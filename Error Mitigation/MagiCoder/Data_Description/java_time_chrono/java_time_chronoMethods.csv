ClassName,Method,Return Type,Description,Full Description
AbstractChronology,compareTo(Chronology other),int,Compares this chronology to another chronology.,"

compareTo
public int compareTo(Chronology other)
Compares this chronology to another chronology.
 
 The comparison order first by the chronology ID string, then by any
 additional information specific to the subclass.
 It is ""consistent with equals"", as defined by Comparable.

Specified by:
compareTo in interface Comparable<Chronology>
Specified by:
compareTo in interface Chronology
Implementation Requirements:
This implementation compares the chronology ID.
 Subclasses must compare any additional state that they store.
Parameters:
other - the other chronology to compare to, not null
Returns:
the comparator value, negative if less, positive if greater


"
AbstractChronology,equals(Object obj),boolean,Checks if this chronology is equal to another chronology.,"

equals
public boolean equals(Object obj)
Checks if this chronology is equal to another chronology.
 
 The comparison is based on the entire state of the object.

Specified by:
equals in interface Chronology
Overrides:
equals in class Object
Implementation Requirements:
This implementation checks the type and calls
 compareTo(java.time.chrono.Chronology).
Parameters:
obj - the object to check, null returns false
Returns:
true if this is equal to the other chronology
See Also:
Object.hashCode(), 
HashMap


"
AbstractChronology,hashCode(),int,A hash code for this chronology.,"

hashCode
public int hashCode()
A hash code for this chronology.
 
 The hash code should be based on the entire state of the object.

Specified by:
hashCode in interface Chronology
Overrides:
hashCode in class Object
Implementation Requirements:
This implementation is based on the chronology ID and class.
 Subclasses should add any additional state that they store.
Returns:
a suitable hash code
See Also:
Object.equals(java.lang.Object), 
System.identityHashCode(java.lang.Object)


"
AbstractChronology,"resolveDate(Map<TemporalField,Long> fieldValues, ResolverStyle resolverStyle)",ChronoLocalDate,Resolves parsed ChronoField values into a date during parsing.,"

resolveDate
public ChronoLocalDate resolveDate(Map<TemporalField,Long> fieldValues,
                                   ResolverStyle resolverStyle)
Resolves parsed ChronoField values into a date during parsing.
 
 Most TemporalField implementations are resolved using the
 resolve method on the field. By contrast, the ChronoField class
 defines fields that only have meaning relative to the chronology.
 As such, ChronoField date fields are resolved here in the
 context of a specific chronology.
 
ChronoField instances are resolved by this method, which may
 be overridden in subclasses.
 
EPOCH_DAY - If present, this is converted to a date and
  all other date fields are then cross-checked against the date.
 PROLEPTIC_MONTH - If present, then it is split into the
  YEAR and MONTH_OF_YEAR. If the mode is strict or smart
  then the field is validated.
 YEAR_OF_ERA and ERA - If both are present, then they
  are combined to form a YEAR. In lenient mode, the YEAR_OF_ERA
  range is not validated, in smart and strict mode it is. The ERA is
  validated for range in all three modes. If only the YEAR_OF_ERA is
  present, and the mode is smart or lenient, then the last available era
  is assumed. In strict mode, no era is assumed and the YEAR_OF_ERA is
  left untouched. If only the ERA is present, then it is left untouched.
 YEAR, MONTH_OF_YEAR and DAY_OF_MONTH -
  If all three are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is smart or strict, then the month and day are validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the first month in the requested year,
  then adding the difference in months, then the difference in days.
  If the mode is smart, and the day-of-month is greater than the maximum for
  the year-month, then the day-of-month is adjusted to the last day-of-month.
  If the mode is strict, then the three fields must form a valid date.
 YEAR and DAY_OF_YEAR -
  If both are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the difference in days.
  If the mode is smart or strict, then the two fields must form a valid date.
 YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and
  ALIGNED_DAY_OF_WEEK_IN_MONTH -
  If all four are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the first month in the requested year, then adding
  the difference in months, then the difference in weeks, then in days.
  If the mode is smart or strict, then the all four fields are validated to
  their outer ranges. The date is then combined in a manner equivalent to
  creating a date on the first day of the requested year and month, then adding
  the amount in weeks and days to reach their values. If the mode is strict,
  the date is additionally validated to check that the day and week adjustment
  did not change the month.
 YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and
  DAY_OF_WEEK - If all four are present, then they are combined to
  form a date. The approach is the same as described above for
  years, months and weeks in ALIGNED_DAY_OF_WEEK_IN_MONTH.
  The day-of-week is adjusted as the next or same matching day-of-week once
  the years, months and weeks have been handled.
 YEAR, ALIGNED_WEEK_OF_YEAR and ALIGNED_DAY_OF_WEEK_IN_YEAR -
  If all three are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the difference in weeks, then in days.
  If the mode is smart or strict, then the all three fields are validated to
  their outer ranges. The date is then combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the amount in weeks and days to reach their values. If the mode is strict,
  the date is additionally validated to check that the day and week adjustment
  did not change the year.
 YEAR, ALIGNED_WEEK_OF_YEAR and DAY_OF_WEEK -
  If all three are present, then they are combined to form a date.
  The approach is the same as described above for years and weeks in
  ALIGNED_DAY_OF_WEEK_IN_YEAR. The day-of-week is adjusted as the
  next or same matching day-of-week once the years and weeks have been handled.
 

 The default implementation is suitable for most calendar systems.
 If ChronoField.YEAR_OF_ERA is found without an ChronoField.ERA
 then the last era in Chronology.eras() is used.
 The implementation assumes a 7 day week, that the first day-of-month
 has the value 1, that first day-of-year has the value 1, and that the
 first of the month and year always exists.

Specified by:
resolveDate in interface Chronology
Parameters:
fieldValues - the map of fields to values, which can be updated, not null
resolverStyle - the requested type of resolve, not null
Returns:
the resolved date, null if insufficient information to create a date
Throws:
DateTimeException - if the date cannot be resolved, typically
  because of a conflict in the input data


"
AbstractChronology,toString(),String,"Outputs this chronology as a String, using the chronology ID.","

toString
public String toString()
Outputs this chronology as a String, using the chronology ID.

Specified by:
toString in interface Chronology
Overrides:
toString in class Object
Returns:
a string representation of this chronology, not null


"
HijrahChronology,"date(Era era, int yearOfEra, int month, int dayOfMonth)",HijrahDate,"Obtains a local date in Hijrah calendar system from the era, year-of-era, month-of-year and day-of-month fields.","

date
public HijrahDate date(Era era,
                       int yearOfEra,
                       int month,
                       int dayOfMonth)
Obtains a local date in Hijrah calendar system from the
 era, year-of-era, month-of-year and day-of-month fields.

Specified by:
date in interface Chronology
Parameters:
era - the Hijrah era, not null
yearOfEra - the year-of-era
month - the month-of-year
dayOfMonth - the day-of-month
Returns:
the Hijrah local date, not null
Throws:
DateTimeException - if unable to create the date
ClassCastException - if the era is not a HijrahEra


"
HijrahChronology,"date(int prolepticYear, int month, int dayOfMonth)",HijrahDate,"Obtains a local date in Hijrah calendar system from the proleptic-year, month-of-year and day-of-month fields.","

date
public HijrahDate date(int prolepticYear,
                       int month,
                       int dayOfMonth)
Obtains a local date in Hijrah calendar system from the
 proleptic-year, month-of-year and day-of-month fields.

Specified by:
date in interface Chronology
Parameters:
prolepticYear - the proleptic-year
month - the month-of-year
dayOfMonth - the day-of-month
Returns:
the Hijrah local date, not null
Throws:
DateTimeException - if unable to create the date


"
HijrahChronology,date(TemporalAccessor temporal),HijrahDate,Obtains a local date in this chronology from another temporal object.,"

date
public HijrahDate date(TemporalAccessor temporal)
Description copied from interface: Chronology
Obtains a local date in this chronology from another temporal object.
 
 This obtains a date in this chronology based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ChronoLocalDate.
 
 The conversion typically uses the EPOCH_DAY
 field, which is standardized across calendar systems.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, aChronology::date.

Specified by:
date in interface Chronology
Parameters:
temporal - the temporal object to convert, not null
Returns:
the local date in this chronology, not null
See Also:
ChronoLocalDate.from(TemporalAccessor)


"
HijrahChronology,dateEpochDay(long epochDay),HijrahDate,Obtains a local date in the Hijrah calendar system from the epoch-day.,"

dateEpochDay
public HijrahDate dateEpochDay(long epochDay)
Obtains a local date in the Hijrah calendar system from the epoch-day.

Specified by:
dateEpochDay in interface Chronology
Parameters:
epochDay - the epoch day
Returns:
the Hijrah local date, not null
Throws:
DateTimeException - if unable to create the date


"
HijrahChronology,dateNow(),HijrahDate,Obtains the current local date in this chronology from the system clock in the default time-zone.,"

dateNow
public HijrahDate dateNow()
Description copied from interface: Chronology
Obtains the current local date in this chronology from the system clock in the default time-zone.
 
 This will query the system clock in the default
 time-zone to obtain the current date.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Specified by:
dateNow in interface Chronology
Returns:
the current local date using the system clock and default time-zone, not null


"
HijrahChronology,dateNow(Clock clock),HijrahDate,Obtains the current local date in this chronology from the specified clock.,"

dateNow
public HijrahDate dateNow(Clock clock)
Description copied from interface: Chronology
Obtains the current local date in this chronology from the specified clock.
 
 This will query the specified clock to obtain the current date - today.
 Using this method allows the use of an alternate clock for testing.
 The alternate clock may be introduced using dependency injection.

Specified by:
dateNow in interface Chronology
Parameters:
clock - the clock to use, not null
Returns:
the current local date, not null


"
HijrahChronology,dateNow(ZoneId zone),HijrahDate,Obtains the current local date in this chronology from the system clock in the specified time-zone.,"

dateNow
public HijrahDate dateNow(ZoneId zone)
Description copied from interface: Chronology
Obtains the current local date in this chronology from the system clock in the specified time-zone.
 
 This will query the system clock to obtain the current date.
 Specifying the time-zone avoids dependence on the default time-zone.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Specified by:
dateNow in interface Chronology
Parameters:
zone - the zone ID to use, not null
Returns:
the current local date using the system clock, not null


"
HijrahChronology,"dateYearDay(Era era, int yearOfEra, int dayOfYear)",HijrahDate,"Obtains a local date in Hijrah calendar system from the era, year-of-era and day-of-year fields.","

dateYearDay
public HijrahDate dateYearDay(Era era,
                              int yearOfEra,
                              int dayOfYear)
Obtains a local date in Hijrah calendar system from the
 era, year-of-era and day-of-year fields.

Specified by:
dateYearDay in interface Chronology
Parameters:
era - the Hijrah era, not null
yearOfEra - the year-of-era
dayOfYear - the day-of-year
Returns:
the Hijrah local date, not null
Throws:
DateTimeException - if unable to create the date
ClassCastException - if the era is not a HijrahEra


"
HijrahChronology,"dateYearDay(int prolepticYear, int dayOfYear)",HijrahDate,Obtains a local date in Hijrah calendar system from the proleptic-year and day-of-year fields.,"

dateYearDay
public HijrahDate dateYearDay(int prolepticYear,
                              int dayOfYear)
Obtains a local date in Hijrah calendar system from the
 proleptic-year and day-of-year fields.

Specified by:
dateYearDay in interface Chronology
Parameters:
prolepticYear - the proleptic-year
dayOfYear - the day-of-year
Returns:
the Hijrah local date, not null
Throws:
DateTimeException - if the value of the year is out of range,
  or if the day-of-year is invalid for the year


"
HijrahChronology,eraOf(int eraValue),HijrahEra,Creates the chronology era object from the numeric value.,"

eraOf
public HijrahEra eraOf(int eraValue)
Description copied from interface: Chronology
Creates the chronology era object from the numeric value.
 
 The era is, conceptually, the largest division of the time-line.
 Most calendar systems have a single epoch dividing the time-line into two eras.
 However, some have multiple eras, such as one for the reign of each leader.
 The exact meaning is determined by the chronology according to the following constraints.
 
 The era in use at 1970-01-01 must have the value 1.
 Later eras must have sequentially higher values.
 Earlier eras must have sequentially lower values.
 Each chronology must refer to an enum or similar singleton to provide the era values.
 
 This method returns the singleton era of the correct type for the specified era value.

Specified by:
eraOf in interface Chronology
Parameters:
eraValue - the era value
Returns:
the calendar system era, not null


"
HijrahChronology,eras(),List<Era>,Gets the list of eras for the chronology.,"

eras
public List<Era> eras()
Description copied from interface: Chronology
Gets the list of eras for the chronology.
 
 Most calendar systems have an era, within which the year has meaning.
 If the calendar system does not support the concept of eras, an empty
 list must be returned.

Specified by:
eras in interface Chronology
Returns:
the list of eras for the chronology, may be immutable, not null


"
HijrahChronology,getCalendarType(),String,Gets the calendar type of the Islamic calendar.,"

getCalendarType
public String getCalendarType()
Gets the calendar type of the Islamic calendar.
 
 The calendar type is an identifier defined by the
 Unicode Locale Data Markup Language (LDML) specification.
 It can be used to lookup the Chronology using Chronology.of(String).

Specified by:
getCalendarType in interface Chronology
Returns:
the calendar system type; non-null if the calendar has
    a standard type, otherwise null
See Also:
getId()


"
HijrahChronology,getId(),String,Gets the ID of the chronology.,"

getId
public String getId()
Gets the ID of the chronology.
 
 The ID uniquely identifies the Chronology. It can be used to
 lookup the Chronology using Chronology.of(String).

Specified by:
getId in interface Chronology
Returns:
the chronology ID, non-null
See Also:
getCalendarType()


"
HijrahChronology,isLeapYear(long prolepticYear),boolean,Checks if the specified year is a leap year.,"

isLeapYear
public boolean isLeapYear(long prolepticYear)
Description copied from interface: Chronology
Checks if the specified year is a leap year.
 
 A leap-year is a year of a longer length than normal.
 The exact meaning is determined by the chronology according to the following constraints.
 
a leap-year must imply a year-length longer than a non leap-year.
 a chronology that does not support the concept of a year must return false.
 

Specified by:
isLeapYear in interface Chronology
Parameters:
prolepticYear - the proleptic-year to check, not validated for range
Returns:
true if the year is a leap year


"
HijrahChronology,localDateTime(TemporalAccessor temporal),ChronoLocalDateTime<HijrahDate>,Obtains a local date-time in this chronology from another temporal object.,"

localDateTime
public ChronoLocalDateTime<HijrahDate> localDateTime(TemporalAccessor temporal)
Description copied from interface: Chronology
Obtains a local date-time in this chronology from another temporal object.
 
 This obtains a date-time in this chronology based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ChronoLocalDateTime.
 
 The conversion extracts and combines the ChronoLocalDate and the
 LocalTime from the temporal object.
 Implementations are permitted to perform optimizations such as accessing
 those fields that are equivalent to the relevant objects.
 The result uses this chronology.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, aChronology::localDateTime.

Specified by:
localDateTime in interface Chronology
Parameters:
temporal - the temporal object to convert, not null
Returns:
the local date-time in this chronology, not null
See Also:
ChronoLocalDateTime.from(TemporalAccessor)


"
HijrahChronology,"prolepticYear(Era era, int yearOfEra)",int,Calculates the proleptic-year given the era and year-of-era.,"

prolepticYear
public int prolepticYear(Era era,
                         int yearOfEra)
Description copied from interface: Chronology
Calculates the proleptic-year given the era and year-of-era.
 
 This combines the era and year-of-era into the single proleptic-year field.
 
 If the chronology makes active use of eras, such as JapaneseChronology
 then the year-of-era will be validated against the era.
 For other chronologies, validation is optional.

Specified by:
prolepticYear in interface Chronology
Parameters:
era - the era of the correct type for the chronology, not null
yearOfEra - the chronology year-of-era
Returns:
the proleptic-year


"
HijrahChronology,range(ChronoField field),ValueRange,Gets the range of valid values for the specified field.,"

range
public ValueRange range(ChronoField field)
Description copied from interface: Chronology
Gets the range of valid values for the specified field.
 
 All fields can be expressed as a long integer.
 This method returns an object that describes the valid range for that value.
 
 Note that the result only describes the minimum and maximum valid values
 and it is important not to read too much into them. For example, there
 could be values within the range that are invalid for the field.
 
 This method will return a result whether or not the chronology supports the field.

Specified by:
range in interface Chronology
Parameters:
field - the field to get the range for, not null
Returns:
the range of valid values for the field, not null


"
HijrahChronology,"resolveDate(Map<TemporalField,Long> fieldValues, ResolverStyle resolverStyle)",HijrahDate,Resolves parsed ChronoField values into a date during parsing.,"

resolveDate
public HijrahDate resolveDate(Map<TemporalField,Long> fieldValues,
                              ResolverStyle resolverStyle)
Description copied from class: AbstractChronology
Resolves parsed ChronoField values into a date during parsing.
 
 Most TemporalField implementations are resolved using the
 resolve method on the field. By contrast, the ChronoField class
 defines fields that only have meaning relative to the chronology.
 As such, ChronoField date fields are resolved here in the
 context of a specific chronology.
 
ChronoField instances are resolved by this method, which may
 be overridden in subclasses.
 
EPOCH_DAY - If present, this is converted to a date and
  all other date fields are then cross-checked against the date.
 PROLEPTIC_MONTH - If present, then it is split into the
  YEAR and MONTH_OF_YEAR. If the mode is strict or smart
  then the field is validated.
 YEAR_OF_ERA and ERA - If both are present, then they
  are combined to form a YEAR. In lenient mode, the YEAR_OF_ERA
  range is not validated, in smart and strict mode it is. The ERA is
  validated for range in all three modes. If only the YEAR_OF_ERA is
  present, and the mode is smart or lenient, then the last available era
  is assumed. In strict mode, no era is assumed and the YEAR_OF_ERA is
  left untouched. If only the ERA is present, then it is left untouched.
 YEAR, MONTH_OF_YEAR and DAY_OF_MONTH -
  If all three are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is smart or strict, then the month and day are validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the first month in the requested year,
  then adding the difference in months, then the difference in days.
  If the mode is smart, and the day-of-month is greater than the maximum for
  the year-month, then the day-of-month is adjusted to the last day-of-month.
  If the mode is strict, then the three fields must form a valid date.
 YEAR and DAY_OF_YEAR -
  If both are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the difference in days.
  If the mode is smart or strict, then the two fields must form a valid date.
 YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and
  ALIGNED_DAY_OF_WEEK_IN_MONTH -
  If all four are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the first month in the requested year, then adding
  the difference in months, then the difference in weeks, then in days.
  If the mode is smart or strict, then the all four fields are validated to
  their outer ranges. The date is then combined in a manner equivalent to
  creating a date on the first day of the requested year and month, then adding
  the amount in weeks and days to reach their values. If the mode is strict,
  the date is additionally validated to check that the day and week adjustment
  did not change the month.
 YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and
  DAY_OF_WEEK - If all four are present, then they are combined to
  form a date. The approach is the same as described above for
  years, months and weeks in ALIGNED_DAY_OF_WEEK_IN_MONTH.
  The day-of-week is adjusted as the next or same matching day-of-week once
  the years, months and weeks have been handled.
 YEAR, ALIGNED_WEEK_OF_YEAR and ALIGNED_DAY_OF_WEEK_IN_YEAR -
  If all three are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the difference in weeks, then in days.
  If the mode is smart or strict, then the all three fields are validated to
  their outer ranges. The date is then combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the amount in weeks and days to reach their values. If the mode is strict,
  the date is additionally validated to check that the day and week adjustment
  did not change the year.
 YEAR, ALIGNED_WEEK_OF_YEAR and DAY_OF_WEEK -
  If all three are present, then they are combined to form a date.
  The approach is the same as described above for years and weeks in
  ALIGNED_DAY_OF_WEEK_IN_YEAR. The day-of-week is adjusted as the
  next or same matching day-of-week once the years and weeks have been handled.
 

 The default implementation is suitable for most calendar systems.
 If ChronoField.YEAR_OF_ERA is found without an ChronoField.ERA
 then the last era in Chronology.eras() is used.
 The implementation assumes a 7 day week, that the first day-of-month
 has the value 1, that first day-of-year has the value 1, and that the
 first of the month and year always exists.

Specified by:
resolveDate in interface Chronology
Overrides:
resolveDate in class AbstractChronology
Parameters:
fieldValues - the map of fields to values, which can be updated, not null
resolverStyle - the requested type of resolve, not null
Returns:
the resolved date, null if insufficient information to create a date


"
HijrahChronology,"zonedDateTime(Instant instant, ZoneId zone)",ChronoZonedDateTime<HijrahDate>,Obtains a ChronoZonedDateTime in this chronology from an Instant.,"

zonedDateTime
public ChronoZonedDateTime<HijrahDate> zonedDateTime(Instant instant,
                                                     ZoneId zone)
Description copied from interface: Chronology
Obtains a ChronoZonedDateTime in this chronology from an Instant.
 
 This obtains a zoned date-time with the same instant as that specified.

Specified by:
zonedDateTime in interface Chronology
Parameters:
instant - the instant to create the date-time from, not null
zone - the time-zone, not null
Returns:
the zoned date-time, not null


"
HijrahChronology,zonedDateTime(TemporalAccessor temporal),ChronoZonedDateTime<HijrahDate>,Obtains a ChronoZonedDateTime in this chronology from another temporal object.,"

zonedDateTime
public ChronoZonedDateTime<HijrahDate> zonedDateTime(TemporalAccessor temporal)
Description copied from interface: Chronology
Obtains a ChronoZonedDateTime in this chronology from another temporal object.
 
 This obtains a zoned date-time in this chronology based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ChronoZonedDateTime.
 
 The conversion will first obtain a ZoneId from the temporal object,
 falling back to a ZoneOffset if necessary. It will then try to obtain
 an Instant, falling back to a ChronoLocalDateTime if necessary.
 The result will be either the combination of ZoneId or ZoneOffset
 with Instant or ChronoLocalDateTime.
 Implementations are permitted to perform optimizations such as accessing
 those fields that are equivalent to the relevant objects.
 The result uses this chronology.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, aChronology::zonedDateTime.

Specified by:
zonedDateTime in interface Chronology
Parameters:
temporal - the temporal object to convert, not null
Returns:
the zoned date-time in this chronology, not null
See Also:
ChronoZonedDateTime.from(TemporalAccessor)


"
HijrahDate,atTime(LocalTime localTime),ChronoLocalDateTime<HijrahDate>,Combines this date with a time to create a ChronoLocalDateTime.,"

atTime
public final ChronoLocalDateTime<HijrahDate> atTime(LocalTime localTime)
Description copied from interface: ChronoLocalDate
Combines this date with a time to create a ChronoLocalDateTime.
 
 This returns a ChronoLocalDateTime formed from this date at the specified time.
 All possible combinations of date and time are valid.

Specified by:
atTime in interface ChronoLocalDate
Parameters:
localTime - the local time to use, not null
Returns:
the local date-time formed from this date and the specified time, not null


"
HijrahDate,equals(Object obj),boolean,"Compares this date to another date, including the chronology.","

equals
public boolean equals(Object obj)
Compares this date to another date, including the chronology.
 
 Compares this HijrahDate with another ensuring that the date is the same.
 
 Only objects of type HijrahDate are compared, other types return false.
 To compare the dates of two TemporalAccessor instances, including dates
 in two different chronologies, use ChronoField.EPOCH_DAY as a comparator.

Specified by:
equals in interface ChronoLocalDate
Parameters:
obj - the object to check, null returns false
Returns:
true if this is equal to the other date and the Chronologies are equal
See Also:
Object.hashCode(), 
HashMap


"
HijrahDate,from(TemporalAccessor temporal),static HijrahDate,Obtains a HijrahDate of the Islamic Umm Al-Qura calendar from a temporal object.,"

from
public static HijrahDate from(TemporalAccessor temporal)
Obtains a HijrahDate of the Islamic Umm Al-Qura calendar from a temporal object.
 
 This obtains a date in the Hijrah calendar system based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of HijrahDate.
 
 The conversion typically uses the EPOCH_DAY
 field, which is standardized across calendar systems.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, HijrahDate::from.

Specified by:
from in interface ChronoLocalDate
Parameters:
temporal - the temporal object to convert, not null
Returns:
the date in Hijrah calendar system, not null
Throws:
DateTimeException - if unable to convert to a HijrahDate
See Also:
Chronology.date(TemporalAccessor)


"
HijrahDate,getChronology(),HijrahChronology,"Gets the chronology of this date, which is the Hijrah calendar system.","

getChronology
public HijrahChronology getChronology()
Gets the chronology of this date, which is the Hijrah calendar system.
 
 The Chronology represents the calendar system in use.
 The era and other fields in ChronoField are defined by the chronology.

Specified by:
getChronology in interface ChronoLocalDate
Returns:
the Hijrah chronology, not null


"
HijrahDate,getEra(),HijrahEra,Gets the era applicable at this date.,"

getEra
public HijrahEra getEra()
Gets the era applicable at this date.
 
 The Hijrah calendar system has one era, 'AH',
 defined by HijrahEra.

Specified by:
getEra in interface ChronoLocalDate
Returns:
the era applicable at this date, not null


"
HijrahDate,getLong(TemporalField field),long,Gets the value of the specified field as a long.,"

getLong
public long getLong(TemporalField field)
Description copied from interface: TemporalAccessor
Gets the value of the specified field as a long.
 
 This queries the date-time for the value of the specified field.
 The returned value may be outside the valid range of values for the field.
 If the date-time cannot return the value, because the field is unsupported or for
 some other reason, an exception will be thrown.

Specified by:
getLong in interface TemporalAccessor
Parameters:
field - the field to get, not null
Returns:
the value for the field


"
HijrahDate,hashCode(),int,A hash code for this date.,"

hashCode
public int hashCode()
A hash code for this date.

Specified by:
hashCode in interface ChronoLocalDate
Returns:
a suitable hash code based only on the Chronology and the date
See Also:
Object.equals(java.lang.Object), 
System.identityHashCode(java.lang.Object)


"
HijrahDate,isLeapYear(),boolean,"Checks if the year is a leap year, according to the Hijrah calendar system rules.","

isLeapYear
public boolean isLeapYear()
Checks if the year is a leap year, according to the Hijrah calendar system rules.

Specified by:
isLeapYear in interface ChronoLocalDate
Returns:
true if this date is in a leap year


"
HijrahDate,lengthOfMonth(),int,Returns the length of the month represented by this date.,"

lengthOfMonth
public int lengthOfMonth()
Returns the length of the month represented by this date.
 
 This returns the length of the month in days.
 Month lengths in the Hijrah calendar system vary between 29 and 30 days.

Specified by:
lengthOfMonth in interface ChronoLocalDate
Returns:
the length of the month in days


"
HijrahDate,lengthOfYear(),int,Returns the length of the year represented by this date.,"

lengthOfYear
public int lengthOfYear()
Returns the length of the year represented by this date.
 
 This returns the length of the year in days.
 A Hijrah calendar system year is typically shorter than
 that of the ISO calendar system.

Specified by:
lengthOfYear in interface ChronoLocalDate
Returns:
the length of the year in days


"
HijrahDate,"minus(long amountToSubtract, TemporalUnit unit)",HijrahDate,Returns an object of the same type as this object with the specified period subtracted.,"

minus
public HijrahDate minus(long amountToSubtract,
                        TemporalUnit unit)
Description copied from interface: ChronoLocalDate
Returns an object of the same type as this object with the specified period subtracted.
 
 This method returns a new object based on this one with the specified period subtracted.
 For example, on a LocalDate, this could be used to subtract a number of years, months or days.
 The returned object will have the same observable type as this object.
 
 In some cases, changing a field is not fully defined. For example, if the target object is
 a date representing the 31st March, then subtracting one month would be unclear.
 In cases like this, the field is responsible for resolving the result. Typically it will choose
 the previous valid date, which would be the last valid day of February in this example.

Specified by:
minus in interface ChronoLocalDate
Specified by:
minus in interface Temporal
Parameters:
amountToSubtract - the amount of the specified unit to subtract, may be negative
unit - the unit of the amount to subtract, not null
Returns:
an object of the same type with the specified period subtracted, not null


"
HijrahDate,minus(TemporalAmount amount),HijrahDate,Returns an object of the same type as this object with an amount subtracted.,"

minus
public HijrahDate minus(TemporalAmount amount)
Returns an object of the same type as this object with an amount subtracted.
 
 This adjusts this temporal, subtracting according to the rules of the specified amount.
 The amount is typically a Period but may be any other type implementing
 the TemporalAmount interface, such as Duration.
 
 Some example code indicating how and why this method is used:
 
  date = date.minus(period);               // subtract a Period instance
  date = date.minus(duration);             // subtract a Duration instance
  date = date.minus(workingDays(6));       // example user-written workingDays method
 

 Note that calling plus followed by minus is not guaranteed to
 return the same date-time.

Specified by:
minus in interface ChronoLocalDate
Specified by:
minus in interface Temporal
Parameters:
amount - the amount to subtract, not null
Returns:
an object of the same type with the specified adjustment made, not null
Throws:
DateTimeException - if the subtraction cannot be made
ArithmeticException - if numeric overflow occurs


"
HijrahDate,now(),static HijrahDate,Obtains the current HijrahDate of the Islamic Umm Al-Qura calendar in the default time-zone.,"

now
public static HijrahDate now()
Obtains the current HijrahDate of the Islamic Umm Al-Qura calendar
 in the default time-zone.
 
 This will query the system clock in the default
 time-zone to obtain the current date.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Returns:
the current date using the system clock and default time-zone, not null


"
HijrahDate,now(Clock clock),static HijrahDate,Obtains the current HijrahDate of the Islamic Umm Al-Qura calendar from the specified clock.,"

now
public static HijrahDate now(Clock clock)
Obtains the current HijrahDate of the Islamic Umm Al-Qura calendar
 from the specified clock.
 
 This will query the specified clock to obtain the current date - today.
 Using this method allows the use of an alternate clock for testing.
 The alternate clock may be introduced using dependency injection.

Parameters:
clock - the clock to use, not null
Returns:
the current date, not null
Throws:
DateTimeException - if the current date cannot be obtained


"
HijrahDate,now(ZoneId zone),static HijrahDate,Obtains the current HijrahDate of the Islamic Umm Al-Qura calendar in the specified time-zone.,"

now
public static HijrahDate now(ZoneId zone)
Obtains the current HijrahDate of the Islamic Umm Al-Qura calendar
 in the specified time-zone.
 
 This will query the system clock to obtain the current date.
 Specifying the time-zone avoids dependence on the default time-zone.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Parameters:
zone - the zone ID to use, not null
Returns:
the current date using the system clock, not null


"
HijrahDate,"of(int prolepticYear, int month, int dayOfMonth)",static HijrahDate,"Obtains a HijrahDate of the Islamic Umm Al-Qura calendar from the proleptic-year, month-of-year and day-of-month fields.","

of
public static HijrahDate of(int prolepticYear,
                            int month,
                            int dayOfMonth)
Obtains a HijrahDate of the Islamic Umm Al-Qura calendar
 from the proleptic-year, month-of-year and day-of-month fields.
 
 This returns a HijrahDate with the specified fields.
 The day must be valid for the year and month, otherwise an exception will be thrown.

Parameters:
prolepticYear - the Hijrah proleptic-year
month - the Hijrah month-of-year, from 1 to 12
dayOfMonth - the Hijrah day-of-month, from 1 to 30
Returns:
the date in Hijrah calendar system, not null
Throws:
DateTimeException - if the value of any field is out of range,
  or if the day-of-month is invalid for the month-year


"
HijrahDate,"plus(long amountToAdd, TemporalUnit unit)",HijrahDate,Returns an object of the same type as this object with the specified period added.,"

plus
public HijrahDate plus(long amountToAdd,
                       TemporalUnit unit)
Description copied from interface: ChronoLocalDate
Returns an object of the same type as this object with the specified period added.
 
 This method returns a new object based on this one with the specified period added.
 For example, on a LocalDate, this could be used to add a number of years, months or days.
 The returned object will have the same observable type as this object.
 
 In some cases, changing a field is not fully defined. For example, if the target object is
 a date representing the 31st January, then adding one month would be unclear.
 In cases like this, the field is responsible for resolving the result. Typically it will choose
 the previous valid date, which would be the last valid day of February in this example.

Specified by:
plus in interface ChronoLocalDate
Specified by:
plus in interface Temporal
Parameters:
amountToAdd - the amount of the specified unit to add, may be negative
unit - the unit of the amount to add, not null
Returns:
an object of the same type with the specified period added, not null


"
HijrahDate,plus(TemporalAmount amount),HijrahDate,Returns an object of the same type as this object with an amount added.,"

plus
public HijrahDate plus(TemporalAmount amount)
Returns an object of the same type as this object with an amount added.
 
 This adjusts this temporal, adding according to the rules of the specified amount.
 The amount is typically a Period but may be any other type implementing
 the TemporalAmount interface, such as Duration.
 
 Some example code indicating how and why this method is used:
 
  date = date.plus(period);                // add a Period instance
  date = date.plus(duration);              // add a Duration instance
  date = date.plus(workingDays(6));        // example user-written workingDays method
 

 Note that calling plus followed by minus is not guaranteed to
 return the same date-time.

Specified by:
plus in interface ChronoLocalDate
Specified by:
plus in interface Temporal
Parameters:
amount - the amount to add, not null
Returns:
an object of the same type with the specified adjustment made, not null
Throws:
DateTimeException - if the addition cannot be made
ArithmeticException - if numeric overflow occurs


"
HijrahDate,range(TemporalField field),ValueRange,Gets the range of valid values for the specified field.,"

range
public ValueRange range(TemporalField field)
Description copied from interface: TemporalAccessor
Gets the range of valid values for the specified field.
 
 All fields can be expressed as a long integer.
 This method returns an object that describes the valid range for that value.
 The value of this temporal object is used to enhance the accuracy of the returned range.
 If the date-time cannot return the range, because the field is unsupported or for
 some other reason, an exception will be thrown.
 
 Note that the result only describes the minimum and maximum valid values
 and it is important not to read too much into them. For example, there
 could be values within the range that are invalid for the field.

Specified by:
range in interface TemporalAccessor
Parameters:
field - the field to query the range for, not null
Returns:
the range of valid values for the field, not null


"
HijrahDate,toEpochDay(),long,Converts this date to the Epoch Day.,"

toEpochDay
public long toEpochDay()
Description copied from interface: ChronoLocalDate
Converts this date to the Epoch Day.
 
 The Epoch Day count is a simple
 incrementing count of days where day 0 is 1970-01-01 (ISO).
 This definition is the same for all chronologies, enabling conversion.
 
 This default implementation queries the EPOCH_DAY field.

Specified by:
toEpochDay in interface ChronoLocalDate
Returns:
the Epoch Day equivalent to this date


"
HijrahDate,toString(),String,Returns a string representation of the object.,"

toString
public String toString()
Description copied from class: Object
Returns a string representation of the object. In general, the
 toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method.
 
 The toString method for class Object
 returns a string consisting of the name of the class of which the
 object is an instance, the at-sign character `@', and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words, this method returns a string equal to the
 value of:
 

 getClass().getName() + '@' + Integer.toHexString(hashCode())
 

Specified by:
toString in interface ChronoLocalDate
Overrides:
toString in class Object
Returns:
a string representation of the object.


"
HijrahDate,until(ChronoLocalDate endDate),ChronoPeriod,Calculates the period between this date and another date as a ChronoPeriod.,"

until
public ChronoPeriod until(ChronoLocalDate endDate)
Description copied from interface: ChronoLocalDate
Calculates the period between this date and another date as a ChronoPeriod.
 
 This calculates the period between two dates. All supplied chronologies
 calculate the period using years, months and days, however the
 ChronoPeriod API allows the period to be represented using other units.
 
 The start and end points are this and the specified date.
 The result will be negative if the end is before the start.
 The negative sign will be the same in each of year, month and day.
 
 The calculation is performed using the chronology of this date.
 If necessary, the input date will be converted to match.
 
 This instance is immutable and unaffected by this method call.

Specified by:
until in interface ChronoLocalDate
Parameters:
endDate - the end date, exclusive, which may be in any chronology, not null
Returns:
the period between this date and the end date, not null


"
HijrahDate,"until(Temporal endExclusive, TemporalUnit unit)",long,Calculates the amount of time until another date in terms of the specified unit.,"

until
public long until(Temporal endExclusive,
                  TemporalUnit unit)
Description copied from interface: ChronoLocalDate
Calculates the amount of time until another date in terms of the specified unit.
 
 This calculates the amount of time between two ChronoLocalDate
 objects in terms of a single TemporalUnit.
 The start and end points are this and the specified date.
 The result will be negative if the end is before the start.
 The Temporal passed to this method is converted to a
 ChronoLocalDate using Chronology.date(TemporalAccessor).
 The calculation returns a whole number, representing the number of
 complete units between the two dates.
 For example, the amount in days between two dates can be calculated
 using startDate.until(endDate, DAYS).
 
 There are two equivalent ways of using this method.
 The first is to invoke this method.
 The second is to use TemporalUnit.between(Temporal, Temporal):
 
   // these two lines are equivalent
   amount = start.until(end, MONTHS);
   amount = MONTHS.between(start, end);
 
 The choice should be made based on which makes the code more readable.
 
 The calculation is implemented in this method for ChronoUnit.
 The units DAYS, WEEKS, MONTHS, YEARS,
 DECADES, CENTURIES, MILLENNIA and ERAS
 should be supported by all implementations.
 Other ChronoUnit values will throw an exception.
 
 If the unit is not a ChronoUnit, then the result of this method
 is obtained by invoking TemporalUnit.between(Temporal, Temporal)
 passing this as the first argument and the converted input temporal as
 the second argument.
 
 This instance is immutable and unaffected by this method call.

Specified by:
until in interface ChronoLocalDate
Specified by:
until in interface Temporal
Parameters:
endExclusive - the end date, exclusive, which is converted to a
  ChronoLocalDate in the same chronology, not null
unit - the unit to measure the amount in, not null
Returns:
the amount of time between this date and the end date


"
HijrahDate,with(TemporalAdjuster adjuster),HijrahDate,Returns an adjusted object of the same type as this object with the adjustment made.,"

with
public HijrahDate with(TemporalAdjuster adjuster)
Returns an adjusted object of the same type as this object with the adjustment made.
 
 This adjusts this date-time according to the rules of the specified adjuster.
 A simple adjuster might simply set the one of the fields, such as the year field.
 A more complex adjuster might set the date to the last day of the month.
 A selection of common adjustments is provided in
 TemporalAdjusters.
 These include finding the ""last day of the month"" and ""next Wednesday"".
 The adjuster is responsible for handling special cases, such as the varying
 lengths of month and leap years.
 
 Some example code indicating how and why this method is used:
 
  date = date.with(Month.JULY);        // most key classes implement TemporalAdjuster
  date = date.with(lastDayOfMonth());  // static import from Adjusters
  date = date.with(next(WEDNESDAY));   // static import from Adjusters and DayOfWeek
 

Specified by:
with in interface ChronoLocalDate
Specified by:
with in interface Temporal
Parameters:
adjuster - the adjuster to use, not null
Returns:
an object of the same type with the specified adjustment made, not null
Throws:
DateTimeException - if unable to make the adjustment.
     For example, if the adjuster requires an ISO chronology
ArithmeticException - if numeric overflow occurs


"
HijrahDate,"with(TemporalField field, long newValue)",HijrahDate,Returns an object of the same type as this object with the specified field altered.,"

with
public HijrahDate with(TemporalField field,
                       long newValue)
Description copied from interface: ChronoLocalDate
Returns an object of the same type as this object with the specified field altered.
 
 This returns a new object based on this one with the value for the specified field changed.
 For example, on a LocalDate, this could be used to set the year, month or day-of-month.
 The returned object will have the same observable type as this object.
 
 In some cases, changing a field is not fully defined. For example, if the target object is
 a date representing the 31st January, then changing the month to February would be unclear.
 In cases like this, the field is responsible for resolving the result. Typically it will choose
 the previous valid date, which would be the last valid day of February in this example.

Specified by:
with in interface ChronoLocalDate
Specified by:
with in interface Temporal
Parameters:
field - the field to set in the result, not null
newValue - the new value of the field in the result
Returns:
an object of the same type with the specified field set, not null


"
HijrahDate,withVariant(HijrahChronology chronology),HijrahDate,Returns a HijrahDate with the Chronology requested.,"

withVariant
public HijrahDate withVariant(HijrahChronology chronology)
Returns a HijrahDate with the Chronology requested.
 
 The year, month, and day are checked against the new requested
 HijrahChronology.  If the chronology has a shorter month length
 for the month, the day is reduced to be the last day of the month.

Parameters:
chronology - the new HijrahChonology, non-null
Returns:
a HijrahDate with the requested HijrahChronology, non-null


"
IsoChronology,"date(Era era, int yearOfEra, int month, int dayOfMonth)",LocalDate,"Obtains an ISO local date from the era, year-of-era, month-of-year and day-of-month fields.","

date
public LocalDate date(Era era,
                      int yearOfEra,
                      int month,
                      int dayOfMonth)
Obtains an ISO local date from the era, year-of-era, month-of-year
 and day-of-month fields.

Specified by:
date in interface Chronology
Parameters:
era - the ISO era, not null
yearOfEra - the ISO year-of-era
month - the ISO month-of-year
dayOfMonth - the ISO day-of-month
Returns:
the ISO local date, not null
Throws:
DateTimeException - if unable to create the date
ClassCastException - if the type of era is not IsoEra


"
IsoChronology,"date(int prolepticYear, int month, int dayOfMonth)",LocalDate,"Obtains an ISO local date from the proleptic-year, month-of-year and day-of-month fields.","

date
public LocalDate date(int prolepticYear,
                      int month,
                      int dayOfMonth)
Obtains an ISO local date from the proleptic-year, month-of-year
 and day-of-month fields.
 
 This is equivalent to LocalDate.of(int, int, int).

Specified by:
date in interface Chronology
Parameters:
prolepticYear - the ISO proleptic-year
month - the ISO month-of-year
dayOfMonth - the ISO day-of-month
Returns:
the ISO local date, not null
Throws:
DateTimeException - if unable to create the date


"
IsoChronology,date(TemporalAccessor temporal),LocalDate,Obtains an ISO local date from another date-time object.,"

date
public LocalDate date(TemporalAccessor temporal)
Obtains an ISO local date from another date-time object.
 
 This is equivalent to LocalDate.from(TemporalAccessor).

Specified by:
date in interface Chronology
Parameters:
temporal - the date-time object to convert, not null
Returns:
the ISO local date, not null
Throws:
DateTimeException - if unable to create the date
See Also:
ChronoLocalDate.from(TemporalAccessor)


"
IsoChronology,dateEpochDay(long epochDay),LocalDate,Obtains an ISO local date from the epoch-day.,"

dateEpochDay
public LocalDate dateEpochDay(long epochDay)
Obtains an ISO local date from the epoch-day.
 
 This is equivalent to LocalDate.ofEpochDay(long).

Specified by:
dateEpochDay in interface Chronology
Parameters:
epochDay - the epoch day
Returns:
the ISO local date, not null
Throws:
DateTimeException - if unable to create the date


"
IsoChronology,dateNow(),LocalDate,Obtains the current ISO local date from the system clock in the default time-zone.,"

dateNow
public LocalDate dateNow()
Obtains the current ISO local date from the system clock in the default time-zone.
 
 This will query the system clock in the default
 time-zone to obtain the current date.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Specified by:
dateNow in interface Chronology
Returns:
the current ISO local date using the system clock and default time-zone, not null
Throws:
DateTimeException - if unable to create the date


"
IsoChronology,dateNow(Clock clock),LocalDate,Obtains the current ISO local date from the specified clock.,"

dateNow
public LocalDate dateNow(Clock clock)
Obtains the current ISO local date from the specified clock.
 
 This will query the specified clock to obtain the current date - today.
 Using this method allows the use of an alternate clock for testing.
 The alternate clock may be introduced using dependency injection.

Specified by:
dateNow in interface Chronology
Parameters:
clock - the clock to use, not null
Returns:
the current ISO local date, not null
Throws:
DateTimeException - if unable to create the date


"
IsoChronology,dateNow(ZoneId zone),LocalDate,Obtains the current ISO local date from the system clock in the specified time-zone.,"

dateNow
public LocalDate dateNow(ZoneId zone)
Obtains the current ISO local date from the system clock in the specified time-zone.
 
 This will query the system clock to obtain the current date.
 Specifying the time-zone avoids dependence on the default time-zone.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Specified by:
dateNow in interface Chronology
Parameters:
zone - the zone ID to use, not null
Returns:
the current ISO local date using the system clock, not null
Throws:
DateTimeException - if unable to create the date


"
IsoChronology,"dateYearDay(Era era, int yearOfEra, int dayOfYear)",LocalDate,"Obtains an ISO local date from the era, year-of-era and day-of-year fields.","

dateYearDay
public LocalDate dateYearDay(Era era,
                             int yearOfEra,
                             int dayOfYear)
Obtains an ISO local date from the era, year-of-era and day-of-year fields.

Specified by:
dateYearDay in interface Chronology
Parameters:
era - the ISO era, not null
yearOfEra - the ISO year-of-era
dayOfYear - the ISO day-of-year
Returns:
the ISO local date, not null
Throws:
DateTimeException - if unable to create the date


"
IsoChronology,"dateYearDay(int prolepticYear, int dayOfYear)",LocalDate,Obtains an ISO local date from the proleptic-year and day-of-year fields.,"

dateYearDay
public LocalDate dateYearDay(int prolepticYear,
                             int dayOfYear)
Obtains an ISO local date from the proleptic-year and day-of-year fields.
 
 This is equivalent to LocalDate.ofYearDay(int, int).

Specified by:
dateYearDay in interface Chronology
Parameters:
prolepticYear - the ISO proleptic-year
dayOfYear - the ISO day-of-year
Returns:
the ISO local date, not null
Throws:
DateTimeException - if unable to create the date


"
IsoChronology,eraOf(int eraValue),IsoEra,Creates the chronology era object from the numeric value.,"

eraOf
public IsoEra eraOf(int eraValue)
Description copied from interface: Chronology
Creates the chronology era object from the numeric value.
 
 The era is, conceptually, the largest division of the time-line.
 Most calendar systems have a single epoch dividing the time-line into two eras.
 However, some have multiple eras, such as one for the reign of each leader.
 The exact meaning is determined by the chronology according to the following constraints.
 
 The era in use at 1970-01-01 must have the value 1.
 Later eras must have sequentially higher values.
 Earlier eras must have sequentially lower values.
 Each chronology must refer to an enum or similar singleton to provide the era values.
 
 This method returns the singleton era of the correct type for the specified era value.

Specified by:
eraOf in interface Chronology
Parameters:
eraValue - the era value
Returns:
the calendar system era, not null


"
IsoChronology,eras(),List<Era>,Gets the list of eras for the chronology.,"

eras
public List<Era> eras()
Description copied from interface: Chronology
Gets the list of eras for the chronology.
 
 Most calendar systems have an era, within which the year has meaning.
 If the calendar system does not support the concept of eras, an empty
 list must be returned.

Specified by:
eras in interface Chronology
Returns:
the list of eras for the chronology, may be immutable, not null


"
IsoChronology,getCalendarType(),String,Gets the calendar type of the underlying calendar system - 'iso8601'.,"

getCalendarType
public String getCalendarType()
Gets the calendar type of the underlying calendar system - 'iso8601'.
 
 The calendar type is an identifier defined by the
 Unicode Locale Data Markup Language (LDML) specification.
 It can be used to lookup the Chronology using Chronology.of(String).
 It can also be used as part of a locale, accessible via
 Locale.getUnicodeLocaleType(String) with the key 'ca'.

Specified by:
getCalendarType in interface Chronology
Returns:
the calendar system type - 'iso8601'
See Also:
getId()


"
IsoChronology,getId(),String,Gets the ID of the chronology - 'ISO'.,"

getId
public String getId()
Gets the ID of the chronology - 'ISO'.
 
 The ID uniquely identifies the Chronology.
 It can be used to lookup the Chronology using Chronology.of(String).

Specified by:
getId in interface Chronology
Returns:
the chronology ID - 'ISO'
See Also:
getCalendarType()


"
IsoChronology,isLeapYear(long prolepticYear),boolean,"Checks if the year is a leap year, according to the ISO proleptic calendar system rules.","

isLeapYear
public boolean isLeapYear(long prolepticYear)
Checks if the year is a leap year, according to the ISO proleptic
 calendar system rules.
 
 This method applies the current rules for leap years across the whole time-line.
 In general, a year is a leap year if it is divisible by four without
 remainder. However, years divisible by 100, are not leap years, with
 the exception of years divisible by 400 which are.
 
 For example, 1904 is a leap year it is divisible by 4.
 1900 was not a leap year as it is divisible by 100, however 2000 was a
 leap year as it is divisible by 400.
 
 The calculation is proleptic - applying the same rules into the far future and far past.
 This is historically inaccurate, but is correct for the ISO-8601 standard.

Specified by:
isLeapYear in interface Chronology
Parameters:
prolepticYear - the ISO proleptic year to check
Returns:
true if the year is leap, false otherwise


"
IsoChronology,localDateTime(TemporalAccessor temporal),LocalDateTime,Obtains an ISO local date-time from another date-time object.,"

localDateTime
public LocalDateTime localDateTime(TemporalAccessor temporal)
Obtains an ISO local date-time from another date-time object.
 
 This is equivalent to LocalDateTime.from(TemporalAccessor).

Specified by:
localDateTime in interface Chronology
Parameters:
temporal - the date-time object to convert, not null
Returns:
the ISO local date-time, not null
Throws:
DateTimeException - if unable to create the date-time
See Also:
ChronoLocalDateTime.from(TemporalAccessor)


"
IsoChronology,"period(int years, int months, int days)",Period,"Obtains a period for this chronology based on years, months and days.","

period
public Period period(int years,
                     int months,
                     int days)
Obtains a period for this chronology based on years, months and days.
 
 This returns a period tied to the ISO chronology using the specified
 years, months and days. See Period for further details.

Specified by:
period in interface Chronology
Parameters:
years - the number of years, may be negative
months - the number of years, may be negative
days - the number of years, may be negative
Returns:
the period in terms of this chronology, not null


"
IsoChronology,"prolepticYear(Era era, int yearOfEra)",int,Calculates the proleptic-year given the era and year-of-era.,"

prolepticYear
public int prolepticYear(Era era,
                         int yearOfEra)
Description copied from interface: Chronology
Calculates the proleptic-year given the era and year-of-era.
 
 This combines the era and year-of-era into the single proleptic-year field.
 
 If the chronology makes active use of eras, such as JapaneseChronology
 then the year-of-era will be validated against the era.
 For other chronologies, validation is optional.

Specified by:
prolepticYear in interface Chronology
Parameters:
era - the era of the correct type for the chronology, not null
yearOfEra - the chronology year-of-era
Returns:
the proleptic-year


"
IsoChronology,range(ChronoField field),ValueRange,Gets the range of valid values for the specified field.,"

range
public ValueRange range(ChronoField field)
Description copied from interface: Chronology
Gets the range of valid values for the specified field.
 
 All fields can be expressed as a long integer.
 This method returns an object that describes the valid range for that value.
 
 Note that the result only describes the minimum and maximum valid values
 and it is important not to read too much into them. For example, there
 could be values within the range that are invalid for the field.
 
 This method will return a result whether or not the chronology supports the field.

Specified by:
range in interface Chronology
Parameters:
field - the field to get the range for, not null
Returns:
the range of valid values for the field, not null


"
IsoChronology,"resolveDate(Map<TemporalField,Long> fieldValues, ResolverStyle resolverStyle)",LocalDate,Resolves parsed ChronoField values into a date during parsing.,"

resolveDate
public LocalDate resolveDate(Map<TemporalField,Long> fieldValues,
                             ResolverStyle resolverStyle)
Resolves parsed ChronoField values into a date during parsing.
 
 Most TemporalField implementations are resolved using the
 resolve method on the field. By contrast, the ChronoField class
 defines fields that only have meaning relative to the chronology.
 As such, ChronoField date fields are resolved here in the
 context of a specific chronology.
 
ChronoField instances on the ISO calendar system are resolved
 as follows.
 
EPOCH_DAY - If present, this is converted to a LocalDate
  and all other date fields are then cross-checked against the date.
 PROLEPTIC_MONTH - If present, then it is split into the
  YEAR and MONTH_OF_YEAR. If the mode is strict or smart
  then the field is validated.
 YEAR_OF_ERA and ERA - If both are present, then they
  are combined to form a YEAR. In lenient mode, the YEAR_OF_ERA
  range is not validated, in smart and strict mode it is. The ERA is
  validated for range in all three modes. If only the YEAR_OF_ERA is
  present, and the mode is smart or lenient, then the current era (CE/AD)
  is assumed. In strict mode, no era is assumed and the YEAR_OF_ERA is
  left untouched. If only the ERA is present, then it is left untouched.
 YEAR, MONTH_OF_YEAR and DAY_OF_MONTH -
  If all three are present, then they are combined to form a LocalDate.
  In all three modes, the YEAR is validated. If the mode is smart or strict,
  then the month and day are validated, with the day validated from 1 to 31.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first of January in the requested year, then adding
  the difference in months, then the difference in days.
  If the mode is smart, and the day-of-month is greater than the maximum for
  the year-month, then the day-of-month is adjusted to the last day-of-month.
  If the mode is strict, then the three fields must form a valid date.
 YEAR and DAY_OF_YEAR -
  If both are present, then they are combined to form a LocalDate.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first of January in the requested year, then adding
  the difference in days.
  If the mode is smart or strict, then the two fields must form a valid date.
 YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and
  ALIGNED_DAY_OF_WEEK_IN_MONTH -
  If all four are present, then they are combined to form a LocalDate.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first of January in the requested year, then adding
  the difference in months, then the difference in weeks, then in days.
  If the mode is smart or strict, then the all four fields are validated to
  their outer ranges. The date is then combined in a manner equivalent to
  creating a date on the first day of the requested year and month, then adding
  the amount in weeks and days to reach their values. If the mode is strict,
  the date is additionally validated to check that the day and week adjustment
  did not change the month.
 YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and
  DAY_OF_WEEK - If all four are present, then they are combined to
  form a LocalDate. The approach is the same as described above for
  years, months and weeks in ALIGNED_DAY_OF_WEEK_IN_MONTH.
  The day-of-week is adjusted as the next or same matching day-of-week once
  the years, months and weeks have been handled.
 YEAR, ALIGNED_WEEK_OF_YEAR and ALIGNED_DAY_OF_WEEK_IN_YEAR -
  If all three are present, then they are combined to form a LocalDate.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first of January in the requested year, then adding
  the difference in weeks, then in days.
  If the mode is smart or strict, then the all three fields are validated to
  their outer ranges. The date is then combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the amount in weeks and days to reach their values. If the mode is strict,
  the date is additionally validated to check that the day and week adjustment
  did not change the year.
 YEAR, ALIGNED_WEEK_OF_YEAR and DAY_OF_WEEK -
  If all three are present, then they are combined to form a LocalDate.
  The approach is the same as described above for years and weeks in
  ALIGNED_DAY_OF_WEEK_IN_YEAR. The day-of-week is adjusted as the
  next or same matching day-of-week once the years and weeks have been handled.
 

Specified by:
resolveDate in interface Chronology
Overrides:
resolveDate in class AbstractChronology
Parameters:
fieldValues - the map of fields to values, which can be updated, not null
resolverStyle - the requested type of resolve, not null
Returns:
the resolved date, null if insufficient information to create a date
Throws:
DateTimeException - if the date cannot be resolved, typically
  because of a conflict in the input data


"
IsoChronology,"zonedDateTime(Instant instant, ZoneId zone)",ZonedDateTime,Obtains an ISO zoned date-time in this chronology from an Instant.,"

zonedDateTime
public ZonedDateTime zonedDateTime(Instant instant,
                                   ZoneId zone)
Obtains an ISO zoned date-time in this chronology from an Instant.
 
 This is equivalent to ZonedDateTime.ofInstant(Instant, ZoneId).

Specified by:
zonedDateTime in interface Chronology
Parameters:
instant - the instant to create the date-time from, not null
zone - the time-zone, not null
Returns:
the zoned date-time, not null
Throws:
DateTimeException - if the result exceeds the supported range


"
IsoChronology,zonedDateTime(TemporalAccessor temporal),ZonedDateTime,Obtains an ISO zoned date-time from another date-time object.,"

zonedDateTime
public ZonedDateTime zonedDateTime(TemporalAccessor temporal)
Obtains an ISO zoned date-time from another date-time object.
 
 This is equivalent to ZonedDateTime.from(TemporalAccessor).

Specified by:
zonedDateTime in interface Chronology
Parameters:
temporal - the date-time object to convert, not null
Returns:
the ISO zoned date-time, not null
Throws:
DateTimeException - if unable to create the date-time
See Also:
ChronoZonedDateTime.from(TemporalAccessor)


"
JapaneseChronology,"date(Era era, int yearOfEra, int month, int dayOfMonth)",JapaneseDate,"Obtains a local date in Japanese calendar system from the era, year-of-era, month-of-year and day-of-month fields.","

date
public JapaneseDate date(Era era,
                         int yearOfEra,
                         int month,
                         int dayOfMonth)
Obtains a local date in Japanese calendar system from the
 era, year-of-era, month-of-year and day-of-month fields.
 
 The Japanese month and day-of-month are the same as those in the
 ISO calendar system. They are not reset when the era changes.
 For example:
 
  6th Jan Showa 64 = ISO 1989-01-06
  7th Jan Showa 64 = ISO 1989-01-07
  8th Jan Heisei 1 = ISO 1989-01-08
  9th Jan Heisei 1 = ISO 1989-01-09
 

Specified by:
date in interface Chronology
Parameters:
era - the Japanese era, not null
yearOfEra - the year-of-era
month - the month-of-year
dayOfMonth - the day-of-month
Returns:
the Japanese local date, not null
Throws:
DateTimeException - if unable to create the date
ClassCastException - if the era is not a JapaneseEra


"
JapaneseChronology,"date(int prolepticYear, int month, int dayOfMonth)",JapaneseDate,"Obtains a local date in Japanese calendar system from the proleptic-year, month-of-year and day-of-month fields.","

date
public JapaneseDate date(int prolepticYear,
                         int month,
                         int dayOfMonth)
Obtains a local date in Japanese calendar system from the
 proleptic-year, month-of-year and day-of-month fields.
 
 The Japanese proleptic year, month and day-of-month are the same as those
 in the ISO calendar system. They are not reset when the era changes.

Specified by:
date in interface Chronology
Parameters:
prolepticYear - the proleptic-year
month - the month-of-year
dayOfMonth - the day-of-month
Returns:
the Japanese local date, not null
Throws:
DateTimeException - if unable to create the date


"
JapaneseChronology,date(TemporalAccessor temporal),JapaneseDate,Obtains a local date in this chronology from another temporal object.,"

date
public JapaneseDate date(TemporalAccessor temporal)
Description copied from interface: Chronology
Obtains a local date in this chronology from another temporal object.
 
 This obtains a date in this chronology based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ChronoLocalDate.
 
 The conversion typically uses the EPOCH_DAY
 field, which is standardized across calendar systems.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, aChronology::date.

Specified by:
date in interface Chronology
Parameters:
temporal - the temporal object to convert, not null
Returns:
the local date in this chronology, not null
See Also:
ChronoLocalDate.from(TemporalAccessor)


"
JapaneseChronology,dateEpochDay(long epochDay),JapaneseDate,Obtains a local date in the Japanese calendar system from the epoch-day.,"

dateEpochDay
public JapaneseDate dateEpochDay(long epochDay)
Obtains a local date in the Japanese calendar system from the epoch-day.

Specified by:
dateEpochDay in interface Chronology
Parameters:
epochDay - the epoch day
Returns:
the Japanese local date, not null
Throws:
DateTimeException - if unable to create the date


"
JapaneseChronology,dateNow(),JapaneseDate,Obtains the current local date in this chronology from the system clock in the default time-zone.,"

dateNow
public JapaneseDate dateNow()
Description copied from interface: Chronology
Obtains the current local date in this chronology from the system clock in the default time-zone.
 
 This will query the system clock in the default
 time-zone to obtain the current date.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Specified by:
dateNow in interface Chronology
Returns:
the current local date using the system clock and default time-zone, not null


"
JapaneseChronology,dateNow(Clock clock),JapaneseDate,Obtains the current local date in this chronology from the specified clock.,"

dateNow
public JapaneseDate dateNow(Clock clock)
Description copied from interface: Chronology
Obtains the current local date in this chronology from the specified clock.
 
 This will query the specified clock to obtain the current date - today.
 Using this method allows the use of an alternate clock for testing.
 The alternate clock may be introduced using dependency injection.

Specified by:
dateNow in interface Chronology
Parameters:
clock - the clock to use, not null
Returns:
the current local date, not null


"
JapaneseChronology,dateNow(ZoneId zone),JapaneseDate,Obtains the current local date in this chronology from the system clock in the specified time-zone.,"

dateNow
public JapaneseDate dateNow(ZoneId zone)
Description copied from interface: Chronology
Obtains the current local date in this chronology from the system clock in the specified time-zone.
 
 This will query the system clock to obtain the current date.
 Specifying the time-zone avoids dependence on the default time-zone.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Specified by:
dateNow in interface Chronology
Parameters:
zone - the zone ID to use, not null
Returns:
the current local date using the system clock, not null


"
JapaneseChronology,"dateYearDay(Era era, int yearOfEra, int dayOfYear)",JapaneseDate,"Obtains a local date in Japanese calendar system from the era, year-of-era and day-of-year fields.","

dateYearDay
public JapaneseDate dateYearDay(Era era,
                                int yearOfEra,
                                int dayOfYear)
Obtains a local date in Japanese calendar system from the
 era, year-of-era and day-of-year fields.
 
 The day-of-year in this factory is expressed relative to the start of the year-of-era.
 This definition changes the normal meaning of day-of-year only in those years
 where the year-of-era is reset to one due to a change in the era.
 For example:
 
  6th Jan Showa 64 = day-of-year 6
  7th Jan Showa 64 = day-of-year 7
  8th Jan Heisei 1 = day-of-year 1
  9th Jan Heisei 1 = day-of-year 2
 

Specified by:
dateYearDay in interface Chronology
Parameters:
era - the Japanese era, not null
yearOfEra - the year-of-era
dayOfYear - the day-of-year
Returns:
the Japanese local date, not null
Throws:
DateTimeException - if unable to create the date
ClassCastException - if the era is not a JapaneseEra


"
JapaneseChronology,"dateYearDay(int prolepticYear, int dayOfYear)",JapaneseDate,Obtains a local date in Japanese calendar system from the proleptic-year and day-of-year fields.,"

dateYearDay
public JapaneseDate dateYearDay(int prolepticYear,
                                int dayOfYear)
Obtains a local date in Japanese calendar system from the
 proleptic-year and day-of-year fields.
 
 The day-of-year in this factory is expressed relative to the start of the proleptic year.
 The Japanese proleptic year and day-of-year are the same as those in the ISO calendar system.
 They are not reset when the era changes.

Specified by:
dateYearDay in interface Chronology
Parameters:
prolepticYear - the proleptic-year
dayOfYear - the day-of-year
Returns:
the Japanese local date, not null
Throws:
DateTimeException - if unable to create the date


"
JapaneseChronology,eraOf(int eraValue),JapaneseEra,Returns the calendar system era object from the given numeric value.,"

eraOf
public JapaneseEra eraOf(int eraValue)
Returns the calendar system era object from the given numeric value.

 See the description of each Era for the numeric values of:
 JapaneseEra.HEISEI, JapaneseEra.SHOWA,JapaneseEra.TAISHO,
 JapaneseEra.MEIJI), only Meiji and later eras are supported.

Specified by:
eraOf in interface Chronology
Parameters:
eraValue - the era value
Returns:
the Japanese Era for the given numeric era value
Throws:
DateTimeException - if eraValue is invalid


"
JapaneseChronology,eras(),List<Era>,Gets the list of eras for the chronology.,"

eras
public List<Era> eras()
Description copied from interface: Chronology
Gets the list of eras for the chronology.
 
 Most calendar systems have an era, within which the year has meaning.
 If the calendar system does not support the concept of eras, an empty
 list must be returned.

Specified by:
eras in interface Chronology
Returns:
the list of eras for the chronology, may be immutable, not null


"
JapaneseChronology,getCalendarType(),String,Gets the calendar type of the underlying calendar system - 'japanese'.,"

getCalendarType
public String getCalendarType()
Gets the calendar type of the underlying calendar system - 'japanese'.
 
 The calendar type is an identifier defined by the
 Unicode Locale Data Markup Language (LDML) specification.
 It can be used to lookup the Chronology using Chronology.of(String).
 It can also be used as part of a locale, accessible via
 Locale.getUnicodeLocaleType(String) with the key 'ca'.

Specified by:
getCalendarType in interface Chronology
Returns:
the calendar system type - 'japanese'
See Also:
getId()


"
JapaneseChronology,getId(),String,Gets the ID of the chronology - 'Japanese'.,"

getId
public String getId()
Gets the ID of the chronology - 'Japanese'.
 
 The ID uniquely identifies the Chronology.
 It can be used to lookup the Chronology using Chronology.of(String).

Specified by:
getId in interface Chronology
Returns:
the chronology ID - 'Japanese'
See Also:
getCalendarType()


"
JapaneseChronology,isLeapYear(long prolepticYear),boolean,Checks if the specified year is a leap year.,"

isLeapYear
public boolean isLeapYear(long prolepticYear)
Checks if the specified year is a leap year.
 
 Japanese calendar leap years occur exactly in line with ISO leap years.
 This method does not validate the year passed in, and only has a
 well-defined result for years in the supported range.

Specified by:
isLeapYear in interface Chronology
Parameters:
prolepticYear - the proleptic-year to check, not validated for range
Returns:
true if the year is a leap year


"
JapaneseChronology,localDateTime(TemporalAccessor temporal),ChronoLocalDateTime<JapaneseDate>,Obtains a local date-time in this chronology from another temporal object.,"

localDateTime
public ChronoLocalDateTime<JapaneseDate> localDateTime(TemporalAccessor temporal)
Description copied from interface: Chronology
Obtains a local date-time in this chronology from another temporal object.
 
 This obtains a date-time in this chronology based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ChronoLocalDateTime.
 
 The conversion extracts and combines the ChronoLocalDate and the
 LocalTime from the temporal object.
 Implementations are permitted to perform optimizations such as accessing
 those fields that are equivalent to the relevant objects.
 The result uses this chronology.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, aChronology::localDateTime.

Specified by:
localDateTime in interface Chronology
Parameters:
temporal - the temporal object to convert, not null
Returns:
the local date-time in this chronology, not null
See Also:
ChronoLocalDateTime.from(TemporalAccessor)


"
JapaneseChronology,"prolepticYear(Era era, int yearOfEra)",int,Calculates the proleptic-year given the era and year-of-era.,"

prolepticYear
public int prolepticYear(Era era,
                         int yearOfEra)
Description copied from interface: Chronology
Calculates the proleptic-year given the era and year-of-era.
 
 This combines the era and year-of-era into the single proleptic-year field.
 
 If the chronology makes active use of eras, such as JapaneseChronology
 then the year-of-era will be validated against the era.
 For other chronologies, validation is optional.

Specified by:
prolepticYear in interface Chronology
Parameters:
era - the era of the correct type for the chronology, not null
yearOfEra - the chronology year-of-era
Returns:
the proleptic-year


"
JapaneseChronology,range(ChronoField field),ValueRange,Gets the range of valid values for the specified field.,"

range
public ValueRange range(ChronoField field)
Description copied from interface: Chronology
Gets the range of valid values for the specified field.
 
 All fields can be expressed as a long integer.
 This method returns an object that describes the valid range for that value.
 
 Note that the result only describes the minimum and maximum valid values
 and it is important not to read too much into them. For example, there
 could be values within the range that are invalid for the field.
 
 This method will return a result whether or not the chronology supports the field.

Specified by:
range in interface Chronology
Parameters:
field - the field to get the range for, not null
Returns:
the range of valid values for the field, not null


"
JapaneseChronology,"resolveDate(Map<TemporalField,Long> fieldValues, ResolverStyle resolverStyle)",JapaneseDate,Resolves parsed ChronoField values into a date during parsing.,"

resolveDate
public JapaneseDate resolveDate(Map<TemporalField,Long> fieldValues,
                                ResolverStyle resolverStyle)
Description copied from class: AbstractChronology
Resolves parsed ChronoField values into a date during parsing.
 
 Most TemporalField implementations are resolved using the
 resolve method on the field. By contrast, the ChronoField class
 defines fields that only have meaning relative to the chronology.
 As such, ChronoField date fields are resolved here in the
 context of a specific chronology.
 
ChronoField instances are resolved by this method, which may
 be overridden in subclasses.
 
EPOCH_DAY - If present, this is converted to a date and
  all other date fields are then cross-checked against the date.
 PROLEPTIC_MONTH - If present, then it is split into the
  YEAR and MONTH_OF_YEAR. If the mode is strict or smart
  then the field is validated.
 YEAR_OF_ERA and ERA - If both are present, then they
  are combined to form a YEAR. In lenient mode, the YEAR_OF_ERA
  range is not validated, in smart and strict mode it is. The ERA is
  validated for range in all three modes. If only the YEAR_OF_ERA is
  present, and the mode is smart or lenient, then the last available era
  is assumed. In strict mode, no era is assumed and the YEAR_OF_ERA is
  left untouched. If only the ERA is present, then it is left untouched.
 YEAR, MONTH_OF_YEAR and DAY_OF_MONTH -
  If all three are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is smart or strict, then the month and day are validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the first month in the requested year,
  then adding the difference in months, then the difference in days.
  If the mode is smart, and the day-of-month is greater than the maximum for
  the year-month, then the day-of-month is adjusted to the last day-of-month.
  If the mode is strict, then the three fields must form a valid date.
 YEAR and DAY_OF_YEAR -
  If both are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the difference in days.
  If the mode is smart or strict, then the two fields must form a valid date.
 YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and
  ALIGNED_DAY_OF_WEEK_IN_MONTH -
  If all four are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the first month in the requested year, then adding
  the difference in months, then the difference in weeks, then in days.
  If the mode is smart or strict, then the all four fields are validated to
  their outer ranges. The date is then combined in a manner equivalent to
  creating a date on the first day of the requested year and month, then adding
  the amount in weeks and days to reach their values. If the mode is strict,
  the date is additionally validated to check that the day and week adjustment
  did not change the month.
 YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and
  DAY_OF_WEEK - If all four are present, then they are combined to
  form a date. The approach is the same as described above for
  years, months and weeks in ALIGNED_DAY_OF_WEEK_IN_MONTH.
  The day-of-week is adjusted as the next or same matching day-of-week once
  the years, months and weeks have been handled.
 YEAR, ALIGNED_WEEK_OF_YEAR and ALIGNED_DAY_OF_WEEK_IN_YEAR -
  If all three are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the difference in weeks, then in days.
  If the mode is smart or strict, then the all three fields are validated to
  their outer ranges. The date is then combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the amount in weeks and days to reach their values. If the mode is strict,
  the date is additionally validated to check that the day and week adjustment
  did not change the year.
 YEAR, ALIGNED_WEEK_OF_YEAR and DAY_OF_WEEK -
  If all three are present, then they are combined to form a date.
  The approach is the same as described above for years and weeks in
  ALIGNED_DAY_OF_WEEK_IN_YEAR. The day-of-week is adjusted as the
  next or same matching day-of-week once the years and weeks have been handled.
 

 The default implementation is suitable for most calendar systems.
 If ChronoField.YEAR_OF_ERA is found without an ChronoField.ERA
 then the last era in Chronology.eras() is used.
 The implementation assumes a 7 day week, that the first day-of-month
 has the value 1, that first day-of-year has the value 1, and that the
 first of the month and year always exists.

Specified by:
resolveDate in interface Chronology
Overrides:
resolveDate in class AbstractChronology
Parameters:
fieldValues - the map of fields to values, which can be updated, not null
resolverStyle - the requested type of resolve, not null
Returns:
the resolved date, null if insufficient information to create a date


"
JapaneseChronology,"zonedDateTime(Instant instant, ZoneId zone)",ChronoZonedDateTime<JapaneseDate>,Obtains a ChronoZonedDateTime in this chronology from an Instant.,"

zonedDateTime
public ChronoZonedDateTime<JapaneseDate> zonedDateTime(Instant instant,
                                                       ZoneId zone)
Description copied from interface: Chronology
Obtains a ChronoZonedDateTime in this chronology from an Instant.
 
 This obtains a zoned date-time with the same instant as that specified.

Specified by:
zonedDateTime in interface Chronology
Parameters:
instant - the instant to create the date-time from, not null
zone - the time-zone, not null
Returns:
the zoned date-time, not null


"
JapaneseChronology,zonedDateTime(TemporalAccessor temporal),ChronoZonedDateTime<JapaneseDate>,Obtains a ChronoZonedDateTime in this chronology from another temporal object.,"

zonedDateTime
public ChronoZonedDateTime<JapaneseDate> zonedDateTime(TemporalAccessor temporal)
Description copied from interface: Chronology
Obtains a ChronoZonedDateTime in this chronology from another temporal object.
 
 This obtains a zoned date-time in this chronology based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ChronoZonedDateTime.
 
 The conversion will first obtain a ZoneId from the temporal object,
 falling back to a ZoneOffset if necessary. It will then try to obtain
 an Instant, falling back to a ChronoLocalDateTime if necessary.
 The result will be either the combination of ZoneId or ZoneOffset
 with Instant or ChronoLocalDateTime.
 Implementations are permitted to perform optimizations such as accessing
 those fields that are equivalent to the relevant objects.
 The result uses this chronology.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, aChronology::zonedDateTime.

Specified by:
zonedDateTime in interface Chronology
Parameters:
temporal - the temporal object to convert, not null
Returns:
the zoned date-time in this chronology, not null
See Also:
ChronoZonedDateTime.from(TemporalAccessor)


"
JapaneseDate,atTime(LocalTime localTime),ChronoLocalDateTime<JapaneseDate>,Combines this date with a time to create a ChronoLocalDateTime.,"

atTime
public final ChronoLocalDateTime<JapaneseDate> atTime(LocalTime localTime)
Description copied from interface: ChronoLocalDate
Combines this date with a time to create a ChronoLocalDateTime.
 
 This returns a ChronoLocalDateTime formed from this date at the specified time.
 All possible combinations of date and time are valid.

Specified by:
atTime in interface ChronoLocalDate
Parameters:
localTime - the local time to use, not null
Returns:
the local date-time formed from this date and the specified time, not null


"
JapaneseDate,equals(Object obj),boolean,"Compares this date to another date, including the chronology.","

equals
public boolean equals(Object obj)
Compares this date to another date, including the chronology.
 
 Compares this JapaneseDate with another ensuring that the date is the same.
 
 Only objects of type JapaneseDate are compared, other types return false.
 To compare the dates of two TemporalAccessor instances, including dates
 in two different chronologies, use ChronoField.EPOCH_DAY as a comparator.

Specified by:
equals in interface ChronoLocalDate
Parameters:
obj - the object to check, null returns false
Returns:
true if this is equal to the other date
See Also:
Object.hashCode(), 
HashMap


"
JapaneseDate,from(TemporalAccessor temporal),static JapaneseDate,Obtains a JapaneseDate from a temporal object.,"

from
public static JapaneseDate from(TemporalAccessor temporal)
Obtains a JapaneseDate from a temporal object.
 
 This obtains a date in the Japanese calendar system based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of JapaneseDate.
 
 The conversion typically uses the EPOCH_DAY
 field, which is standardized across calendar systems.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, JapaneseDate::from.

Specified by:
from in interface ChronoLocalDate
Parameters:
temporal - the temporal object to convert, not null
Returns:
the date in Japanese calendar system, not null
Throws:
DateTimeException - if unable to convert to a JapaneseDate
See Also:
Chronology.date(TemporalAccessor)


"
JapaneseDate,getChronology(),JapaneseChronology,"Gets the chronology of this date, which is the Japanese calendar system.","

getChronology
public JapaneseChronology getChronology()
Gets the chronology of this date, which is the Japanese calendar system.
 
 The Chronology represents the calendar system in use.
 The era and other fields in ChronoField are defined by the chronology.

Specified by:
getChronology in interface ChronoLocalDate
Returns:
the Japanese chronology, not null


"
JapaneseDate,getEra(),JapaneseEra,Gets the era applicable at this date.,"

getEra
public JapaneseEra getEra()
Gets the era applicable at this date.
 
 The Japanese calendar system has multiple eras defined by JapaneseEra.

Specified by:
getEra in interface ChronoLocalDate
Returns:
the era applicable at this date, not null


"
JapaneseDate,getLong(TemporalField field),long,Gets the value of the specified field as a long.,"

getLong
public long getLong(TemporalField field)
Description copied from interface: TemporalAccessor
Gets the value of the specified field as a long.
 
 This queries the date-time for the value of the specified field.
 The returned value may be outside the valid range of values for the field.
 If the date-time cannot return the value, because the field is unsupported or for
 some other reason, an exception will be thrown.

Specified by:
getLong in interface TemporalAccessor
Parameters:
field - the field to get, not null
Returns:
the value for the field


"
JapaneseDate,hashCode(),int,A hash code for this date.,"

hashCode
public int hashCode()
A hash code for this date.

Specified by:
hashCode in interface ChronoLocalDate
Returns:
a suitable hash code based only on the Chronology and the date
See Also:
Object.equals(java.lang.Object), 
System.identityHashCode(java.lang.Object)


"
JapaneseDate,isSupported(TemporalField field),boolean,Checks if the specified field is supported.,"

isSupported
public boolean isSupported(TemporalField field)
Checks if the specified field is supported.
 
 This checks if this date can be queried for the specified field.
 If false, then calling the range and
 get methods will throw an exception.
 
 If the field is a ChronoField then the query is implemented here.
 The supported fields are:
 
DAY_OF_WEEK
DAY_OF_MONTH
DAY_OF_YEAR
EPOCH_DAY
MONTH_OF_YEAR
PROLEPTIC_MONTH
YEAR_OF_ERA
YEAR
ERA

 All other ChronoField instances will return false.
 
 If the field is not a ChronoField, then the result of this method
 is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor)
 passing this as the argument.
 Whether the field is supported is determined by the field.

Specified by:
isSupported in interface ChronoLocalDate
Specified by:
isSupported in interface TemporalAccessor
Parameters:
field - the field to check, null returns false
Returns:
true if the field is supported on this date, false if not


"
JapaneseDate,lengthOfMonth(),int,Returns the length of the month represented by this date.,"

lengthOfMonth
public int lengthOfMonth()
Returns the length of the month represented by this date.
 
 This returns the length of the month in days.
 Month lengths match those of the ISO calendar system.

Specified by:
lengthOfMonth in interface ChronoLocalDate
Returns:
the length of the month in days


"
JapaneseDate,lengthOfYear(),int,"Returns the length of the year represented by this date, as defined by the calendar system.","

lengthOfYear
public int lengthOfYear()
Description copied from interface: ChronoLocalDate
Returns the length of the year represented by this date, as defined by the calendar system.
 
 This returns the length of the year in days.
 
 The default implementation uses ChronoLocalDate.isLeapYear() and returns 365 or 366.

Specified by:
lengthOfYear in interface ChronoLocalDate
Returns:
the length of the year in days


"
JapaneseDate,"minus(long amountToAdd, TemporalUnit unit)",JapaneseDate,Returns an object of the same type as this object with the specified period subtracted.,"

minus
public JapaneseDate minus(long amountToAdd,
                          TemporalUnit unit)
Description copied from interface: ChronoLocalDate
Returns an object of the same type as this object with the specified period subtracted.
 
 This method returns a new object based on this one with the specified period subtracted.
 For example, on a LocalDate, this could be used to subtract a number of years, months or days.
 The returned object will have the same observable type as this object.
 
 In some cases, changing a field is not fully defined. For example, if the target object is
 a date representing the 31st March, then subtracting one month would be unclear.
 In cases like this, the field is responsible for resolving the result. Typically it will choose
 the previous valid date, which would be the last valid day of February in this example.

Specified by:
minus in interface ChronoLocalDate
Specified by:
minus in interface Temporal
Parameters:
amountToAdd - the amount of the specified unit to subtract, may be negative
unit - the unit of the amount to subtract, not null
Returns:
an object of the same type with the specified period subtracted, not null


"
JapaneseDate,minus(TemporalAmount amount),JapaneseDate,Returns an object of the same type as this object with an amount subtracted.,"

minus
public JapaneseDate minus(TemporalAmount amount)
Returns an object of the same type as this object with an amount subtracted.
 
 This adjusts this temporal, subtracting according to the rules of the specified amount.
 The amount is typically a Period but may be any other type implementing
 the TemporalAmount interface, such as Duration.
 
 Some example code indicating how and why this method is used:
 
  date = date.minus(period);               // subtract a Period instance
  date = date.minus(duration);             // subtract a Duration instance
  date = date.minus(workingDays(6));       // example user-written workingDays method
 

 Note that calling plus followed by minus is not guaranteed to
 return the same date-time.

Specified by:
minus in interface ChronoLocalDate
Specified by:
minus in interface Temporal
Parameters:
amount - the amount to subtract, not null
Returns:
an object of the same type with the specified adjustment made, not null
Throws:
DateTimeException - if the subtraction cannot be made
ArithmeticException - if numeric overflow occurs


"
JapaneseDate,now(),static JapaneseDate,Obtains the current JapaneseDate from the system clock in the default time-zone.,"

now
public static JapaneseDate now()
Obtains the current JapaneseDate from the system clock in the default time-zone.
 
 This will query the system clock in the default
 time-zone to obtain the current date.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Returns:
the current date using the system clock and default time-zone, not null


"
JapaneseDate,now(Clock clock),static JapaneseDate,Obtains the current JapaneseDate from the specified clock.,"

now
public static JapaneseDate now(Clock clock)
Obtains the current JapaneseDate from the specified clock.
 
 This will query the specified clock to obtain the current date - today.
 Using this method allows the use of an alternate clock for testing.
 The alternate clock may be introduced using dependency injection.

Parameters:
clock - the clock to use, not null
Returns:
the current date, not null
Throws:
DateTimeException - if the current date cannot be obtained


"
JapaneseDate,now(ZoneId zone),static JapaneseDate,Obtains the current JapaneseDate from the system clock in the specified time-zone.,"

now
public static JapaneseDate now(ZoneId zone)
Obtains the current JapaneseDate from the system clock in the specified time-zone.
 
 This will query the system clock to obtain the current date.
 Specifying the time-zone avoids dependence on the default time-zone.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Parameters:
zone - the zone ID to use, not null
Returns:
the current date using the system clock, not null


"
JapaneseDate,"of(int prolepticYear, int month, int dayOfMonth)",static JapaneseDate,"Obtains a JapaneseDate representing a date in the Japanese calendar system from the proleptic-year, month-of-year and day-of-month fields.","

of
public static JapaneseDate of(int prolepticYear,
                              int month,
                              int dayOfMonth)
Obtains a JapaneseDate representing a date in the Japanese calendar
 system from the proleptic-year, month-of-year and day-of-month fields.
 
 This returns a JapaneseDate with the specified fields.
 The day must be valid for the year and month, otherwise an exception will be thrown.
 
 The Japanese proleptic year, month and day-of-month are the same as those
 in the ISO calendar system. They are not reset when the era changes.

Parameters:
prolepticYear - the Japanese proleptic-year
month - the Japanese month-of-year, from 1 to 12
dayOfMonth - the Japanese day-of-month, from 1 to 31
Returns:
the date in Japanese calendar system, not null
Throws:
DateTimeException - if the value of any field is out of range,
  or if the day-of-month is invalid for the month-year


"
JapaneseDate,"of(JapaneseEra era, int yearOfEra, int month, int dayOfMonth)",static JapaneseDate,"Obtains a JapaneseDate representing a date in the Japanese calendar system from the era, year-of-era, month-of-year and day-of-month fields.","

of
public static JapaneseDate of(JapaneseEra era,
                              int yearOfEra,
                              int month,
                              int dayOfMonth)
Obtains a JapaneseDate representing a date in the Japanese calendar
 system from the era, year-of-era, month-of-year and day-of-month fields.
 
 This returns a JapaneseDate with the specified fields.
 The day must be valid for the year and month, otherwise an exception will be thrown.
 
 The Japanese month and day-of-month are the same as those in the
 ISO calendar system. They are not reset when the era changes.
 For example:
 
  6th Jan Showa 64 = ISO 1989-01-06
  7th Jan Showa 64 = ISO 1989-01-07
  8th Jan Heisei 1 = ISO 1989-01-08
  9th Jan Heisei 1 = ISO 1989-01-09
 

Parameters:
era - the Japanese era, not null
yearOfEra - the Japanese year-of-era
month - the Japanese month-of-year, from 1 to 12
dayOfMonth - the Japanese day-of-month, from 1 to 31
Returns:
the date in Japanese calendar system, not null
Throws:
DateTimeException - if the value of any field is out of range,
  or if the day-of-month is invalid for the month-year,
  or if the date is not a Japanese era


"
JapaneseDate,"plus(long amountToAdd, TemporalUnit unit)",JapaneseDate,Returns an object of the same type as this object with the specified period added.,"

plus
public JapaneseDate plus(long amountToAdd,
                         TemporalUnit unit)
Description copied from interface: ChronoLocalDate
Returns an object of the same type as this object with the specified period added.
 
 This method returns a new object based on this one with the specified period added.
 For example, on a LocalDate, this could be used to add a number of years, months or days.
 The returned object will have the same observable type as this object.
 
 In some cases, changing a field is not fully defined. For example, if the target object is
 a date representing the 31st January, then adding one month would be unclear.
 In cases like this, the field is responsible for resolving the result. Typically it will choose
 the previous valid date, which would be the last valid day of February in this example.

Specified by:
plus in interface ChronoLocalDate
Specified by:
plus in interface Temporal
Parameters:
amountToAdd - the amount of the specified unit to add, may be negative
unit - the unit of the amount to add, not null
Returns:
an object of the same type with the specified period added, not null


"
JapaneseDate,plus(TemporalAmount amount),JapaneseDate,Returns an object of the same type as this object with an amount added.,"

plus
public JapaneseDate plus(TemporalAmount amount)
Returns an object of the same type as this object with an amount added.
 
 This adjusts this temporal, adding according to the rules of the specified amount.
 The amount is typically a Period but may be any other type implementing
 the TemporalAmount interface, such as Duration.
 
 Some example code indicating how and why this method is used:
 
  date = date.plus(period);                // add a Period instance
  date = date.plus(duration);              // add a Duration instance
  date = date.plus(workingDays(6));        // example user-written workingDays method
 

 Note that calling plus followed by minus is not guaranteed to
 return the same date-time.

Specified by:
plus in interface ChronoLocalDate
Specified by:
plus in interface Temporal
Parameters:
amount - the amount to add, not null
Returns:
an object of the same type with the specified adjustment made, not null
Throws:
DateTimeException - if the addition cannot be made
ArithmeticException - if numeric overflow occurs


"
JapaneseDate,range(TemporalField field),ValueRange,Gets the range of valid values for the specified field.,"

range
public ValueRange range(TemporalField field)
Description copied from interface: TemporalAccessor
Gets the range of valid values for the specified field.
 
 All fields can be expressed as a long integer.
 This method returns an object that describes the valid range for that value.
 The value of this temporal object is used to enhance the accuracy of the returned range.
 If the date-time cannot return the range, because the field is unsupported or for
 some other reason, an exception will be thrown.
 
 Note that the result only describes the minimum and maximum valid values
 and it is important not to read too much into them. For example, there
 could be values within the range that are invalid for the field.

Specified by:
range in interface TemporalAccessor
Parameters:
field - the field to query the range for, not null
Returns:
the range of valid values for the field, not null


"
JapaneseDate,toEpochDay(),long,Converts this date to the Epoch Day.,"

toEpochDay
public long toEpochDay()
Description copied from interface: ChronoLocalDate
Converts this date to the Epoch Day.
 
 The Epoch Day count is a simple
 incrementing count of days where day 0 is 1970-01-01 (ISO).
 This definition is the same for all chronologies, enabling conversion.
 
 This default implementation queries the EPOCH_DAY field.

Specified by:
toEpochDay in interface ChronoLocalDate
Returns:
the Epoch Day equivalent to this date


"
JapaneseDate,toString(),String,Returns a string representation of the object.,"

toString
public String toString()
Description copied from class: Object
Returns a string representation of the object. In general, the
 toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method.
 
 The toString method for class Object
 returns a string consisting of the name of the class of which the
 object is an instance, the at-sign character `@', and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words, this method returns a string equal to the
 value of:
 

 getClass().getName() + '@' + Integer.toHexString(hashCode())
 

Specified by:
toString in interface ChronoLocalDate
Overrides:
toString in class Object
Returns:
a string representation of the object.


"
JapaneseDate,until(ChronoLocalDate endDate),ChronoPeriod,Calculates the period between this date and another date as a ChronoPeriod.,"

until
public ChronoPeriod until(ChronoLocalDate endDate)
Description copied from interface: ChronoLocalDate
Calculates the period between this date and another date as a ChronoPeriod.
 
 This calculates the period between two dates. All supplied chronologies
 calculate the period using years, months and days, however the
 ChronoPeriod API allows the period to be represented using other units.
 
 The start and end points are this and the specified date.
 The result will be negative if the end is before the start.
 The negative sign will be the same in each of year, month and day.
 
 The calculation is performed using the chronology of this date.
 If necessary, the input date will be converted to match.
 
 This instance is immutable and unaffected by this method call.

Specified by:
until in interface ChronoLocalDate
Parameters:
endDate - the end date, exclusive, which may be in any chronology, not null
Returns:
the period between this date and the end date, not null


"
JapaneseDate,"until(Temporal endExclusive, TemporalUnit unit)",long,Calculates the amount of time until another date in terms of the specified unit.,"

until
public long until(Temporal endExclusive,
                  TemporalUnit unit)
Description copied from interface: ChronoLocalDate
Calculates the amount of time until another date in terms of the specified unit.
 
 This calculates the amount of time between two ChronoLocalDate
 objects in terms of a single TemporalUnit.
 The start and end points are this and the specified date.
 The result will be negative if the end is before the start.
 The Temporal passed to this method is converted to a
 ChronoLocalDate using Chronology.date(TemporalAccessor).
 The calculation returns a whole number, representing the number of
 complete units between the two dates.
 For example, the amount in days between two dates can be calculated
 using startDate.until(endDate, DAYS).
 
 There are two equivalent ways of using this method.
 The first is to invoke this method.
 The second is to use TemporalUnit.between(Temporal, Temporal):
 
   // these two lines are equivalent
   amount = start.until(end, MONTHS);
   amount = MONTHS.between(start, end);
 
 The choice should be made based on which makes the code more readable.
 
 The calculation is implemented in this method for ChronoUnit.
 The units DAYS, WEEKS, MONTHS, YEARS,
 DECADES, CENTURIES, MILLENNIA and ERAS
 should be supported by all implementations.
 Other ChronoUnit values will throw an exception.
 
 If the unit is not a ChronoUnit, then the result of this method
 is obtained by invoking TemporalUnit.between(Temporal, Temporal)
 passing this as the first argument and the converted input temporal as
 the second argument.
 
 This instance is immutable and unaffected by this method call.

Specified by:
until in interface ChronoLocalDate
Specified by:
until in interface Temporal
Parameters:
endExclusive - the end date, exclusive, which is converted to a
  ChronoLocalDate in the same chronology, not null
unit - the unit to measure the amount in, not null
Returns:
the amount of time between this date and the end date


"
JapaneseDate,with(TemporalAdjuster adjuster),JapaneseDate,Returns an adjusted object of the same type as this object with the adjustment made.,"

with
public JapaneseDate with(TemporalAdjuster adjuster)
Returns an adjusted object of the same type as this object with the adjustment made.
 
 This adjusts this date-time according to the rules of the specified adjuster.
 A simple adjuster might simply set the one of the fields, such as the year field.
 A more complex adjuster might set the date to the last day of the month.
 A selection of common adjustments is provided in
 TemporalAdjusters.
 These include finding the ""last day of the month"" and ""next Wednesday"".
 The adjuster is responsible for handling special cases, such as the varying
 lengths of month and leap years.
 
 Some example code indicating how and why this method is used:
 
  date = date.with(Month.JULY);        // most key classes implement TemporalAdjuster
  date = date.with(lastDayOfMonth());  // static import from Adjusters
  date = date.with(next(WEDNESDAY));   // static import from Adjusters and DayOfWeek
 

Specified by:
with in interface ChronoLocalDate
Specified by:
with in interface Temporal
Parameters:
adjuster - the adjuster to use, not null
Returns:
an object of the same type with the specified adjustment made, not null
Throws:
DateTimeException - if unable to make the adjustment
ArithmeticException - if numeric overflow occurs


"
JapaneseDate,"with(TemporalField field, long newValue)",JapaneseDate,Returns an object of the same type as this object with the specified field altered.,"

with
public JapaneseDate with(TemporalField field,
                         long newValue)
Description copied from interface: ChronoLocalDate
Returns an object of the same type as this object with the specified field altered.
 
 This returns a new object based on this one with the value for the specified field changed.
 For example, on a LocalDate, this could be used to set the year, month or day-of-month.
 The returned object will have the same observable type as this object.
 
 In some cases, changing a field is not fully defined. For example, if the target object is
 a date representing the 31st January, then changing the month to February would be unclear.
 In cases like this, the field is responsible for resolving the result. Typically it will choose
 the previous valid date, which would be the last valid day of February in this example.

Specified by:
with in interface ChronoLocalDate
Specified by:
with in interface Temporal
Parameters:
field - the field to set in the result, not null
newValue - the new value of the field in the result
Returns:
an object of the same type with the specified field set, not null


"
JapaneseEra,"getDisplayName(TextStyle style, Locale locale)",String,Gets the textual representation of this era.,"

getDisplayName
public String getDisplayName(TextStyle style,
                             Locale locale)
Gets the textual representation of this era.
 
 This returns the textual name used to identify the era,
 suitable for presentation to the user.
 The parameters control the style of the returned text and the locale.
 
 If no textual mapping is found then the numeric value is returned.

Specified by:
getDisplayName in interface Era
Parameters:
style - the style of the text required, not null
locale - the locale to use, not null
Returns:
the text value of the era, not null


"
JapaneseEra,getValue(),int,Gets the numeric era int value.,"

getValue
public int getValue()
Gets the numeric era int value.
 
 The SHOWA era that contains 1970-01-01 (ISO calendar system) has the value 1.
 Later eras are numbered from 2 (HEISEI).
 Earlier eras are numbered 0 (TAISHO), -1 (MEIJI)).

Specified by:
getValue in interface Era
Returns:
the era value


"
JapaneseEra,of(int japaneseEra),static JapaneseEra,Obtains an instance of JapaneseEra from an int value.,"

of
public static JapaneseEra of(int japaneseEra)
Obtains an instance of JapaneseEra from an int value.
 
The value 1 is associated with the 'Showa' era, because
 it contains 1970-01-01 (ISO calendar system).
The values -1 and 0 are associated with two earlier
 eras, Meiji and Taisho, respectively.
A value greater than 1 is associated with a later era,
 beginning with Heisei (2).


 Every instance of JapaneseEra that is returned from the values()
 method has an int value (available via Era.getValue() which is
 accepted by this method.

Parameters:
japaneseEra - the era to represent
Returns:
the JapaneseEra singleton, not null
Throws:
DateTimeException - if the value is invalid


"
JapaneseEra,range(TemporalField field),ValueRange,Gets the range of valid values for the specified field.,"

range
public ValueRange range(TemporalField field)
Gets the range of valid values for the specified field.
 
 The range object expresses the minimum and maximum valid values for a field.
 This era is used to enhance the accuracy of the returned range.
 If it is not possible to return the range, because the field is not supported
 or for some other reason, an exception is thrown.
 
 If the field is a ChronoField then the query is implemented here.
 The ERA field returns the range.
 All other ChronoField instances will throw an UnsupportedTemporalTypeException.
 
 If the field is not a ChronoField, then the result of this method
 is obtained by invoking TemporalField.rangeRefinedBy(TemporalAccessor)
 passing this as the argument.
 Whether the range can be obtained is determined by the field.
 
 The range of valid Japanese eras can change over time due to the nature
 of the Japanese calendar system.

Specified by:
range in interface Era
Specified by:
range in interface TemporalAccessor
Parameters:
field - the field to query the range for, not null
Returns:
the range of valid values for the field, not null
Throws:
DateTimeException - if the range for the field cannot be obtained
UnsupportedTemporalTypeException - if the unit is not supported


"
JapaneseEra,toString(),String,Returns a string representation of the object.,"

toString
public String toString()
Description copied from class: Object
Returns a string representation of the object. In general, the
 toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method.
 
 The toString method for class Object
 returns a string consisting of the name of the class of which the
 object is an instance, the at-sign character `@', and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words, this method returns a string equal to the
 value of:
 

 getClass().getName() + '@' + Integer.toHexString(hashCode())
 

Overrides:
toString in class Object
Returns:
a string representation of the object.


"
JapaneseEra,valueOf(String japaneseEra),static JapaneseEra,Returns the JapaneseEra with the name.,"

valueOf
public static JapaneseEra valueOf(String japaneseEra)
Returns the JapaneseEra with the name.
 
 The string must match exactly the name of the era.
 (Extraneous whitespace characters are not permitted.)

Parameters:
japaneseEra - the japaneseEra name; non-null
Returns:
the JapaneseEra singleton, never null
Throws:
IllegalArgumentException - if there is not JapaneseEra with the specified name


"
JapaneseEra,values(),static JapaneseEra[],Returns an array of JapaneseEras.,"

values
public static JapaneseEra[] values()
Returns an array of JapaneseEras.
 
 This method may be used to iterate over the JapaneseEras as follows:
 
 for (JapaneseEra c : JapaneseEra.values())
     System.out.println(c);
 

Returns:
an array of JapaneseEras


"
MinguoChronology,"date(Era era, int yearOfEra, int month, int dayOfMonth)",MinguoDate,"Obtains a local date in Minguo calendar system from the era, year-of-era, month-of-year and day-of-month fields.","

date
public MinguoDate date(Era era,
                       int yearOfEra,
                       int month,
                       int dayOfMonth)
Obtains a local date in Minguo calendar system from the
 era, year-of-era, month-of-year and day-of-month fields.

Specified by:
date in interface Chronology
Parameters:
era - the Minguo era, not null
yearOfEra - the year-of-era
month - the month-of-year
dayOfMonth - the day-of-month
Returns:
the Minguo local date, not null
Throws:
DateTimeException - if unable to create the date
ClassCastException - if the era is not a MinguoEra


"
MinguoChronology,"date(int prolepticYear, int month, int dayOfMonth)",MinguoDate,"Obtains a local date in Minguo calendar system from the proleptic-year, month-of-year and day-of-month fields.","

date
public MinguoDate date(int prolepticYear,
                       int month,
                       int dayOfMonth)
Obtains a local date in Minguo calendar system from the
 proleptic-year, month-of-year and day-of-month fields.

Specified by:
date in interface Chronology
Parameters:
prolepticYear - the proleptic-year
month - the month-of-year
dayOfMonth - the day-of-month
Returns:
the Minguo local date, not null
Throws:
DateTimeException - if unable to create the date


"
MinguoChronology,date(TemporalAccessor temporal),MinguoDate,Obtains a local date in this chronology from another temporal object.,"

date
public MinguoDate date(TemporalAccessor temporal)
Description copied from interface: Chronology
Obtains a local date in this chronology from another temporal object.
 
 This obtains a date in this chronology based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ChronoLocalDate.
 
 The conversion typically uses the EPOCH_DAY
 field, which is standardized across calendar systems.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, aChronology::date.

Specified by:
date in interface Chronology
Parameters:
temporal - the temporal object to convert, not null
Returns:
the local date in this chronology, not null
See Also:
ChronoLocalDate.from(TemporalAccessor)


"
MinguoChronology,dateEpochDay(long epochDay),MinguoDate,Obtains a local date in the Minguo calendar system from the epoch-day.,"

dateEpochDay
public MinguoDate dateEpochDay(long epochDay)
Obtains a local date in the Minguo calendar system from the epoch-day.

Specified by:
dateEpochDay in interface Chronology
Parameters:
epochDay - the epoch day
Returns:
the Minguo local date, not null
Throws:
DateTimeException - if unable to create the date


"
MinguoChronology,dateNow(),MinguoDate,Obtains the current local date in this chronology from the system clock in the default time-zone.,"

dateNow
public MinguoDate dateNow()
Description copied from interface: Chronology
Obtains the current local date in this chronology from the system clock in the default time-zone.
 
 This will query the system clock in the default
 time-zone to obtain the current date.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Specified by:
dateNow in interface Chronology
Returns:
the current local date using the system clock and default time-zone, not null


"
MinguoChronology,dateNow(Clock clock),MinguoDate,Obtains the current local date in this chronology from the specified clock.,"

dateNow
public MinguoDate dateNow(Clock clock)
Description copied from interface: Chronology
Obtains the current local date in this chronology from the specified clock.
 
 This will query the specified clock to obtain the current date - today.
 Using this method allows the use of an alternate clock for testing.
 The alternate clock may be introduced using dependency injection.

Specified by:
dateNow in interface Chronology
Parameters:
clock - the clock to use, not null
Returns:
the current local date, not null


"
MinguoChronology,dateNow(ZoneId zone),MinguoDate,Obtains the current local date in this chronology from the system clock in the specified time-zone.,"

dateNow
public MinguoDate dateNow(ZoneId zone)
Description copied from interface: Chronology
Obtains the current local date in this chronology from the system clock in the specified time-zone.
 
 This will query the system clock to obtain the current date.
 Specifying the time-zone avoids dependence on the default time-zone.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Specified by:
dateNow in interface Chronology
Parameters:
zone - the zone ID to use, not null
Returns:
the current local date using the system clock, not null


"
MinguoChronology,"dateYearDay(Era era, int yearOfEra, int dayOfYear)",MinguoDate,"Obtains a local date in Minguo calendar system from the era, year-of-era and day-of-year fields.","

dateYearDay
public MinguoDate dateYearDay(Era era,
                              int yearOfEra,
                              int dayOfYear)
Obtains a local date in Minguo calendar system from the
 era, year-of-era and day-of-year fields.

Specified by:
dateYearDay in interface Chronology
Parameters:
era - the Minguo era, not null
yearOfEra - the year-of-era
dayOfYear - the day-of-year
Returns:
the Minguo local date, not null
Throws:
DateTimeException - if unable to create the date
ClassCastException - if the era is not a MinguoEra


"
MinguoChronology,"dateYearDay(int prolepticYear, int dayOfYear)",MinguoDate,Obtains a local date in Minguo calendar system from the proleptic-year and day-of-year fields.,"

dateYearDay
public MinguoDate dateYearDay(int prolepticYear,
                              int dayOfYear)
Obtains a local date in Minguo calendar system from the
 proleptic-year and day-of-year fields.

Specified by:
dateYearDay in interface Chronology
Parameters:
prolepticYear - the proleptic-year
dayOfYear - the day-of-year
Returns:
the Minguo local date, not null
Throws:
DateTimeException - if unable to create the date


"
MinguoChronology,eraOf(int eraValue),MinguoEra,Creates the chronology era object from the numeric value.,"

eraOf
public MinguoEra eraOf(int eraValue)
Description copied from interface: Chronology
Creates the chronology era object from the numeric value.
 
 The era is, conceptually, the largest division of the time-line.
 Most calendar systems have a single epoch dividing the time-line into two eras.
 However, some have multiple eras, such as one for the reign of each leader.
 The exact meaning is determined by the chronology according to the following constraints.
 
 The era in use at 1970-01-01 must have the value 1.
 Later eras must have sequentially higher values.
 Earlier eras must have sequentially lower values.
 Each chronology must refer to an enum or similar singleton to provide the era values.
 
 This method returns the singleton era of the correct type for the specified era value.

Specified by:
eraOf in interface Chronology
Parameters:
eraValue - the era value
Returns:
the calendar system era, not null


"
MinguoChronology,eras(),List<Era>,Gets the list of eras for the chronology.,"

eras
public List<Era> eras()
Description copied from interface: Chronology
Gets the list of eras for the chronology.
 
 Most calendar systems have an era, within which the year has meaning.
 If the calendar system does not support the concept of eras, an empty
 list must be returned.

Specified by:
eras in interface Chronology
Returns:
the list of eras for the chronology, may be immutable, not null


"
MinguoChronology,getCalendarType(),String,Gets the calendar type of the underlying calendar system - 'roc'.,"

getCalendarType
public String getCalendarType()
Gets the calendar type of the underlying calendar system - 'roc'.
 
 The calendar type is an identifier defined by the
 Unicode Locale Data Markup Language (LDML) specification.
 It can be used to lookup the Chronology using Chronology.of(String).
 It can also be used as part of a locale, accessible via
 Locale.getUnicodeLocaleType(String) with the key 'ca'.

Specified by:
getCalendarType in interface Chronology
Returns:
the calendar system type - 'roc'
See Also:
getId()


"
MinguoChronology,getId(),String,Gets the ID of the chronology - 'Minguo'.,"

getId
public String getId()
Gets the ID of the chronology - 'Minguo'.
 
 The ID uniquely identifies the Chronology.
 It can be used to lookup the Chronology using Chronology.of(String).

Specified by:
getId in interface Chronology
Returns:
the chronology ID - 'Minguo'
See Also:
getCalendarType()


"
MinguoChronology,isLeapYear(long prolepticYear),boolean,Checks if the specified year is a leap year.,"

isLeapYear
public boolean isLeapYear(long prolepticYear)
Checks if the specified year is a leap year.
 
 Minguo leap years occur exactly in line with ISO leap years.
 This method does not validate the year passed in, and only has a
 well-defined result for years in the supported range.

Specified by:
isLeapYear in interface Chronology
Parameters:
prolepticYear - the proleptic-year to check, not validated for range
Returns:
true if the year is a leap year


"
MinguoChronology,localDateTime(TemporalAccessor temporal),ChronoLocalDateTime<MinguoDate>,Obtains a local date-time in this chronology from another temporal object.,"

localDateTime
public ChronoLocalDateTime<MinguoDate> localDateTime(TemporalAccessor temporal)
Description copied from interface: Chronology
Obtains a local date-time in this chronology from another temporal object.
 
 This obtains a date-time in this chronology based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ChronoLocalDateTime.
 
 The conversion extracts and combines the ChronoLocalDate and the
 LocalTime from the temporal object.
 Implementations are permitted to perform optimizations such as accessing
 those fields that are equivalent to the relevant objects.
 The result uses this chronology.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, aChronology::localDateTime.

Specified by:
localDateTime in interface Chronology
Parameters:
temporal - the temporal object to convert, not null
Returns:
the local date-time in this chronology, not null
See Also:
ChronoLocalDateTime.from(TemporalAccessor)


"
MinguoChronology,"prolepticYear(Era era, int yearOfEra)",int,Calculates the proleptic-year given the era and year-of-era.,"

prolepticYear
public int prolepticYear(Era era,
                         int yearOfEra)
Description copied from interface: Chronology
Calculates the proleptic-year given the era and year-of-era.
 
 This combines the era and year-of-era into the single proleptic-year field.
 
 If the chronology makes active use of eras, such as JapaneseChronology
 then the year-of-era will be validated against the era.
 For other chronologies, validation is optional.

Specified by:
prolepticYear in interface Chronology
Parameters:
era - the era of the correct type for the chronology, not null
yearOfEra - the chronology year-of-era
Returns:
the proleptic-year


"
MinguoChronology,range(ChronoField field),ValueRange,Gets the range of valid values for the specified field.,"

range
public ValueRange range(ChronoField field)
Description copied from interface: Chronology
Gets the range of valid values for the specified field.
 
 All fields can be expressed as a long integer.
 This method returns an object that describes the valid range for that value.
 
 Note that the result only describes the minimum and maximum valid values
 and it is important not to read too much into them. For example, there
 could be values within the range that are invalid for the field.
 
 This method will return a result whether or not the chronology supports the field.

Specified by:
range in interface Chronology
Parameters:
field - the field to get the range for, not null
Returns:
the range of valid values for the field, not null


"
MinguoChronology,"resolveDate(Map<TemporalField,Long> fieldValues, ResolverStyle resolverStyle)",MinguoDate,Resolves parsed ChronoField values into a date during parsing.,"

resolveDate
public MinguoDate resolveDate(Map<TemporalField,Long> fieldValues,
                              ResolverStyle resolverStyle)
Description copied from class: AbstractChronology
Resolves parsed ChronoField values into a date during parsing.
 
 Most TemporalField implementations are resolved using the
 resolve method on the field. By contrast, the ChronoField class
 defines fields that only have meaning relative to the chronology.
 As such, ChronoField date fields are resolved here in the
 context of a specific chronology.
 
ChronoField instances are resolved by this method, which may
 be overridden in subclasses.
 
EPOCH_DAY - If present, this is converted to a date and
  all other date fields are then cross-checked against the date.
 PROLEPTIC_MONTH - If present, then it is split into the
  YEAR and MONTH_OF_YEAR. If the mode is strict or smart
  then the field is validated.
 YEAR_OF_ERA and ERA - If both are present, then they
  are combined to form a YEAR. In lenient mode, the YEAR_OF_ERA
  range is not validated, in smart and strict mode it is. The ERA is
  validated for range in all three modes. If only the YEAR_OF_ERA is
  present, and the mode is smart or lenient, then the last available era
  is assumed. In strict mode, no era is assumed and the YEAR_OF_ERA is
  left untouched. If only the ERA is present, then it is left untouched.
 YEAR, MONTH_OF_YEAR and DAY_OF_MONTH -
  If all three are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is smart or strict, then the month and day are validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the first month in the requested year,
  then adding the difference in months, then the difference in days.
  If the mode is smart, and the day-of-month is greater than the maximum for
  the year-month, then the day-of-month is adjusted to the last day-of-month.
  If the mode is strict, then the three fields must form a valid date.
 YEAR and DAY_OF_YEAR -
  If both are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the difference in days.
  If the mode is smart or strict, then the two fields must form a valid date.
 YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and
  ALIGNED_DAY_OF_WEEK_IN_MONTH -
  If all four are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the first month in the requested year, then adding
  the difference in months, then the difference in weeks, then in days.
  If the mode is smart or strict, then the all four fields are validated to
  their outer ranges. The date is then combined in a manner equivalent to
  creating a date on the first day of the requested year and month, then adding
  the amount in weeks and days to reach their values. If the mode is strict,
  the date is additionally validated to check that the day and week adjustment
  did not change the month.
 YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and
  DAY_OF_WEEK - If all four are present, then they are combined to
  form a date. The approach is the same as described above for
  years, months and weeks in ALIGNED_DAY_OF_WEEK_IN_MONTH.
  The day-of-week is adjusted as the next or same matching day-of-week once
  the years, months and weeks have been handled.
 YEAR, ALIGNED_WEEK_OF_YEAR and ALIGNED_DAY_OF_WEEK_IN_YEAR -
  If all three are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the difference in weeks, then in days.
  If the mode is smart or strict, then the all three fields are validated to
  their outer ranges. The date is then combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the amount in weeks and days to reach their values. If the mode is strict,
  the date is additionally validated to check that the day and week adjustment
  did not change the year.
 YEAR, ALIGNED_WEEK_OF_YEAR and DAY_OF_WEEK -
  If all three are present, then they are combined to form a date.
  The approach is the same as described above for years and weeks in
  ALIGNED_DAY_OF_WEEK_IN_YEAR. The day-of-week is adjusted as the
  next or same matching day-of-week once the years and weeks have been handled.
 

 The default implementation is suitable for most calendar systems.
 If ChronoField.YEAR_OF_ERA is found without an ChronoField.ERA
 then the last era in Chronology.eras() is used.
 The implementation assumes a 7 day week, that the first day-of-month
 has the value 1, that first day-of-year has the value 1, and that the
 first of the month and year always exists.

Specified by:
resolveDate in interface Chronology
Overrides:
resolveDate in class AbstractChronology
Parameters:
fieldValues - the map of fields to values, which can be updated, not null
resolverStyle - the requested type of resolve, not null
Returns:
the resolved date, null if insufficient information to create a date


"
MinguoChronology,"zonedDateTime(Instant instant, ZoneId zone)",ChronoZonedDateTime<MinguoDate>,Obtains a ChronoZonedDateTime in this chronology from an Instant.,"

zonedDateTime
public ChronoZonedDateTime<MinguoDate> zonedDateTime(Instant instant,
                                                     ZoneId zone)
Description copied from interface: Chronology
Obtains a ChronoZonedDateTime in this chronology from an Instant.
 
 This obtains a zoned date-time with the same instant as that specified.

Specified by:
zonedDateTime in interface Chronology
Parameters:
instant - the instant to create the date-time from, not null
zone - the time-zone, not null
Returns:
the zoned date-time, not null


"
MinguoChronology,zonedDateTime(TemporalAccessor temporal),ChronoZonedDateTime<MinguoDate>,Obtains a ChronoZonedDateTime in this chronology from another temporal object.,"

zonedDateTime
public ChronoZonedDateTime<MinguoDate> zonedDateTime(TemporalAccessor temporal)
Description copied from interface: Chronology
Obtains a ChronoZonedDateTime in this chronology from another temporal object.
 
 This obtains a zoned date-time in this chronology based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ChronoZonedDateTime.
 
 The conversion will first obtain a ZoneId from the temporal object,
 falling back to a ZoneOffset if necessary. It will then try to obtain
 an Instant, falling back to a ChronoLocalDateTime if necessary.
 The result will be either the combination of ZoneId or ZoneOffset
 with Instant or ChronoLocalDateTime.
 Implementations are permitted to perform optimizations such as accessing
 those fields that are equivalent to the relevant objects.
 The result uses this chronology.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, aChronology::zonedDateTime.

Specified by:
zonedDateTime in interface Chronology
Parameters:
temporal - the temporal object to convert, not null
Returns:
the zoned date-time in this chronology, not null
See Also:
ChronoZonedDateTime.from(TemporalAccessor)


"
MinguoDate,atTime(LocalTime localTime),ChronoLocalDateTime<MinguoDate>,Combines this date with a time to create a ChronoLocalDateTime.,"

atTime
public final ChronoLocalDateTime<MinguoDate> atTime(LocalTime localTime)
Description copied from interface: ChronoLocalDate
Combines this date with a time to create a ChronoLocalDateTime.
 
 This returns a ChronoLocalDateTime formed from this date at the specified time.
 All possible combinations of date and time are valid.

Specified by:
atTime in interface ChronoLocalDate
Parameters:
localTime - the local time to use, not null
Returns:
the local date-time formed from this date and the specified time, not null


"
MinguoDate,equals(Object obj),boolean,"Compares this date to another date, including the chronology.","

equals
public boolean equals(Object obj)
Compares this date to another date, including the chronology.
 
 Compares this MinguoDate with another ensuring that the date is the same.
 
 Only objects of type MinguoDate are compared, other types return false.
 To compare the dates of two TemporalAccessor instances, including dates
 in two different chronologies, use ChronoField.EPOCH_DAY as a comparator.

Specified by:
equals in interface ChronoLocalDate
Parameters:
obj - the object to check, null returns false
Returns:
true if this is equal to the other date
See Also:
Object.hashCode(), 
HashMap


"
MinguoDate,from(TemporalAccessor temporal),static MinguoDate,Obtains a MinguoDate from a temporal object.,"

from
public static MinguoDate from(TemporalAccessor temporal)
Obtains a MinguoDate from a temporal object.
 
 This obtains a date in the Minguo calendar system based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of MinguoDate.
 
 The conversion typically uses the EPOCH_DAY
 field, which is standardized across calendar systems.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, MinguoDate::from.

Specified by:
from in interface ChronoLocalDate
Parameters:
temporal - the temporal object to convert, not null
Returns:
the date in Minguo calendar system, not null
Throws:
DateTimeException - if unable to convert to a MinguoDate
See Also:
Chronology.date(TemporalAccessor)


"
MinguoDate,getChronology(),MinguoChronology,"Gets the chronology of this date, which is the Minguo calendar system.","

getChronology
public MinguoChronology getChronology()
Gets the chronology of this date, which is the Minguo calendar system.
 
 The Chronology represents the calendar system in use.
 The era and other fields in ChronoField are defined by the chronology.

Specified by:
getChronology in interface ChronoLocalDate
Returns:
the Minguo chronology, not null


"
MinguoDate,getEra(),MinguoEra,Gets the era applicable at this date.,"

getEra
public MinguoEra getEra()
Gets the era applicable at this date.
 
 The Minguo calendar system has two eras, 'ROC' and 'BEFORE_ROC',
 defined by MinguoEra.

Specified by:
getEra in interface ChronoLocalDate
Returns:
the era applicable at this date, not null


"
MinguoDate,getLong(TemporalField field),long,Gets the value of the specified field as a long.,"

getLong
public long getLong(TemporalField field)
Description copied from interface: TemporalAccessor
Gets the value of the specified field as a long.
 
 This queries the date-time for the value of the specified field.
 The returned value may be outside the valid range of values for the field.
 If the date-time cannot return the value, because the field is unsupported or for
 some other reason, an exception will be thrown.

Specified by:
getLong in interface TemporalAccessor
Parameters:
field - the field to get, not null
Returns:
the value for the field


"
MinguoDate,hashCode(),int,A hash code for this date.,"

hashCode
public int hashCode()
A hash code for this date.

Specified by:
hashCode in interface ChronoLocalDate
Returns:
a suitable hash code based only on the Chronology and the date
See Also:
Object.equals(java.lang.Object), 
System.identityHashCode(java.lang.Object)


"
MinguoDate,lengthOfMonth(),int,Returns the length of the month represented by this date.,"

lengthOfMonth
public int lengthOfMonth()
Returns the length of the month represented by this date.
 
 This returns the length of the month in days.
 Month lengths match those of the ISO calendar system.

Specified by:
lengthOfMonth in interface ChronoLocalDate
Returns:
the length of the month in days


"
MinguoDate,"minus(long amountToAdd, TemporalUnit unit)",MinguoDate,Returns an object of the same type as this object with the specified period subtracted.,"

minus
public MinguoDate minus(long amountToAdd,
                        TemporalUnit unit)
Description copied from interface: ChronoLocalDate
Returns an object of the same type as this object with the specified period subtracted.
 
 This method returns a new object based on this one with the specified period subtracted.
 For example, on a LocalDate, this could be used to subtract a number of years, months or days.
 The returned object will have the same observable type as this object.
 
 In some cases, changing a field is not fully defined. For example, if the target object is
 a date representing the 31st March, then subtracting one month would be unclear.
 In cases like this, the field is responsible for resolving the result. Typically it will choose
 the previous valid date, which would be the last valid day of February in this example.

Specified by:
minus in interface ChronoLocalDate
Specified by:
minus in interface Temporal
Parameters:
amountToAdd - the amount of the specified unit to subtract, may be negative
unit - the unit of the amount to subtract, not null
Returns:
an object of the same type with the specified period subtracted, not null


"
MinguoDate,minus(TemporalAmount amount),MinguoDate,Returns an object of the same type as this object with an amount subtracted.,"

minus
public MinguoDate minus(TemporalAmount amount)
Returns an object of the same type as this object with an amount subtracted.
 
 This adjusts this temporal, subtracting according to the rules of the specified amount.
 The amount is typically a Period but may be any other type implementing
 the TemporalAmount interface, such as Duration.
 
 Some example code indicating how and why this method is used:
 
  date = date.minus(period);               // subtract a Period instance
  date = date.minus(duration);             // subtract a Duration instance
  date = date.minus(workingDays(6));       // example user-written workingDays method
 

 Note that calling plus followed by minus is not guaranteed to
 return the same date-time.

Specified by:
minus in interface ChronoLocalDate
Specified by:
minus in interface Temporal
Parameters:
amount - the amount to subtract, not null
Returns:
an object of the same type with the specified adjustment made, not null
Throws:
DateTimeException - if the subtraction cannot be made
ArithmeticException - if numeric overflow occurs


"
MinguoDate,now(),static MinguoDate,Obtains the current MinguoDate from the system clock in the default time-zone.,"

now
public static MinguoDate now()
Obtains the current MinguoDate from the system clock in the default time-zone.
 
 This will query the system clock in the default
 time-zone to obtain the current date.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Returns:
the current date using the system clock and default time-zone, not null


"
MinguoDate,now(Clock clock),static MinguoDate,Obtains the current MinguoDate from the specified clock.,"

now
public static MinguoDate now(Clock clock)
Obtains the current MinguoDate from the specified clock.
 
 This will query the specified clock to obtain the current date - today.
 Using this method allows the use of an alternate clock for testing.
 The alternate clock may be introduced using dependency injection.

Parameters:
clock - the clock to use, not null
Returns:
the current date, not null
Throws:
DateTimeException - if the current date cannot be obtained


"
MinguoDate,now(ZoneId zone),static MinguoDate,Obtains the current MinguoDate from the system clock in the specified time-zone.,"

now
public static MinguoDate now(ZoneId zone)
Obtains the current MinguoDate from the system clock in the specified time-zone.
 
 This will query the system clock to obtain the current date.
 Specifying the time-zone avoids dependence on the default time-zone.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Parameters:
zone - the zone ID to use, not null
Returns:
the current date using the system clock, not null


"
MinguoDate,"of(int prolepticYear, int month, int dayOfMonth)",static MinguoDate,"Obtains a MinguoDate representing a date in the Minguo calendar system from the proleptic-year, month-of-year and day-of-month fields.","

of
public static MinguoDate of(int prolepticYear,
                            int month,
                            int dayOfMonth)
Obtains a MinguoDate representing a date in the Minguo calendar
 system from the proleptic-year, month-of-year and day-of-month fields.
 
 This returns a MinguoDate with the specified fields.
 The day must be valid for the year and month, otherwise an exception will be thrown.

Parameters:
prolepticYear - the Minguo proleptic-year
month - the Minguo month-of-year, from 1 to 12
dayOfMonth - the Minguo day-of-month, from 1 to 31
Returns:
the date in Minguo calendar system, not null
Throws:
DateTimeException - if the value of any field is out of range,
  or if the day-of-month is invalid for the month-year


"
MinguoDate,"plus(long amountToAdd, TemporalUnit unit)",MinguoDate,Returns an object of the same type as this object with the specified period added.,"

plus
public MinguoDate plus(long amountToAdd,
                       TemporalUnit unit)
Description copied from interface: ChronoLocalDate
Returns an object of the same type as this object with the specified period added.
 
 This method returns a new object based on this one with the specified period added.
 For example, on a LocalDate, this could be used to add a number of years, months or days.
 The returned object will have the same observable type as this object.
 
 In some cases, changing a field is not fully defined. For example, if the target object is
 a date representing the 31st January, then adding one month would be unclear.
 In cases like this, the field is responsible for resolving the result. Typically it will choose
 the previous valid date, which would be the last valid day of February in this example.

Specified by:
plus in interface ChronoLocalDate
Specified by:
plus in interface Temporal
Parameters:
amountToAdd - the amount of the specified unit to add, may be negative
unit - the unit of the amount to add, not null
Returns:
an object of the same type with the specified period added, not null


"
MinguoDate,plus(TemporalAmount amount),MinguoDate,Returns an object of the same type as this object with an amount added.,"

plus
public MinguoDate plus(TemporalAmount amount)
Returns an object of the same type as this object with an amount added.
 
 This adjusts this temporal, adding according to the rules of the specified amount.
 The amount is typically a Period but may be any other type implementing
 the TemporalAmount interface, such as Duration.
 
 Some example code indicating how and why this method is used:
 
  date = date.plus(period);                // add a Period instance
  date = date.plus(duration);              // add a Duration instance
  date = date.plus(workingDays(6));        // example user-written workingDays method
 

 Note that calling plus followed by minus is not guaranteed to
 return the same date-time.

Specified by:
plus in interface ChronoLocalDate
Specified by:
plus in interface Temporal
Parameters:
amount - the amount to add, not null
Returns:
an object of the same type with the specified adjustment made, not null
Throws:
DateTimeException - if the addition cannot be made
ArithmeticException - if numeric overflow occurs


"
MinguoDate,range(TemporalField field),ValueRange,Gets the range of valid values for the specified field.,"

range
public ValueRange range(TemporalField field)
Description copied from interface: TemporalAccessor
Gets the range of valid values for the specified field.
 
 All fields can be expressed as a long integer.
 This method returns an object that describes the valid range for that value.
 The value of this temporal object is used to enhance the accuracy of the returned range.
 If the date-time cannot return the range, because the field is unsupported or for
 some other reason, an exception will be thrown.
 
 Note that the result only describes the minimum and maximum valid values
 and it is important not to read too much into them. For example, there
 could be values within the range that are invalid for the field.

Specified by:
range in interface TemporalAccessor
Parameters:
field - the field to query the range for, not null
Returns:
the range of valid values for the field, not null


"
MinguoDate,toEpochDay(),long,Converts this date to the Epoch Day.,"

toEpochDay
public long toEpochDay()
Description copied from interface: ChronoLocalDate
Converts this date to the Epoch Day.
 
 The Epoch Day count is a simple
 incrementing count of days where day 0 is 1970-01-01 (ISO).
 This definition is the same for all chronologies, enabling conversion.
 
 This default implementation queries the EPOCH_DAY field.

Specified by:
toEpochDay in interface ChronoLocalDate
Returns:
the Epoch Day equivalent to this date


"
MinguoDate,toString(),String,Returns a string representation of the object.,"

toString
public String toString()
Description copied from class: Object
Returns a string representation of the object. In general, the
 toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method.
 
 The toString method for class Object
 returns a string consisting of the name of the class of which the
 object is an instance, the at-sign character `@', and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words, this method returns a string equal to the
 value of:
 

 getClass().getName() + '@' + Integer.toHexString(hashCode())
 

Specified by:
toString in interface ChronoLocalDate
Overrides:
toString in class Object
Returns:
a string representation of the object.


"
MinguoDate,until(ChronoLocalDate endDate),ChronoPeriod,Calculates the period between this date and another date as a ChronoPeriod.,"

until
public ChronoPeriod until(ChronoLocalDate endDate)
Description copied from interface: ChronoLocalDate
Calculates the period between this date and another date as a ChronoPeriod.
 
 This calculates the period between two dates. All supplied chronologies
 calculate the period using years, months and days, however the
 ChronoPeriod API allows the period to be represented using other units.
 
 The start and end points are this and the specified date.
 The result will be negative if the end is before the start.
 The negative sign will be the same in each of year, month and day.
 
 The calculation is performed using the chronology of this date.
 If necessary, the input date will be converted to match.
 
 This instance is immutable and unaffected by this method call.

Specified by:
until in interface ChronoLocalDate
Parameters:
endDate - the end date, exclusive, which may be in any chronology, not null
Returns:
the period between this date and the end date, not null


"
MinguoDate,"until(Temporal endExclusive, TemporalUnit unit)",long,Calculates the amount of time until another date in terms of the specified unit.,"

until
public long until(Temporal endExclusive,
                  TemporalUnit unit)
Description copied from interface: ChronoLocalDate
Calculates the amount of time until another date in terms of the specified unit.
 
 This calculates the amount of time between two ChronoLocalDate
 objects in terms of a single TemporalUnit.
 The start and end points are this and the specified date.
 The result will be negative if the end is before the start.
 The Temporal passed to this method is converted to a
 ChronoLocalDate using Chronology.date(TemporalAccessor).
 The calculation returns a whole number, representing the number of
 complete units between the two dates.
 For example, the amount in days between two dates can be calculated
 using startDate.until(endDate, DAYS).
 
 There are two equivalent ways of using this method.
 The first is to invoke this method.
 The second is to use TemporalUnit.between(Temporal, Temporal):
 
   // these two lines are equivalent
   amount = start.until(end, MONTHS);
   amount = MONTHS.between(start, end);
 
 The choice should be made based on which makes the code more readable.
 
 The calculation is implemented in this method for ChronoUnit.
 The units DAYS, WEEKS, MONTHS, YEARS,
 DECADES, CENTURIES, MILLENNIA and ERAS
 should be supported by all implementations.
 Other ChronoUnit values will throw an exception.
 
 If the unit is not a ChronoUnit, then the result of this method
 is obtained by invoking TemporalUnit.between(Temporal, Temporal)
 passing this as the first argument and the converted input temporal as
 the second argument.
 
 This instance is immutable and unaffected by this method call.

Specified by:
until in interface ChronoLocalDate
Specified by:
until in interface Temporal
Parameters:
endExclusive - the end date, exclusive, which is converted to a
  ChronoLocalDate in the same chronology, not null
unit - the unit to measure the amount in, not null
Returns:
the amount of time between this date and the end date


"
MinguoDate,with(TemporalAdjuster adjuster),MinguoDate,Returns an adjusted object of the same type as this object with the adjustment made.,"

with
public MinguoDate with(TemporalAdjuster adjuster)
Returns an adjusted object of the same type as this object with the adjustment made.
 
 This adjusts this date-time according to the rules of the specified adjuster.
 A simple adjuster might simply set the one of the fields, such as the year field.
 A more complex adjuster might set the date to the last day of the month.
 A selection of common adjustments is provided in
 TemporalAdjusters.
 These include finding the ""last day of the month"" and ""next Wednesday"".
 The adjuster is responsible for handling special cases, such as the varying
 lengths of month and leap years.
 
 Some example code indicating how and why this method is used:
 
  date = date.with(Month.JULY);        // most key classes implement TemporalAdjuster
  date = date.with(lastDayOfMonth());  // static import from Adjusters
  date = date.with(next(WEDNESDAY));   // static import from Adjusters and DayOfWeek
 

Specified by:
with in interface ChronoLocalDate
Specified by:
with in interface Temporal
Parameters:
adjuster - the adjuster to use, not null
Returns:
an object of the same type with the specified adjustment made, not null
Throws:
DateTimeException - if unable to make the adjustment
ArithmeticException - if numeric overflow occurs


"
MinguoDate,"with(TemporalField field, long newValue)",MinguoDate,Returns an object of the same type as this object with the specified field altered.,"

with
public MinguoDate with(TemporalField field,
                       long newValue)
Description copied from interface: ChronoLocalDate
Returns an object of the same type as this object with the specified field altered.
 
 This returns a new object based on this one with the value for the specified field changed.
 For example, on a LocalDate, this could be used to set the year, month or day-of-month.
 The returned object will have the same observable type as this object.
 
 In some cases, changing a field is not fully defined. For example, if the target object is
 a date representing the 31st January, then changing the month to February would be unclear.
 In cases like this, the field is responsible for resolving the result. Typically it will choose
 the previous valid date, which would be the last valid day of February in this example.

Specified by:
with in interface ChronoLocalDate
Specified by:
with in interface Temporal
Parameters:
field - the field to set in the result, not null
newValue - the new value of the field in the result
Returns:
an object of the same type with the specified field set, not null


"
ThaiBuddhistChronology,"date(Era era, int yearOfEra, int month, int dayOfMonth)",ThaiBuddhistDate,"Obtains a local date in Thai Buddhist calendar system from the era, year-of-era, month-of-year and day-of-month fields.","

date
public ThaiBuddhistDate date(Era era,
                             int yearOfEra,
                             int month,
                             int dayOfMonth)
Obtains a local date in Thai Buddhist calendar system from the
 era, year-of-era, month-of-year and day-of-month fields.

Specified by:
date in interface Chronology
Parameters:
era - the Thai Buddhist era, not null
yearOfEra - the year-of-era
month - the month-of-year
dayOfMonth - the day-of-month
Returns:
the Thai Buddhist local date, not null
Throws:
DateTimeException - if unable to create the date
ClassCastException - if the era is not a ThaiBuddhistEra


"
ThaiBuddhistChronology,"date(int prolepticYear, int month, int dayOfMonth)",ThaiBuddhistDate,"Obtains a local date in Thai Buddhist calendar system from the proleptic-year, month-of-year and day-of-month fields.","

date
public ThaiBuddhistDate date(int prolepticYear,
                             int month,
                             int dayOfMonth)
Obtains a local date in Thai Buddhist calendar system from the
 proleptic-year, month-of-year and day-of-month fields.

Specified by:
date in interface Chronology
Parameters:
prolepticYear - the proleptic-year
month - the month-of-year
dayOfMonth - the day-of-month
Returns:
the Thai Buddhist local date, not null
Throws:
DateTimeException - if unable to create the date


"
ThaiBuddhistChronology,date(TemporalAccessor temporal),ThaiBuddhistDate,Obtains a local date in this chronology from another temporal object.,"

date
public ThaiBuddhistDate date(TemporalAccessor temporal)
Description copied from interface: Chronology
Obtains a local date in this chronology from another temporal object.
 
 This obtains a date in this chronology based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ChronoLocalDate.
 
 The conversion typically uses the EPOCH_DAY
 field, which is standardized across calendar systems.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, aChronology::date.

Specified by:
date in interface Chronology
Parameters:
temporal - the temporal object to convert, not null
Returns:
the local date in this chronology, not null
See Also:
ChronoLocalDate.from(TemporalAccessor)


"
ThaiBuddhistChronology,dateEpochDay(long epochDay),ThaiBuddhistDate,Obtains a local date in the Thai Buddhist calendar system from the epoch-day.,"

dateEpochDay
public ThaiBuddhistDate dateEpochDay(long epochDay)
Obtains a local date in the Thai Buddhist calendar system from the epoch-day.

Specified by:
dateEpochDay in interface Chronology
Parameters:
epochDay - the epoch day
Returns:
the Thai Buddhist local date, not null
Throws:
DateTimeException - if unable to create the date


"
ThaiBuddhistChronology,dateNow(),ThaiBuddhistDate,Obtains the current local date in this chronology from the system clock in the default time-zone.,"

dateNow
public ThaiBuddhistDate dateNow()
Description copied from interface: Chronology
Obtains the current local date in this chronology from the system clock in the default time-zone.
 
 This will query the system clock in the default
 time-zone to obtain the current date.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Specified by:
dateNow in interface Chronology
Returns:
the current local date using the system clock and default time-zone, not null


"
ThaiBuddhistChronology,dateNow(Clock clock),ThaiBuddhistDate,Obtains the current local date in this chronology from the specified clock.,"

dateNow
public ThaiBuddhistDate dateNow(Clock clock)
Description copied from interface: Chronology
Obtains the current local date in this chronology from the specified clock.
 
 This will query the specified clock to obtain the current date - today.
 Using this method allows the use of an alternate clock for testing.
 The alternate clock may be introduced using dependency injection.

Specified by:
dateNow in interface Chronology
Parameters:
clock - the clock to use, not null
Returns:
the current local date, not null


"
ThaiBuddhistChronology,dateNow(ZoneId zone),ThaiBuddhistDate,Obtains the current local date in this chronology from the system clock in the specified time-zone.,"

dateNow
public ThaiBuddhistDate dateNow(ZoneId zone)
Description copied from interface: Chronology
Obtains the current local date in this chronology from the system clock in the specified time-zone.
 
 This will query the system clock to obtain the current date.
 Specifying the time-zone avoids dependence on the default time-zone.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Specified by:
dateNow in interface Chronology
Parameters:
zone - the zone ID to use, not null
Returns:
the current local date using the system clock, not null


"
ThaiBuddhistChronology,"dateYearDay(Era era, int yearOfEra, int dayOfYear)",ThaiBuddhistDate,"Obtains a local date in Thai Buddhist calendar system from the era, year-of-era and day-of-year fields.","

dateYearDay
public ThaiBuddhistDate dateYearDay(Era era,
                                    int yearOfEra,
                                    int dayOfYear)
Obtains a local date in Thai Buddhist calendar system from the
 era, year-of-era and day-of-year fields.

Specified by:
dateYearDay in interface Chronology
Parameters:
era - the Thai Buddhist era, not null
yearOfEra - the year-of-era
dayOfYear - the day-of-year
Returns:
the Thai Buddhist local date, not null
Throws:
DateTimeException - if unable to create the date
ClassCastException - if the era is not a ThaiBuddhistEra


"
ThaiBuddhistChronology,"dateYearDay(int prolepticYear, int dayOfYear)",ThaiBuddhistDate,Obtains a local date in Thai Buddhist calendar system from the proleptic-year and day-of-year fields.,"

dateYearDay
public ThaiBuddhistDate dateYearDay(int prolepticYear,
                                    int dayOfYear)
Obtains a local date in Thai Buddhist calendar system from the
 proleptic-year and day-of-year fields.

Specified by:
dateYearDay in interface Chronology
Parameters:
prolepticYear - the proleptic-year
dayOfYear - the day-of-year
Returns:
the Thai Buddhist local date, not null
Throws:
DateTimeException - if unable to create the date


"
ThaiBuddhistChronology,eraOf(int eraValue),ThaiBuddhistEra,Creates the chronology era object from the numeric value.,"

eraOf
public ThaiBuddhistEra eraOf(int eraValue)
Description copied from interface: Chronology
Creates the chronology era object from the numeric value.
 
 The era is, conceptually, the largest division of the time-line.
 Most calendar systems have a single epoch dividing the time-line into two eras.
 However, some have multiple eras, such as one for the reign of each leader.
 The exact meaning is determined by the chronology according to the following constraints.
 
 The era in use at 1970-01-01 must have the value 1.
 Later eras must have sequentially higher values.
 Earlier eras must have sequentially lower values.
 Each chronology must refer to an enum or similar singleton to provide the era values.
 
 This method returns the singleton era of the correct type for the specified era value.

Specified by:
eraOf in interface Chronology
Parameters:
eraValue - the era value
Returns:
the calendar system era, not null


"
ThaiBuddhistChronology,eras(),List<Era>,Gets the list of eras for the chronology.,"

eras
public List<Era> eras()
Description copied from interface: Chronology
Gets the list of eras for the chronology.
 
 Most calendar systems have an era, within which the year has meaning.
 If the calendar system does not support the concept of eras, an empty
 list must be returned.

Specified by:
eras in interface Chronology
Returns:
the list of eras for the chronology, may be immutable, not null


"
ThaiBuddhistChronology,getCalendarType(),String,Gets the calendar type of the underlying calendar system - 'buddhist'.,"

getCalendarType
public String getCalendarType()
Gets the calendar type of the underlying calendar system - 'buddhist'.
 
 The calendar type is an identifier defined by the
 Unicode Locale Data Markup Language (LDML) specification.
 It can be used to lookup the Chronology using Chronology.of(String).
 It can also be used as part of a locale, accessible via
 Locale.getUnicodeLocaleType(String) with the key 'ca'.

Specified by:
getCalendarType in interface Chronology
Returns:
the calendar system type - 'buddhist'
See Also:
getId()


"
ThaiBuddhistChronology,getId(),String,Gets the ID of the chronology - 'ThaiBuddhist'.,"

getId
public String getId()
Gets the ID of the chronology - 'ThaiBuddhist'.
 
 The ID uniquely identifies the Chronology.
 It can be used to lookup the Chronology using Chronology.of(String).

Specified by:
getId in interface Chronology
Returns:
the chronology ID - 'ThaiBuddhist'
See Also:
getCalendarType()


"
ThaiBuddhistChronology,isLeapYear(long prolepticYear),boolean,Checks if the specified year is a leap year.,"

isLeapYear
public boolean isLeapYear(long prolepticYear)
Checks if the specified year is a leap year.
 
 Thai Buddhist leap years occur exactly in line with ISO leap years.
 This method does not validate the year passed in, and only has a
 well-defined result for years in the supported range.

Specified by:
isLeapYear in interface Chronology
Parameters:
prolepticYear - the proleptic-year to check, not validated for range
Returns:
true if the year is a leap year


"
ThaiBuddhistChronology,localDateTime(TemporalAccessor temporal),ChronoLocalDateTime<ThaiBuddhistDate>,Obtains a local date-time in this chronology from another temporal object.,"

localDateTime
public ChronoLocalDateTime<ThaiBuddhistDate> localDateTime(TemporalAccessor temporal)
Description copied from interface: Chronology
Obtains a local date-time in this chronology from another temporal object.
 
 This obtains a date-time in this chronology based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ChronoLocalDateTime.
 
 The conversion extracts and combines the ChronoLocalDate and the
 LocalTime from the temporal object.
 Implementations are permitted to perform optimizations such as accessing
 those fields that are equivalent to the relevant objects.
 The result uses this chronology.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, aChronology::localDateTime.

Specified by:
localDateTime in interface Chronology
Parameters:
temporal - the temporal object to convert, not null
Returns:
the local date-time in this chronology, not null
See Also:
ChronoLocalDateTime.from(TemporalAccessor)


"
ThaiBuddhistChronology,"prolepticYear(Era era, int yearOfEra)",int,Calculates the proleptic-year given the era and year-of-era.,"

prolepticYear
public int prolepticYear(Era era,
                         int yearOfEra)
Description copied from interface: Chronology
Calculates the proleptic-year given the era and year-of-era.
 
 This combines the era and year-of-era into the single proleptic-year field.
 
 If the chronology makes active use of eras, such as JapaneseChronology
 then the year-of-era will be validated against the era.
 For other chronologies, validation is optional.

Specified by:
prolepticYear in interface Chronology
Parameters:
era - the era of the correct type for the chronology, not null
yearOfEra - the chronology year-of-era
Returns:
the proleptic-year


"
ThaiBuddhistChronology,range(ChronoField field),ValueRange,Gets the range of valid values for the specified field.,"

range
public ValueRange range(ChronoField field)
Description copied from interface: Chronology
Gets the range of valid values for the specified field.
 
 All fields can be expressed as a long integer.
 This method returns an object that describes the valid range for that value.
 
 Note that the result only describes the minimum and maximum valid values
 and it is important not to read too much into them. For example, there
 could be values within the range that are invalid for the field.
 
 This method will return a result whether or not the chronology supports the field.

Specified by:
range in interface Chronology
Parameters:
field - the field to get the range for, not null
Returns:
the range of valid values for the field, not null


"
ThaiBuddhistChronology,"resolveDate(Map<TemporalField,Long> fieldValues, ResolverStyle resolverStyle)",ThaiBuddhistDate,Resolves parsed ChronoField values into a date during parsing.,"

resolveDate
public ThaiBuddhistDate resolveDate(Map<TemporalField,Long> fieldValues,
                                    ResolverStyle resolverStyle)
Description copied from class: AbstractChronology
Resolves parsed ChronoField values into a date during parsing.
 
 Most TemporalField implementations are resolved using the
 resolve method on the field. By contrast, the ChronoField class
 defines fields that only have meaning relative to the chronology.
 As such, ChronoField date fields are resolved here in the
 context of a specific chronology.
 
ChronoField instances are resolved by this method, which may
 be overridden in subclasses.
 
EPOCH_DAY - If present, this is converted to a date and
  all other date fields are then cross-checked against the date.
 PROLEPTIC_MONTH - If present, then it is split into the
  YEAR and MONTH_OF_YEAR. If the mode is strict or smart
  then the field is validated.
 YEAR_OF_ERA and ERA - If both are present, then they
  are combined to form a YEAR. In lenient mode, the YEAR_OF_ERA
  range is not validated, in smart and strict mode it is. The ERA is
  validated for range in all three modes. If only the YEAR_OF_ERA is
  present, and the mode is smart or lenient, then the last available era
  is assumed. In strict mode, no era is assumed and the YEAR_OF_ERA is
  left untouched. If only the ERA is present, then it is left untouched.
 YEAR, MONTH_OF_YEAR and DAY_OF_MONTH -
  If all three are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is smart or strict, then the month and day are validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the first month in the requested year,
  then adding the difference in months, then the difference in days.
  If the mode is smart, and the day-of-month is greater than the maximum for
  the year-month, then the day-of-month is adjusted to the last day-of-month.
  If the mode is strict, then the three fields must form a valid date.
 YEAR and DAY_OF_YEAR -
  If both are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the difference in days.
  If the mode is smart or strict, then the two fields must form a valid date.
 YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and
  ALIGNED_DAY_OF_WEEK_IN_MONTH -
  If all four are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the first month in the requested year, then adding
  the difference in months, then the difference in weeks, then in days.
  If the mode is smart or strict, then the all four fields are validated to
  their outer ranges. The date is then combined in a manner equivalent to
  creating a date on the first day of the requested year and month, then adding
  the amount in weeks and days to reach their values. If the mode is strict,
  the date is additionally validated to check that the day and week adjustment
  did not change the month.
 YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and
  DAY_OF_WEEK - If all four are present, then they are combined to
  form a date. The approach is the same as described above for
  years, months and weeks in ALIGNED_DAY_OF_WEEK_IN_MONTH.
  The day-of-week is adjusted as the next or same matching day-of-week once
  the years, months and weeks have been handled.
 YEAR, ALIGNED_WEEK_OF_YEAR and ALIGNED_DAY_OF_WEEK_IN_YEAR -
  If all three are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the difference in weeks, then in days.
  If the mode is smart or strict, then the all three fields are validated to
  their outer ranges. The date is then combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the amount in weeks and days to reach their values. If the mode is strict,
  the date is additionally validated to check that the day and week adjustment
  did not change the year.
 YEAR, ALIGNED_WEEK_OF_YEAR and DAY_OF_WEEK -
  If all three are present, then they are combined to form a date.
  The approach is the same as described above for years and weeks in
  ALIGNED_DAY_OF_WEEK_IN_YEAR. The day-of-week is adjusted as the
  next or same matching day-of-week once the years and weeks have been handled.
 

 The default implementation is suitable for most calendar systems.
 If ChronoField.YEAR_OF_ERA is found without an ChronoField.ERA
 then the last era in Chronology.eras() is used.
 The implementation assumes a 7 day week, that the first day-of-month
 has the value 1, that first day-of-year has the value 1, and that the
 first of the month and year always exists.

Specified by:
resolveDate in interface Chronology
Overrides:
resolveDate in class AbstractChronology
Parameters:
fieldValues - the map of fields to values, which can be updated, not null
resolverStyle - the requested type of resolve, not null
Returns:
the resolved date, null if insufficient information to create a date


"
ThaiBuddhistChronology,"zonedDateTime(Instant instant, ZoneId zone)",ChronoZonedDateTime<ThaiBuddhistDate>,Obtains a ChronoZonedDateTime in this chronology from an Instant.,"

zonedDateTime
public ChronoZonedDateTime<ThaiBuddhistDate> zonedDateTime(Instant instant,
                                                           ZoneId zone)
Description copied from interface: Chronology
Obtains a ChronoZonedDateTime in this chronology from an Instant.
 
 This obtains a zoned date-time with the same instant as that specified.

Specified by:
zonedDateTime in interface Chronology
Parameters:
instant - the instant to create the date-time from, not null
zone - the time-zone, not null
Returns:
the zoned date-time, not null


"
ThaiBuddhistChronology,zonedDateTime(TemporalAccessor temporal),ChronoZonedDateTime<ThaiBuddhistDate>,Obtains a ChronoZonedDateTime in this chronology from another temporal object.,"

zonedDateTime
public ChronoZonedDateTime<ThaiBuddhistDate> zonedDateTime(TemporalAccessor temporal)
Description copied from interface: Chronology
Obtains a ChronoZonedDateTime in this chronology from another temporal object.
 
 This obtains a zoned date-time in this chronology based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ChronoZonedDateTime.
 
 The conversion will first obtain a ZoneId from the temporal object,
 falling back to a ZoneOffset if necessary. It will then try to obtain
 an Instant, falling back to a ChronoLocalDateTime if necessary.
 The result will be either the combination of ZoneId or ZoneOffset
 with Instant or ChronoLocalDateTime.
 Implementations are permitted to perform optimizations such as accessing
 those fields that are equivalent to the relevant objects.
 The result uses this chronology.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, aChronology::zonedDateTime.

Specified by:
zonedDateTime in interface Chronology
Parameters:
temporal - the temporal object to convert, not null
Returns:
the zoned date-time in this chronology, not null
See Also:
ChronoZonedDateTime.from(TemporalAccessor)


"
ThaiBuddhistDate,atTime(LocalTime localTime),ChronoLocalDateTime<ThaiBuddhistDate>,Combines this date with a time to create a ChronoLocalDateTime.,"

atTime
public final ChronoLocalDateTime<ThaiBuddhistDate> atTime(LocalTime localTime)
Description copied from interface: ChronoLocalDate
Combines this date with a time to create a ChronoLocalDateTime.
 
 This returns a ChronoLocalDateTime formed from this date at the specified time.
 All possible combinations of date and time are valid.

Specified by:
atTime in interface ChronoLocalDate
Parameters:
localTime - the local time to use, not null
Returns:
the local date-time formed from this date and the specified time, not null


"
ThaiBuddhistDate,equals(Object obj),boolean,"Compares this date to another date, including the chronology.","

equals
public boolean equals(Object obj)
Compares this date to another date, including the chronology.
 
 Compares this ThaiBuddhistDate with another ensuring that the date is the same.
 
 Only objects of type ThaiBuddhistDate are compared, other types return false.
 To compare the dates of two TemporalAccessor instances, including dates
 in two different chronologies, use ChronoField.EPOCH_DAY as a comparator.

Specified by:
equals in interface ChronoLocalDate
Parameters:
obj - the object to check, null returns false
Returns:
true if this is equal to the other date
See Also:
Object.hashCode(), 
HashMap


"
ThaiBuddhistDate,from(TemporalAccessor temporal),static ThaiBuddhistDate,Obtains a ThaiBuddhistDate from a temporal object.,"

from
public static ThaiBuddhistDate from(TemporalAccessor temporal)
Obtains a ThaiBuddhistDate from a temporal object.
 
 This obtains a date in the Thai Buddhist calendar system based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ThaiBuddhistDate.
 
 The conversion typically uses the EPOCH_DAY
 field, which is standardized across calendar systems.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, ThaiBuddhistDate::from.

Specified by:
from in interface ChronoLocalDate
Parameters:
temporal - the temporal object to convert, not null
Returns:
the date in Thai Buddhist calendar system, not null
Throws:
DateTimeException - if unable to convert to a ThaiBuddhistDate
See Also:
Chronology.date(TemporalAccessor)


"
ThaiBuddhistDate,getChronology(),ThaiBuddhistChronology,"Gets the chronology of this date, which is the Thai Buddhist calendar system.","

getChronology
public ThaiBuddhistChronology getChronology()
Gets the chronology of this date, which is the Thai Buddhist calendar system.
 
 The Chronology represents the calendar system in use.
 The era and other fields in ChronoField are defined by the chronology.

Specified by:
getChronology in interface ChronoLocalDate
Returns:
the Thai Buddhist chronology, not null


"
ThaiBuddhistDate,getEra(),ThaiBuddhistEra,Gets the era applicable at this date.,"

getEra
public ThaiBuddhistEra getEra()
Gets the era applicable at this date.
 
 The Thai Buddhist calendar system has two eras, 'BE' and 'BEFORE_BE',
 defined by ThaiBuddhistEra.

Specified by:
getEra in interface ChronoLocalDate
Returns:
the era applicable at this date, not null


"
ThaiBuddhistDate,getLong(TemporalField field),long,Gets the value of the specified field as a long.,"

getLong
public long getLong(TemporalField field)
Description copied from interface: TemporalAccessor
Gets the value of the specified field as a long.
 
 This queries the date-time for the value of the specified field.
 The returned value may be outside the valid range of values for the field.
 If the date-time cannot return the value, because the field is unsupported or for
 some other reason, an exception will be thrown.

Specified by:
getLong in interface TemporalAccessor
Parameters:
field - the field to get, not null
Returns:
the value for the field


"
ThaiBuddhistDate,hashCode(),int,A hash code for this date.,"

hashCode
public int hashCode()
A hash code for this date.

Specified by:
hashCode in interface ChronoLocalDate
Returns:
a suitable hash code based only on the Chronology and the date
See Also:
Object.equals(java.lang.Object), 
System.identityHashCode(java.lang.Object)


"
ThaiBuddhistDate,lengthOfMonth(),int,Returns the length of the month represented by this date.,"

lengthOfMonth
public int lengthOfMonth()
Returns the length of the month represented by this date.
 
 This returns the length of the month in days.
 Month lengths match those of the ISO calendar system.

Specified by:
lengthOfMonth in interface ChronoLocalDate
Returns:
the length of the month in days


"
ThaiBuddhistDate,"minus(long amountToAdd, TemporalUnit unit)",ThaiBuddhistDate,Returns an object of the same type as this object with the specified period subtracted.,"

minus
public ThaiBuddhistDate minus(long amountToAdd,
                              TemporalUnit unit)
Description copied from interface: ChronoLocalDate
Returns an object of the same type as this object with the specified period subtracted.
 
 This method returns a new object based on this one with the specified period subtracted.
 For example, on a LocalDate, this could be used to subtract a number of years, months or days.
 The returned object will have the same observable type as this object.
 
 In some cases, changing a field is not fully defined. For example, if the target object is
 a date representing the 31st March, then subtracting one month would be unclear.
 In cases like this, the field is responsible for resolving the result. Typically it will choose
 the previous valid date, which would be the last valid day of February in this example.

Specified by:
minus in interface ChronoLocalDate
Specified by:
minus in interface Temporal
Parameters:
amountToAdd - the amount of the specified unit to subtract, may be negative
unit - the unit of the amount to subtract, not null
Returns:
an object of the same type with the specified period subtracted, not null


"
ThaiBuddhistDate,minus(TemporalAmount amount),ThaiBuddhistDate,Returns an object of the same type as this object with an amount subtracted.,"

minus
public ThaiBuddhistDate minus(TemporalAmount amount)
Returns an object of the same type as this object with an amount subtracted.
 
 This adjusts this temporal, subtracting according to the rules of the specified amount.
 The amount is typically a Period but may be any other type implementing
 the TemporalAmount interface, such as Duration.
 
 Some example code indicating how and why this method is used:
 
  date = date.minus(period);               // subtract a Period instance
  date = date.minus(duration);             // subtract a Duration instance
  date = date.minus(workingDays(6));       // example user-written workingDays method
 

 Note that calling plus followed by minus is not guaranteed to
 return the same date-time.

Specified by:
minus in interface ChronoLocalDate
Specified by:
minus in interface Temporal
Parameters:
amount - the amount to subtract, not null
Returns:
an object of the same type with the specified adjustment made, not null
Throws:
DateTimeException - if the subtraction cannot be made
ArithmeticException - if numeric overflow occurs


"
ThaiBuddhistDate,now(),static ThaiBuddhistDate,Obtains the current ThaiBuddhistDate from the system clock in the default time-zone.,"

now
public static ThaiBuddhistDate now()
Obtains the current ThaiBuddhistDate from the system clock in the default time-zone.
 
 This will query the system clock in the default
 time-zone to obtain the current date.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Returns:
the current date using the system clock and default time-zone, not null


"
ThaiBuddhistDate,now(Clock clock),static ThaiBuddhistDate,Obtains the current ThaiBuddhistDate from the specified clock.,"

now
public static ThaiBuddhistDate now(Clock clock)
Obtains the current ThaiBuddhistDate from the specified clock.
 
 This will query the specified clock to obtain the current date - today.
 Using this method allows the use of an alternate clock for testing.
 The alternate clock may be introduced using dependency injection.

Parameters:
clock - the clock to use, not null
Returns:
the current date, not null
Throws:
DateTimeException - if the current date cannot be obtained


"
ThaiBuddhistDate,now(ZoneId zone),static ThaiBuddhistDate,Obtains the current ThaiBuddhistDate from the system clock in the specified time-zone.,"

now
public static ThaiBuddhistDate now(ZoneId zone)
Obtains the current ThaiBuddhistDate from the system clock in the specified time-zone.
 
 This will query the system clock to obtain the current date.
 Specifying the time-zone avoids dependence on the default time-zone.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Parameters:
zone - the zone ID to use, not null
Returns:
the current date using the system clock, not null


"
ThaiBuddhistDate,"of(int prolepticYear, int month, int dayOfMonth)",static ThaiBuddhistDate,"Obtains a ThaiBuddhistDate representing a date in the Thai Buddhist calendar system from the proleptic-year, month-of-year and day-of-month fields.","

of
public static ThaiBuddhistDate of(int prolepticYear,
                                  int month,
                                  int dayOfMonth)
Obtains a ThaiBuddhistDate representing a date in the Thai Buddhist calendar
 system from the proleptic-year, month-of-year and day-of-month fields.
 
 This returns a ThaiBuddhistDate with the specified fields.
 The day must be valid for the year and month, otherwise an exception will be thrown.

Parameters:
prolepticYear - the Thai Buddhist proleptic-year
month - the Thai Buddhist month-of-year, from 1 to 12
dayOfMonth - the Thai Buddhist day-of-month, from 1 to 31
Returns:
the date in Thai Buddhist calendar system, not null
Throws:
DateTimeException - if the value of any field is out of range,
  or if the day-of-month is invalid for the month-year


"
ThaiBuddhistDate,"plus(long amountToAdd, TemporalUnit unit)",ThaiBuddhistDate,Returns an object of the same type as this object with the specified period added.,"

plus
public ThaiBuddhistDate plus(long amountToAdd,
                             TemporalUnit unit)
Description copied from interface: ChronoLocalDate
Returns an object of the same type as this object with the specified period added.
 
 This method returns a new object based on this one with the specified period added.
 For example, on a LocalDate, this could be used to add a number of years, months or days.
 The returned object will have the same observable type as this object.
 
 In some cases, changing a field is not fully defined. For example, if the target object is
 a date representing the 31st January, then adding one month would be unclear.
 In cases like this, the field is responsible for resolving the result. Typically it will choose
 the previous valid date, which would be the last valid day of February in this example.

Specified by:
plus in interface ChronoLocalDate
Specified by:
plus in interface Temporal
Parameters:
amountToAdd - the amount of the specified unit to add, may be negative
unit - the unit of the amount to add, not null
Returns:
an object of the same type with the specified period added, not null


"
ThaiBuddhistDate,plus(TemporalAmount amount),ThaiBuddhistDate,Returns an object of the same type as this object with an amount added.,"

plus
public ThaiBuddhistDate plus(TemporalAmount amount)
Returns an object of the same type as this object with an amount added.
 
 This adjusts this temporal, adding according to the rules of the specified amount.
 The amount is typically a Period but may be any other type implementing
 the TemporalAmount interface, such as Duration.
 
 Some example code indicating how and why this method is used:
 
  date = date.plus(period);                // add a Period instance
  date = date.plus(duration);              // add a Duration instance
  date = date.plus(workingDays(6));        // example user-written workingDays method
 

 Note that calling plus followed by minus is not guaranteed to
 return the same date-time.

Specified by:
plus in interface ChronoLocalDate
Specified by:
plus in interface Temporal
Parameters:
amount - the amount to add, not null
Returns:
an object of the same type with the specified adjustment made, not null
Throws:
DateTimeException - if the addition cannot be made
ArithmeticException - if numeric overflow occurs


"
ThaiBuddhistDate,range(TemporalField field),ValueRange,Gets the range of valid values for the specified field.,"

range
public ValueRange range(TemporalField field)
Description copied from interface: TemporalAccessor
Gets the range of valid values for the specified field.
 
 All fields can be expressed as a long integer.
 This method returns an object that describes the valid range for that value.
 The value of this temporal object is used to enhance the accuracy of the returned range.
 If the date-time cannot return the range, because the field is unsupported or for
 some other reason, an exception will be thrown.
 
 Note that the result only describes the minimum and maximum valid values
 and it is important not to read too much into them. For example, there
 could be values within the range that are invalid for the field.

Specified by:
range in interface TemporalAccessor
Parameters:
field - the field to query the range for, not null
Returns:
the range of valid values for the field, not null


"
ThaiBuddhistDate,toEpochDay(),long,Converts this date to the Epoch Day.,"

toEpochDay
public long toEpochDay()
Description copied from interface: ChronoLocalDate
Converts this date to the Epoch Day.
 
 The Epoch Day count is a simple
 incrementing count of days where day 0 is 1970-01-01 (ISO).
 This definition is the same for all chronologies, enabling conversion.
 
 This default implementation queries the EPOCH_DAY field.

Specified by:
toEpochDay in interface ChronoLocalDate
Returns:
the Epoch Day equivalent to this date


"
ThaiBuddhistDate,toString(),String,Returns a string representation of the object.,"

toString
public String toString()
Description copied from class: Object
Returns a string representation of the object. In general, the
 toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method.
 
 The toString method for class Object
 returns a string consisting of the name of the class of which the
 object is an instance, the at-sign character `@', and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words, this method returns a string equal to the
 value of:
 

 getClass().getName() + '@' + Integer.toHexString(hashCode())
 

Specified by:
toString in interface ChronoLocalDate
Overrides:
toString in class Object
Returns:
a string representation of the object.


"
ThaiBuddhistDate,until(ChronoLocalDate endDate),ChronoPeriod,Calculates the period between this date and another date as a ChronoPeriod.,"

until
public ChronoPeriod until(ChronoLocalDate endDate)
Description copied from interface: ChronoLocalDate
Calculates the period between this date and another date as a ChronoPeriod.
 
 This calculates the period between two dates. All supplied chronologies
 calculate the period using years, months and days, however the
 ChronoPeriod API allows the period to be represented using other units.
 
 The start and end points are this and the specified date.
 The result will be negative if the end is before the start.
 The negative sign will be the same in each of year, month and day.
 
 The calculation is performed using the chronology of this date.
 If necessary, the input date will be converted to match.
 
 This instance is immutable and unaffected by this method call.

Specified by:
until in interface ChronoLocalDate
Parameters:
endDate - the end date, exclusive, which may be in any chronology, not null
Returns:
the period between this date and the end date, not null


"
ThaiBuddhistDate,"until(Temporal endExclusive, TemporalUnit unit)",long,Calculates the amount of time until another date in terms of the specified unit.,"

until
public long until(Temporal endExclusive,
                  TemporalUnit unit)
Description copied from interface: ChronoLocalDate
Calculates the amount of time until another date in terms of the specified unit.
 
 This calculates the amount of time between two ChronoLocalDate
 objects in terms of a single TemporalUnit.
 The start and end points are this and the specified date.
 The result will be negative if the end is before the start.
 The Temporal passed to this method is converted to a
 ChronoLocalDate using Chronology.date(TemporalAccessor).
 The calculation returns a whole number, representing the number of
 complete units between the two dates.
 For example, the amount in days between two dates can be calculated
 using startDate.until(endDate, DAYS).
 
 There are two equivalent ways of using this method.
 The first is to invoke this method.
 The second is to use TemporalUnit.between(Temporal, Temporal):
 
   // these two lines are equivalent
   amount = start.until(end, MONTHS);
   amount = MONTHS.between(start, end);
 
 The choice should be made based on which makes the code more readable.
 
 The calculation is implemented in this method for ChronoUnit.
 The units DAYS, WEEKS, MONTHS, YEARS,
 DECADES, CENTURIES, MILLENNIA and ERAS
 should be supported by all implementations.
 Other ChronoUnit values will throw an exception.
 
 If the unit is not a ChronoUnit, then the result of this method
 is obtained by invoking TemporalUnit.between(Temporal, Temporal)
 passing this as the first argument and the converted input temporal as
 the second argument.
 
 This instance is immutable and unaffected by this method call.

Specified by:
until in interface ChronoLocalDate
Specified by:
until in interface Temporal
Parameters:
endExclusive - the end date, exclusive, which is converted to a
  ChronoLocalDate in the same chronology, not null
unit - the unit to measure the amount in, not null
Returns:
the amount of time between this date and the end date


"
ThaiBuddhistDate,with(TemporalAdjuster adjuster),ThaiBuddhistDate,Returns an adjusted object of the same type as this object with the adjustment made.,"

with
public ThaiBuddhistDate with(TemporalAdjuster adjuster)
Returns an adjusted object of the same type as this object with the adjustment made.
 
 This adjusts this date-time according to the rules of the specified adjuster.
 A simple adjuster might simply set the one of the fields, such as the year field.
 A more complex adjuster might set the date to the last day of the month.
 A selection of common adjustments is provided in
 TemporalAdjusters.
 These include finding the ""last day of the month"" and ""next Wednesday"".
 The adjuster is responsible for handling special cases, such as the varying
 lengths of month and leap years.
 
 Some example code indicating how and why this method is used:
 
  date = date.with(Month.JULY);        // most key classes implement TemporalAdjuster
  date = date.with(lastDayOfMonth());  // static import from Adjusters
  date = date.with(next(WEDNESDAY));   // static import from Adjusters and DayOfWeek
 

Specified by:
with in interface ChronoLocalDate
Specified by:
with in interface Temporal
Parameters:
adjuster - the adjuster to use, not null
Returns:
an object of the same type with the specified adjustment made, not null
Throws:
DateTimeException - if unable to make the adjustment
ArithmeticException - if numeric overflow occurs


"
ThaiBuddhistDate,"with(TemporalField field, long newValue)",ThaiBuddhistDate,Returns an object of the same type as this object with the specified field altered.,"

with
public ThaiBuddhistDate with(TemporalField field,
                             long newValue)
Description copied from interface: ChronoLocalDate
Returns an object of the same type as this object with the specified field altered.
 
 This returns a new object based on this one with the value for the specified field changed.
 For example, on a LocalDate, this could be used to set the year, month or day-of-month.
 The returned object will have the same observable type as this object.
 
 In some cases, changing a field is not fully defined. For example, if the target object is
 a date representing the 31st January, then changing the month to February would be unclear.
 In cases like this, the field is responsible for resolving the result. Typically it will choose
 the previous valid date, which would be the last valid day of February in this example.

Specified by:
with in interface ChronoLocalDate
Specified by:
with in interface Temporal
Parameters:
field - the field to set in the result, not null
newValue - the new value of the field in the result
Returns:
an object of the same type with the specified field set, not null


"
