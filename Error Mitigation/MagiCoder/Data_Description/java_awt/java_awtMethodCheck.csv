Sample Number,ClassName,Snippet Number,Method,Exist,Description,Full Description
0,AlphaComposite,1,"AlphaComposite getInstance(int rule, float alpha)",True,Creates an AlphaComposite object with the specified rule and the constant alpha to multiply with the alpha of the source.,"

getInstance
public static AlphaComposite getInstance(int rule,
                                         float alpha)
Creates an AlphaComposite object with the specified rule and
 the constant alpha to multiply with the alpha of the source.
 The source is multiplied with the specified alpha before being composited
 with the destination.

Parameters:
rule - the compositing rule
alpha - the constant alpha to be multiplied with the alpha of
 the source. alpha must be a floating point number in the
 inclusive range [0.0, 1.0].
Throws:
IllegalArgumentException - if
         alpha is less than 0.0 or greater than 1.0, or if
         rule is not one of
         the following:  CLEAR, SRC, DST,
         SRC_OVER, DST_OVER, SRC_IN,
         DST_IN, SRC_OUT, DST_OUT,
         SRC_ATOP, DST_ATOP, or XOR


"
0,AlphaComposite,2,"AlphaComposite getInstance(int rule, float srcAlpha, float dstAlpha)",False,,NULL
0,AlphaComposite,3,"AlphaComposite getInstance(int rule, AlphaComposite src, AlphaComposite dst)",False,,NULL
0,AlphaComposite,4,"AlphaComposite getInstance(int rule, AlphaComposite src, float dstAlpha)",False,,NULL
0,AlphaComposite,5,"AlphaComposite getInstance(int rule, float srcAlpha, AlphaComposite dst)",False,,NULL
1,AWTEvent,1,"AWTEvent(Object source, int id)",False,,NULL
1,AWTEvent,2,Object getSource(),False,,NULL
1,AWTEvent,3,int getID(),True,Returns the event type.,"

getID
public int getID()
Returns the event type.

"
1,AWTEvent,4,void consume(),True,"Consumes this event, if this event can be consumed.","

consume
protected void consume()
Consumes this event, if this event can be consumed. Only low-level,
 system events can be consumed

"
1,AWTEvent,5,boolean isConsumed(),True,Returns whether this event has been consumed.,"

isConsumed
protected boolean isConsumed()
Returns whether this event has been consumed.

"
2,AWTEventMulticaster,1,void addListener(AWTEventListener listener),False,,NULL
2,AWTEventMulticaster,2,void removeListener(AWTEventListener listener),False,,NULL
2,AWTEventMulticaster,3,void dispatchEvent(AWTEvent event),False,,NULL
2,AWTEventMulticaster,4,"void dispatchEvent(AWTEvent event, Object arg)",False,,NULL
2,AWTEventMulticaster,5,"void dispatchEvent(AWTEvent event, AWTEventMulticaster source)",False,,NULL
3,AWTKeyStroke,1,"AWTKeyStroke.getAWTKeyStroke(int keyCode, int modifiers)",False,,NULL
3,AWTKeyStroke,2,AWTKeyStroke.getAWTKeyStroke(String keyStroke),False,,NULL
3,AWTKeyStroke,3,"AWTKeyStroke.getAWTKeyStroke(char keyChar, int modifiers)",False,,NULL
3,AWTKeyStroke,4,"AWTKeyStroke.getAWTKeyStroke(String keyStroke, int modifiers)",False,,NULL
3,AWTKeyStroke,5,AWTKeyStroke.getAWTKeyStroke(char keyChar),False,,NULL
4,AWTPermission,1,boolean implies(Permission p),False,,NULL
4,AWTPermission,2,boolean equals(Object obj),False,,NULL
4,AWTPermission,3,int hashCode(),False,,NULL
4,AWTPermission,4,String getActions(),False,,NULL
4,AWTPermission,5,String toString(),False,,NULL
5,BasicStroke,1,"BasicStroke(float width, int cap, int join)",False,,NULL
5,BasicStroke,2,"BasicStroke(float width, int cap, int join, float miterlimit, float[] dash, float dash_phase)",False,,NULL
5,BasicStroke,3,float getLineWidth(),True,Returns the line width.,"

getLineWidth
public float getLineWidth()
Returns the line width.  Line width is represented in user space,
 which is the default-coordinate space used by Java 2D.  See the
 Graphics2D class comments for more information on
 the user space coordinate system.

Returns:
the line width of this BasicStroke.
See Also:
Graphics2D


"
5,BasicStroke,4,int getEndCap(),True,Returns the end cap style.,"

getEndCap
public int getEndCap()
Returns the end cap style.

Returns:
the end cap style of this BasicStroke as one
 of the static int values that define possible end cap
 styles.


"
5,BasicStroke,5,int getLineJoin(),True,Returns the line join style.,"

getLineJoin
public int getLineJoin()
Returns the line join style.

Returns:
the line join style of the BasicStroke as one
 of the static int values that define possible line
 join styles.


"
5,BasicStroke,6,float getMiterLimit(),True,Returns the limit of miter joins.,"

getMiterLimit
public float getMiterLimit()
Returns the limit of miter joins.

Returns:
the limit of miter joins of the BasicStroke.


"
5,BasicStroke,7,float[] getDashArray(),True,Returns the array representing the lengths of the dash segments.,"

getDashArray
public float[] getDashArray()
Returns the array representing the lengths of the dash segments.
 Alternate entries in the array represent the user space lengths
 of the opaque and transparent segments of the dashes.
 As the pen moves along the outline of the Shape
 to be stroked, the user space
 distance that the pen travels is accumulated.  The distance
 value is used to index into the dash array.
 The pen is opaque when its current cumulative distance maps
 to an even element of the dash array and transparent otherwise.

Returns:
the dash array.


"
5,BasicStroke,8,float getDashPhase(),True,Returns the current dash phase.,"

getDashPhase
public float getDashPhase()
Returns the current dash phase.
 The dash phase is a distance specified in user coordinates that
 represents an offset into the dashing pattern. In other words, the dash
 phase defines the point in the dashing pattern that will correspond to
 the beginning of the stroke.

Returns:
the dash phase as a float value.


"
5,BasicStroke,9,boolean equals(Object obj),True,"Tests if a specified object is equal to this BasicStroke by first testing if it is a BasicStroke and then comparing its width, join, cap, miter limit, dash, and dash phase attributes with those of this BasicStroke.","

equals
public boolean equals(Object obj)
Tests if a specified object is equal to this BasicStroke
 by first testing if it is a BasicStroke and then comparing
 its width, join, cap, miter limit, dash, and dash phase attributes with
 those of this BasicStroke.

Overrides:
equals in class Object
Parameters:
obj - the specified object to compare to this
              BasicStroke
Returns:
true if the width, join, cap, miter limit, dash, and
            dash phase are the same for both objects;
            false otherwise.
See Also:
Object.hashCode(), 
HashMap


"
5,BasicStroke,10,int hashCode(),True,Returns the hashcode for this stroke.,"

hashCode
public int hashCode()
Returns the hashcode for this stroke.

Overrides:
hashCode in class Object
Returns:
a hash code for this stroke.
See Also:
Object.equals(java.lang.Object), 
System.identityHashCode(java.lang.Object)


"
6,BorderLayout,1,"void addLayoutComponent(String name, Component comp)",True,"Deprecated. replaced by addLayoutComponent(Component, Object).","

addLayoutComponent
@Deprecated
public void addLayoutComponent(String name,
                                           Component comp)
Deprecated. replaced by addLayoutComponent(Component, Object).
Description copied from interface: LayoutManager
If the layout manager uses a per-component string,
 adds the component comp to the layout,
 associating it
 with the string specified by name.

Specified by:
addLayoutComponent in interface LayoutManager
Parameters:
name - the string to be associated with the component
comp - the component to be added


"
6,BorderLayout,2,"Component add(String name, Component comp)",False,,NULL
6,BorderLayout,3,"void addLayoutComponent(Component comp, Object constraints)",True,"Adds the specified component to the layout, using the specified constraint object.","

addLayoutComponent
public void addLayoutComponent(Component comp,
                               Object constraints)
Adds the specified component to the layout, using the specified
 constraint object.  For border layouts, the constraint must be
 one of the following constants:  NORTH,
 SOUTH, EAST,
 WEST, or CENTER.
 
 Most applications do not call this method directly. This method
 is called when a component is added to a container using the
 Container.add method with the same argument types.

Specified by:
addLayoutComponent in interface LayoutManager2
Parameters:
comp - the component to be added.
constraints - an object that specifies how and where
                       the component is added to the layout.
Throws:
IllegalArgumentException - if the constraint object is not
                 a string, or if it not one of the five specified
              constants.
Since:
JDK1.1
See Also:
Container.add(java.awt.Component, java.lang.Object)


"
6,BorderLayout,4,"void addLayoutComponent(String name, Component comp, int width, int height)",False,,NULL
6,BorderLayout,5,"void addLayoutComponent(Component comp, Object constraints, int width, int height)",False,,NULL
7,BufferCapabilities,1,boolean isDoubleBuffered(),False,,NULL
7,BufferCapabilities,2,boolean isPageBuffered(),False,,NULL
7,BufferCapabilities,3,boolean isSwapGroupBuffered(),False,,NULL
7,BufferCapabilities,4,boolean isTiling(),False,,NULL
7,BufferCapabilities,5,boolean isVolatile(),False,,NULL
8,BufferCapabilities.FlipContents,1,boolean isDoubleBuffered(),False,,NULL
8,BufferCapabilities.FlipContents,2,boolean isPageFlipping(),False,,NULL
8,BufferCapabilities.FlipContents,3,boolean isSwapControl(),False,,NULL
8,BufferCapabilities.FlipContents,4,boolean isPageFlipping(),False,,NULL
8,BufferCapabilities.FlipContents,5,boolean isPageFlipping(),False,,NULL
9,Button,1,Button(String label),False,,NULL
9,Button,2,void setLabel(String label),True,Sets the button's label to be the specified string.,"

setLabel
public void setLabel(String label)
Sets the button's label to be the specified string.

Parameters:
label - the new label, or null
                if the button has no label.
See Also:
getLabel()


"
9,Button,3,String getLabel(),True,Gets the label of this button.,"

getLabel
public String getLabel()
Gets the label of this button.

Returns:
the button's label, or null
                if the button has no label.
See Also:
setLabel(java.lang.String)


"
9,Button,4,void setEnabled(boolean b),False,,NULL
9,Button,5,boolean isEnabled(),False,,NULL
10,Canvas,1,void update(Graphics g),True,Updates this canvas.,"

update
public void update(Graphics g)
Updates this canvas.
 
 This method is called in response to a call to repaint.
 The canvas is first cleared by filling it with the background
 color, and then completely redrawn by calling this canvas's
 paint method.
 Note: applications that override this method should either call
 super.update(g) or incorporate the functionality described
 above into their own code.

Overrides:
update in class Component
Parameters:
g - the specified Graphics context
See Also:
paint(Graphics), 
Component.update(Graphics)


"
10,Canvas,2,void paint(Graphics g),True,Paints this canvas.,"

paint
public void paint(Graphics g)
Paints this canvas.
 
 Most applications that subclass Canvas should
 override this method in order to perform some useful operation
 (typically, custom painting of the canvas).
 The default operation is simply to clear the canvas.
 Applications that override this method need not call
 super.paint(g).

Overrides:
paint in class Component
Parameters:
g - the specified Graphics context
See Also:
update(Graphics), 
Component.paint(Graphics)


"
10,Canvas,3,"void paint(Graphics g, ImageObserver io)",False,,NULL
10,Canvas,4,"void update(Graphics g, ImageObserver io)",False,,NULL
10,Canvas,5,void paintComponent(Graphics g),False,,NULL
11,CardLayout,1,"void addLayoutComponent(String name, Component comp)",True,"Deprecated. replaced by addLayoutComponent(Component, Object).","

addLayoutComponent
@Deprecated
public void addLayoutComponent(String name,
                                           Component comp)
Deprecated. replaced by
      addLayoutComponent(Component, Object).
Description copied from interface: LayoutManager
If the layout manager uses a per-component string,
 adds the component comp to the layout,
 associating it
 with the string specified by name.

Specified by:
addLayoutComponent in interface LayoutManager
Parameters:
name - the string to be associated with the component
comp - the component to be added


"
11,CardLayout,2,"void addLayoutComponent(Component comp, Object constraints)",True,Adds the specified component to this card layout's internal table of names.,"

addLayoutComponent
public void addLayoutComponent(Component comp,
                               Object constraints)
Adds the specified component to this card layout's internal
 table of names. The object specified by constraints
 must be a string. The card layout stores this string as a key-value
 pair that can be used for random access to a particular card.
 By calling the show method, an application can
 display the component with the specified name.

Specified by:
addLayoutComponent in interface LayoutManager2
Parameters:
comp - the component to be added.
constraints - a tag that identifies a particular
                                        card in the layout.
Throws:
IllegalArgumentException - if the constraint is not a string.
See Also:
show(java.awt.Container, java.lang.String)


"
11,CardLayout,3,void first(Container target),True,Flips to the first card of the container.,"

first
public void first(Container parent)
Flips to the first card of the container.

Parameters:
parent - the parent container in which to do the layout
See Also:
last(java.awt.Container)


"
11,CardLayout,4,void last(Container target),True,Flips to the last card of the container.,"

last
public void last(Container parent)
Flips to the last card of the container.

Parameters:
parent - the parent container in which to do the layout
See Also:
first(java.awt.Container)


"
11,CardLayout,5,void next(Container target),True,Flips to the next card of the specified container.,"

next
public void next(Container parent)
Flips to the next card of the specified container. If the
 currently visible card is the last one, this method flips to the
 first card in the layout.

Parameters:
parent - the parent container in which to do the layout
See Also:
previous(java.awt.Container)


"
11,CardLayout,6,void previous(Container target),True,Flips to the previous card of the specified container.,"

previous
public void previous(Container parent)
Flips to the previous card of the specified container. If the
 currently visible card is the first one, this method flips to the
 last card in the layout.

Parameters:
parent - the parent container in which to do the layout
See Also:
next(java.awt.Container)


"
11,CardLayout,7,void removeLayoutComponent(Component comp),True,Removes the specified component from the layout.,"

removeLayoutComponent
public void removeLayoutComponent(Component comp)
Removes the specified component from the layout.
 If the card was visible on top, the next card underneath it is shown.

Specified by:
removeLayoutComponent in interface LayoutManager
Parameters:
comp - the component to be removed.
See Also:
Container.remove(java.awt.Component), 
Container.removeAll()


"
11,CardLayout,8,"void show(Container parent, String name)",True,"Flips to the component that was added to this layout with the specified name, using addLayoutComponent.","

show
public void show(Container parent,
                 String name)
Flips to the component that was added to this layout with the
 specified name, using addLayoutComponent.
 If no such component exists, then nothing happens.

Parameters:
parent - the parent container in which to do the layout
name - the component name
See Also:
addLayoutComponent(java.awt.Component, java.lang.Object)


"
11,CardLayout,9,"void show(Container parent, Component comp)",False,,NULL
11,CardLayout,10,"void addLayoutComponent(String name, Component comp)",True,"Deprecated. replaced by addLayoutComponent(Component, Object).","

addLayoutComponent
@Deprecated
public void addLayoutComponent(String name,
                                           Component comp)
Deprecated. replaced by
      addLayoutComponent(Component, Object).
Description copied from interface: LayoutManager
If the layout manager uses a per-component string,
 adds the component comp to the layout,
 associating it
 with the string specified by name.

Specified by:
addLayoutComponent in interface LayoutManager
Parameters:
name - the string to be associated with the component
comp - the component to be added


"
12,Checkbox,1,Checkbox(String label),False,,NULL
12,Checkbox,2,"Checkbox(String label, boolean state)",False,,NULL
12,Checkbox,3,void setState(boolean b),True,Sets the state of this check box to the specified state.,"

setState
public void setState(boolean state)
Sets the state of this check box to the specified state.
 The boolean value true indicates the ""on"" state,
 and false indicates the ""off"" state.

 Note that this method should be primarily used to
 initialize the state of the checkbox.  Programmatically
 setting the state of the checkbox will not trigger
 an ItemEvent.  The only way to trigger an
 ItemEvent is by user interaction.

Parameters:
state - the boolean state of the check box
See Also:
getState()


"
12,Checkbox,4,boolean getState(),True,"Determines whether this check box is in the ""on"" or ""off"" state.","

getState
public boolean getState()
Determines whether this check box is in the ""on"" or ""off"" state.
 The boolean value true indicates the ""on"" state,
 and false indicates the ""off"" state.

Returns:
the state of this check box, as a boolean value
See Also:
setState(boolean)


"
12,Checkbox,5,void toggle(),False,,NULL
13,CheckboxGroup,1,boolean add(E e),False,,NULL
13,CheckboxGroup,2,boolean addAll(Collection<? extends E> c),False,,NULL
13,CheckboxGroup,3,void clear(),False,,NULL
13,CheckboxGroup,4,boolean contains(Object o),False,,NULL
13,CheckboxGroup,5,boolean containsAll(Collection<?> c),False,,NULL
13,CheckboxGroup,6,boolean equals(Object o),False,,NULL
13,CheckboxGroup,7,E get(int index),False,,NULL
13,CheckboxGroup,8,int indexOf(Object o),False,,NULL
13,CheckboxGroup,9,boolean isEmpty(),False,,NULL
13,CheckboxGroup,10,Iterator<E> iterator(),False,,NULL
13,CheckboxGroup,11,int lastIndexOf(Object o),False,,NULL
13,CheckboxGroup,12,ListIterator<E> listIterator(),False,,NULL
13,CheckboxGroup,13,ListIterator<E> listIterator(int index),False,,NULL
13,CheckboxGroup,14,boolean remove(Object o),False,,NULL
13,CheckboxGroup,15,E remove(int index),False,,NULL
13,CheckboxGroup,16,boolean removeAll(Collection<?> c),False,,NULL
13,CheckboxGroup,17,boolean retainAll(Collection<?> c),False,,NULL
13,CheckboxGroup,18,"E set(int index, E element)",False,,NULL
13,CheckboxGroup,19,int size(),False,,NULL
13,CheckboxGroup,20,"List<E> subList(int fromIndex, int toIndex)",False,,NULL
13,CheckboxGroup,21,Object[] toArray(),False,,NULL
13,CheckboxGroup,22,<T> T[] toArray(T[] a),False,,NULL
13,CheckboxGroup,23,String toString(),True,"Returns a string representation of this check box group, including the value of its current selection.","

toString
public String toString()
Returns a string representation of this check box group,
 including the value of its current selection.

Overrides:
toString in class Object
Returns:
a string representation of this check box group.


"
14,CheckboxMenuItem,1,CheckboxMenuItem(String label),False,,NULL
14,CheckboxMenuItem,2,void setState(boolean b),True,Sets this check box menu item to the specified state.,"

setState
public void setState(boolean b)
Sets this check box menu item to the specified state.
 The boolean value true indicates ""on"" while
 false indicates ""off.""

 Note that this method should be primarily used to
 initialize the state of the check box menu item.
 Programmatically setting the state of the check box
 menu item will not trigger
 an ItemEvent.  The only way to trigger an
 ItemEvent is by user interaction.

Parameters:
b - true if the check box
             menu item is on, otherwise false
See Also:
getState()


"
14,CheckboxMenuItem,3,boolean getState(),True,"Determines whether the state of this check box menu item is ""on"" or ""off.""","

getState
public boolean getState()
Determines whether the state of this check box menu item
 is ""on"" or ""off.""

Returns:
the state of this check box menu item, where
                     true indicates ""on"" and
                     false indicates ""off""
See Also:
setState(boolean)


"
14,CheckboxMenuItem,4,void setCheckbox(boolean b),False,,NULL
14,CheckboxMenuItem,5,boolean getCheckbox(),False,,NULL
15,Choice,1,boolean add(E e),False,,NULL
15,Choice,2,void addItem(String item),True,Obsolete as of Java 2 platform v1.1.,"

addItem
public void addItem(String item)
Obsolete as of Java 2 platform v1.1.  Please use the
 add method instead.
 
 Adds an item to this Choice menu.

Parameters:
item - the item to be added
Throws:
NullPointerException - if the item's value is equal to
          null


"
15,Choice,3,void addItemListener(ItemListener l),True,Adds the specified item listener to receive item events from this Choice menu.,"

addItemListener
public void addItemListener(ItemListener l)
Adds the specified item listener to receive item events from
 this Choice menu.  Item events are sent in response
 to user input, but not in response to calls to select.
 If l is null, no exception is thrown and no action
 is performed.
 Refer to AWT Threading Issues for details on AWT's threading model.

Specified by:
addItemListener in interface ItemSelectable
Parameters:
l - the item listener
Since:
JDK1.1
See Also:
removeItemListener(java.awt.event.ItemListener), 
getItemListeners(), 
select(int), 
ItemEvent, 
ItemListener


"
15,Choice,4,void removeItemListener(ItemListener l),True,Removes the specified item listener so that it no longer receives item events from this Choice menu.,"

removeItemListener
public void removeItemListener(ItemListener l)
Removes the specified item listener so that it no longer receives
 item events from this Choice menu.
 If l is null, no exception is thrown and no
 action is performed.
 Refer to AWT Threading Issues for details on AWT's threading model.

Specified by:
removeItemListener in interface ItemSelectable
Parameters:
l - the item listener
Since:
JDK1.1
See Also:
addItemListener(java.awt.event.ItemListener), 
getItemListeners(), 
ItemEvent, 
ItemListener


"
15,Choice,5,String getItem(int index),True,Gets the string at the specified index in this Choice menu.,"

getItem
public String getItem(int index)
Gets the string at the specified index in this
 Choice menu.

Parameters:
index - the index at which to begin
See Also:
getItemCount()


"
16,Color,1,Color(int rgb),False,,NULL
16,Color,2,"Color(int rgba, boolean hasalpha)",False,,NULL
16,Color,3,"Color(float r, float g, float b)",False,,NULL
16,Color,4,"Color(float r, float g, float b, float a)",False,,NULL
16,Color,5,Color(int argb),False,,NULL
16,Color,6,"Color(int argb, boolean hasalpha)",False,,NULL
16,Color,7,int getRGB(),True,Returns the RGB value representing the color in the default sRGB ColorModel.,"

getRGB
public int getRGB()
Returns the RGB value representing the color in the default sRGB
 ColorModel.
 (Bits 24-31 are alpha, 16-23 are red, 8-15 are green, 0-7 are
 blue).

Returns:
the RGB value of the color in the default sRGB
         ColorModel.
Since:
JDK1.0
See Also:
ColorModel.getRGBdefault(), 
getRed(), 
getGreen(), 
getBlue()


"
16,Color,8,int getRGB(ColorSpace cs),False,,NULL
16,Color,9,int getAlpha(),True,Returns the alpha component in the range 0-255.,"

getAlpha
public int getAlpha()
Returns the alpha component in the range 0-255.

Returns:
the alpha component.
See Also:
getRGB()


"
16,Color,10,int getBlue(),True,Returns the blue component in the range 0-255 in the default sRGB space.,"

getBlue
public int getBlue()
Returns the blue component in the range 0-255 in the default sRGB
 space.

Returns:
the blue component.
See Also:
getRGB()


"
16,Color,11,int getGreen(),True,Returns the green component in the range 0-255 in the default sRGB space.,"

getGreen
public int getGreen()
Returns the green component in the range 0-255 in the default sRGB
 space.

Returns:
the green component.
See Also:
getRGB()


"
16,Color,12,int getRed(),True,Returns the red component in the range 0-255 in the default sRGB space.,"

getRed
public int getRed()
Returns the red component in the range 0-255 in the default sRGB
 space.

Returns:
the red component.
See Also:
getRGB()


"
16,Color,13,Color brighter(),True,Creates a new Color that is a brighter version of this Color.,"

brighter
public Color brighter()
Creates a new Color that is a brighter version of this
 Color.
 
 This method applies an arbitrary scale factor to each of the three RGB
 components of this Color to create a brighter version
 of this Color.
 The alpha value is preserved.
 Although brighter and
 darker are inverse operations, the results of a
 series of invocations of these two methods might be inconsistent
 because of rounding errors.

Returns:
a new Color object that is
                 a brighter version of this Color
                 with the same alpha value.
Since:
JDK1.0
See Also:
darker()


"
16,Color,14,Color darker(),True,Creates a new Color that is a darker version of this Color.,"

darker
public Color darker()
Creates a new Color that is a darker version of this
 Color.
 
 This method applies an arbitrary scale factor to each of the three RGB
 components of this Color to create a darker version of
 this Color.
 The alpha value is preserved.
 Although brighter and
 darker are inverse operations, the results of a series
 of invocations of these two methods might be inconsistent because
 of rounding errors.

Returns:
a new Color object that is
                    a darker version of this Color
                    with the same alpha value.
Since:
JDK1.0
See Also:
brighter()


"
16,Color,15,Color brighter(float f),False,,NULL
16,Color,16,Color darker(float f),False,,NULL
16,Color,17,Color brighter(Color c),False,,NULL
16,Color,18,Color darker(Color c),False,,NULL
16,Color,19,"Color interpolate(Color c1, Color c2, float f)",False,,NULL
16,Color,20,"Color mix(Color c1, Color c2, float f)",False,,NULL
16,Color,21,Color brighter(float f),False,,NULL
16,Color,22,Color darker(float f),False,,NULL
16,Color,23,Color brighter(Color c),False,,NULL
16,Color,24,Color darker(Color c),False,,NULL
16,Color,25,"Color interpolate(Color c1, Color c2, float f)",False,,NULL
16,Color,26,"Color mix(Color c1, Color c2, float f)",False,,NULL
17,Component,1,void addNotify(),True,Makes this Component displayable by connecting it to a native screen resource.,"

addNotify
public void addNotify()
Makes this Component displayable by connecting it to a
 native screen resource.
 This method is called internally by the toolkit and should
 not be called directly by programs.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.

Since:
JDK1.0
See Also:
isDisplayable(), 
removeNotify(), 
invalidate()


"
17,Component,2,void removeNotify(),True,Makes this Component undisplayable by destroying it native screen resource.,"

removeNotify
public void removeNotify()
Makes this Component undisplayable by destroying it native
 screen resource.
 
 This method is called by the toolkit internally and should
 not be called directly by programs. Code overriding
 this method should call super.removeNotify as
 the first line of the overriding method.

Since:
JDK1.0
See Also:
isDisplayable(), 
addNotify()


"
17,Component,3,void paint(Graphics g),True,Paints this component.,"

paint
public void paint(Graphics g)
Paints this component.
 
 This method is called when the contents of the component should
 be painted; such as when the component is first being shown or
 is damaged and in need of repair.  The clip rectangle in the
 Graphics parameter is set to the area
 which needs to be painted.
 Subclasses of Component that override this
 method need not call super.paint(g).
 
 For performance reasons, Components with zero width
 or height aren't considered to need painting when they are first shown,
 and also aren't considered to need repair.
 
Note: For more information on the paint mechanisms utilitized
 by AWT and Swing, including information on how to write the most
 efficient painting code, see
 Painting in AWT and Swing.

Parameters:
g - the graphics context to use for painting
Since:
JDK1.0
See Also:
update(java.awt.Graphics)


"
17,Component,4,void update(Graphics g),True,Updates this component.,"

update
public void update(Graphics g)
Updates this component.
 
 If this component is not a lightweight component, the
 AWT calls the update method in response to
 a call to repaint.  You can assume that
 the background is not cleared.
 
 The update method of Component
 calls this component's paint method to redraw
 this component.  This method is commonly overridden by subclasses
 which need to do additional work in response to a call to
 repaint.
 Subclasses of Component that override this method should either
 call super.update(g), or call paint(g)
 directly from their update method.
 
 The origin of the graphics context, its
 (0, 0) coordinate point, is the
 top-left corner of this component. The clipping region of the
 graphics context is the bounding rectangle of this component.

 
Note: For more information on the paint mechanisms utilitized
 by AWT and Swing, including information on how to write the most
 efficient painting code, see
 Painting in AWT and Swing.

Parameters:
g - the specified context to use for updating
Since:
JDK1.0
See Also:
paint(java.awt.Graphics), 
repaint()


"
17,Component,5,void repaint(),True,Repaints this component.,"

repaint
public void repaint()
Repaints this component.
 
 If this component is a lightweight component, this method
 causes a call to this component's paint
 method as soon as possible.  Otherwise, this method causes
 a call to this component's update method as soon
 as possible.
 
Note: For more information on the paint mechanisms utilitized
 by AWT and Swing, including information on how to write the most
 efficient painting code, see
 Painting in AWT and Swing.

Since:
JDK1.0
See Also:
update(Graphics)


"
18,ComponentOrientation,1,getComponentOrientation(),False,,NULL
18,ComponentOrientation,2,getItemOrientation(),False,,NULL
18,ComponentOrientation,3,getMirrorOrientation(),False,,NULL
18,ComponentOrientation,4,getOrientation(),False,,NULL
18,ComponentOrientation,5,getOrientation(int orientation),False,,NULL
19,Container,1,Component add(Component comp),True,Appends the specified component to the end of this container.,"

add
public Component add(Component comp)
Appends the specified component to the end of this container.
 This is a convenience method for addImpl(java.awt.Component, java.lang.Object, int).
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy. If the container has already been
 displayed, the hierarchy must be validated thereafter in order to
 display the added component.

Parameters:
comp - the component to be added
Returns:
the component argument
Throws:
NullPointerException - if comp is null
See Also:
addImpl(java.awt.Component, java.lang.Object, int), 
invalidate(), 
validate(), 
JComponent.revalidate()


"
19,Container,2,"Component add(Component comp, Object constraints)",False,,NULL
19,Container,3,"Component add(String name, Component comp)",True,Adds the specified component to this container.,"

add
public Component add(String name,
                     Component comp)
Adds the specified component to this container.
 This is a convenience method for addImpl(java.awt.Component, java.lang.Object, int).
 
 This method is obsolete as of 1.1.  Please use the
 method add(Component, Object) instead.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy. If the container has already been
 displayed, the hierarchy must be validated thereafter in order to
 display the added component.

Throws:
NullPointerException - if comp is null
See Also:
add(Component, Object), 
invalidate()


"
19,Container,4,Component[] getComponents(),True,Gets all the components in this container.,"

getComponents
public Component[] getComponents()
Gets all the components in this container.
 
 Note: This method should be called under AWT tree lock.

Returns:
an array of all the components in this container.
See Also:
Component.getTreeLock()


"
19,Container,5,int getComponentCount(),True,Gets the number of components in this panel.,"

getComponentCount
public int getComponentCount()
Gets the number of components in this panel.
 
 Note: This method should be called under AWT tree lock.

Returns:
the number of components in this panel.
Since:
JDK1.1
See Also:
getComponent(int), 
Component.getTreeLock()


"
19,Container,6,Component getComponent(int index),True,Gets the nth component in this container.,"

getComponent
public Component getComponent(int n)
Gets the nth component in this container.
 
 Note: This method should be called under AWT tree lock.

Parameters:
n - the index of the component to get.
Returns:
the nth component in this container.
Throws:
ArrayIndexOutOfBoundsException - if the nth value does not exist.
See Also:
Component.getTreeLock()


"
19,Container,7,Component getComponent(String name),False,,NULL
19,Container,8,void remove(int index),True,"Removes the component, specified by index, from this container.","

remove
public void remove(int index)
Removes the component, specified by index,
 from this container.
 This method also notifies the layout manager to remove the
 component from this container's layout via the
 removeLayoutComponent method.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy. If the container has already been
 displayed, the hierarchy must be validated thereafter in order to
 reflect the changes.

Parameters:
index - the index of the component to be removed
Throws:
ArrayIndexOutOfBoundsException - if index is not in
         range [0, getComponentCount()-1]
Since:
JDK1.1
See Also:
add(java.awt.Component), 
invalidate(), 
validate(), 
getComponentCount()


"
19,Container,9,void remove(Component comp),True,Removes the specified component from this container.,"

remove
public void remove(Component comp)
Removes the specified component from this container.
 This method also notifies the layout manager to remove the
 component from this container's layout via the
 removeLayoutComponent method.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy. If the container has already been
 displayed, the hierarchy must be validated thereafter in order to
 reflect the changes.

Parameters:
comp - the component to be removed
Throws:
NullPointerException - if comp is null
See Also:
add(java.awt.Component), 
invalidate(), 
validate(), 
remove(int)


"
19,Container,10,void removeAll(),True,Removes all the components from this container.,"

removeAll
public void removeAll()
Removes all the components from this container.
 This method also notifies the layout manager to remove the
 components from this container's layout via the
 removeLayoutComponent method.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy. If the container has already been
 displayed, the hierarchy must be validated thereafter in order to
 reflect the changes.

See Also:
add(java.awt.Component), 
remove(int), 
invalidate()


"
19,Container,11,void setLayout(LayoutManager mgr),True,Sets the layout manager for this container.,"

setLayout
public void setLayout(LayoutManager mgr)
Sets the layout manager for this container.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.

Parameters:
mgr - the specified layout manager
See Also:
doLayout(), 
getLayout(), 
invalidate()


"
19,Container,12,void validate(),True,Validates this container and all of its subcomponents.,"

validate
public void validate()
Validates this container and all of its subcomponents.
 
 Validating a container means laying out its subcomponents.
 Layout-related changes, such as setting the bounds of a component, or
 adding a component to the container, invalidate the container
 automatically.  Note that the ancestors of the container may be
 invalidated also (see Component.invalidate() for details.)
 Therefore, to restore the validity of the hierarchy, the validate() method should be invoked on the top-most invalid
 container of the hierarchy.
 
 Validating the container may be a quite time-consuming operation. For
 performance reasons a developer may postpone the validation of the
 hierarchy till a set of layout-related operations completes, e.g. after
 adding all the children to the container.
 
 If this Container is not valid, this method invokes
 the validateTree method and marks this Container
 as valid. Otherwise, no action is performed.

Overrides:
validate in class Component
See Also:
add(java.awt.Component), 
invalidate(), 
isValidateRoot(), 
JComponent.revalidate(), 
validateTree()


"
19,Container,13,void addNotify(),True,Makes this Container displayable by connecting it to a native screen resource.,"

addNotify
public void addNotify()
Makes this Container displayable by connecting it to
 a native screen resource.  Making a container displayable will
 cause all of its children to be made displayable.
 This method is called internally by the toolkit and should
 not be called directly by programs.

Overrides:
addNotify in class Component
See Also:
Component.isDisplayable(), 
removeNotify()


"
19,Container,14,void removeNotify(),True,Makes this Container undisplayable by removing its connection to its native screen resource.,"

removeNotify
public void removeNotify()
Makes this Container undisplayable by removing its connection
 to its native screen resource.  Making a container undisplayable
 will cause all of its children to be made undisplayable.
 This method is called by the toolkit internally and should
 not be called directly by programs.

Overrides:
removeNotify in class Component
See Also:
Component.isDisplayable(), 
addNotify()


"
19,Container,15,void paint(Graphics g),True,Paints the container.,"

paint
public void paint(Graphics g)
Paints the container. This forwards the paint to any lightweight
 components that are children of this container. If this method is
 reimplemented, super.paint(g) should be called so that lightweight
 components are properly rendered. If a child component is entirely
 clipped by the current clipping setting in g, paint() will not be
 forwarded to that child.

Overrides:
paint in class Component
Parameters:
g - the specified Graphics window
See Also:
Component.update(Graphics)


"
19,Container,16,void update(Graphics g),True,Updates the container.,"

update
public void update(Graphics g)
Updates the container.  This forwards the update to any lightweight
 components that are children of this container.  If this method is
 reimplemented, super.update(g) should be called so that lightweight
 components are properly rendered.  If a child component is entirely
 clipped by the current clipping setting in g, update() will not be
 forwarded to that child.

Overrides:
update in class Component
Parameters:
g - the specified Graphics window
See Also:
Component.update(Graphics)


"
19,Container,17,void repaint(),False,,NULL
19,Container,18,void repaint(long tm),False,,NULL
19,Container,19,"void repaint(int x, int y, int width, int height)",False,,NULL
19,Container,20,void setCursor(Cursor cursor),False,,NULL
19,Container,21,void setBackground(Color bg),False,,NULL
19,Container,22,void setForeground(Color fg),False,,NULL
19,Container,23,void setFont(Font font),True,Sets the font of this container.,"

setFont
public void setFont(Font f)
Sets the font of this container.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.

Overrides:
setFont in class Component
Parameters:
f - The font to become this container's font.
Since:
JDK1.0
See Also:
Component.getFont(), 
invalidate()


"
19,Container,24,void setSize(Dimension d),False,,NULL
19,Container,25,"void setSize(int width, int height)",False,,NULL
19,Container,26,void setPreferredSize(Dimension preferredSize),False,,NULL
19,Container,27,void setPreferredSize(Dimension preferredSize),False,,NULL
19,Container,28,void setMinimumSize(Dimension minSize),False,,NULL
19,Container,29,void setMaximumSize(Dimension maxSize),False,,NULL
19,Container,30,void setLayout(LayoutManager mgr),True,Sets the layout manager for this container.,"

setLayout
public void setLayout(LayoutManager mgr)
Sets the layout manager for this container.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.

Parameters:
mgr - the specified layout manager
See Also:
doLayout(), 
getLayout(), 
invalidate()


"
19,Container,31,void setVisible(boolean b),False,,NULL
19,Container,32,void setEnabled(boolean b),False,,NULL
19,Container,33,void setFocusable(boolean b),False,,NULL
19,Container,34,void setFocusTraversalKeysEnabled(boolean b),False,,NULL
19,Container,35,void setComponentOrientation(ComponentOrientation cOrientation),False,,NULL
19,Container,36,void setDoubleBuffered(boolean b),False,,NULL
19,Container,37,void setOpaque(boolean b),False,,NULL
19,Container,38,void setBorder(Border b),False,,NULL
19,Container,39,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,40,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,41,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,42,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,43,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,44,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,45,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,46,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,47,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,48,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,49,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,50,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,51,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,52,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,53,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,54,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,55,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,56,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,57,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,58,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,59,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,60,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,61,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,62,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,63,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,64,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
19,Container,65,"void setComponentZOrder(Component child, int index)",True,Moves the specified component to the specified z-order index in the container.,"

setComponentZOrder
public void setComponentZOrder(Component comp,
                               int index)
Moves the specified component to the specified z-order index in
 the container. The z-order determines the order that components
 are painted; the component with the highest z-order paints first
 and the component with the lowest z-order paints last.
 Where components overlap, the component with the lower
 z-order paints over the component with the higher z-order.
 
 If the component is a child of some other container, it is
 removed from that container before being added to this container.
 The important difference between this method and
 java.awt.Container.add(Component, int) is that this method
 doesn't call removeNotify on the component while
 removing it from its previous container unless necessary and when
 allowed by the underlying native windowing system. This way, if the
 component has the keyboard focus, it maintains the focus when
 moved to the new position.
 
 This property is guaranteed to apply only to lightweight
 non-Container components.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
Note: Not all platforms support changing the z-order of
 heavyweight components from one container into another without
 the call to removeNotify. There is no way to detect
 whether a platform supports this, so developers shouldn't make
 any assumptions.

Parameters:
comp - the component to be moved
index - the position in the container's list to
            insert the component, where getComponentCount()
            appends to the end
Throws:
NullPointerException - if comp is
            null
IllegalArgumentException - if comp is one of the
            container's parents
IllegalArgumentException - if index is not in
            the range [0, getComponentCount()] for moving
            between containers, or not in the range
            [0, getComponentCount()-1] for moving inside
            a container
IllegalArgumentException - if adding a container to itself
IllegalArgumentException - if adding a Window
            to a container
Since:
1.5
See Also:
getComponentZOrder(java.awt.Component), 
invalidate()


"
20,ContainerOrderFocusTraversalPolicy,1,boolean isFocusTraversable(Component c),False,,NULL
20,ContainerOrderFocusTraversalPolicy,2,Component getDefaultComponent(Container aContainer),True,Returns the default Component to focus.,"

getDefaultComponent
public Component getDefaultComponent(Container aContainer)
Returns the default Component to focus. This Component will be the first
 to receive focus when traversing down into a new focus traversal cycle
 rooted at aContainer. The default implementation of this method
 returns the same Component as getFirstComponent.

Specified by:
getDefaultComponent in class FocusTraversalPolicy
Parameters:
aContainer - the focus cycle root or focus traversal policy provider whose default
        Component is to be returned
Returns:
the default Component in the traversal cycle of aContainer,
         or null if no suitable Component can be found
Throws:
IllegalArgumentException - if aContainer is null
See Also:
getFirstComponent(java.awt.Container)


"
20,ContainerOrderFocusTraversalPolicy,3,"Component getComponentAfter(Container aContainer, Component aComponent)",True,Returns the Component that should receive the focus after aComponent.,"

getComponentAfter
public Component getComponentAfter(Container aContainer,
                                   Component aComponent)
Returns the Component that should receive the focus after aComponent.
 aContainer must be a focus cycle root of aComponent or a focus traversal policy provider.
 
 By default, ContainerOrderFocusTraversalPolicy implicitly transfers
 focus down-cycle. That is, during normal forward focus traversal, the
 Component traversed after a focus cycle root will be the focus-cycle-
 root's default Component to focus. This behavior can be disabled using
 the setImplicitDownCycleTraversal method.
 
 If aContainer is focus
 traversal policy provider, the focus is always transferred down-cycle.

Specified by:
getComponentAfter in class FocusTraversalPolicy
Parameters:
aContainer - a focus cycle root of aComponent or a focus traversal policy provider
aComponent - a (possibly indirect) child of aContainer, or
        aContainer itself
Returns:
the Component that should receive the focus after aComponent, or
         null if no suitable Component can be found
Throws:
IllegalArgumentException - if aContainer is not a focus cycle
         root of aComponent or focus traversal policy provider, or if either aContainer or
         aComponent is null


"
20,ContainerOrderFocusTraversalPolicy,4,"Component getComponentBefore(Container aContainer, Component aComponent)",True,Returns the Component that should receive the focus before aComponent.,"

getComponentBefore
public Component getComponentBefore(Container aContainer,
                                    Component aComponent)
Returns the Component that should receive the focus before aComponent.
 aContainer must be a focus cycle root of aComponent or a focus traversal policy
 provider.

Specified by:
getComponentBefore in class FocusTraversalPolicy
Parameters:
aContainer - a focus cycle root of aComponent or focus traversal policy provider
aComponent - a (possibly indirect) child of aContainer, or
        aContainer itself
Returns:
the Component that should receive the focus before aComponent,
         or null if no suitable Component can be found
Throws:
IllegalArgumentException - if aContainer is not a focus cycle
         root of aComponent or focus traversal policy provider, or if either aContainer or
         aComponent is null


"
20,ContainerOrderFocusTraversalPolicy,5,Component getFirstComponent(Container aContainer),True,Returns the first Component in the traversal cycle.,"

getFirstComponent
public Component getFirstComponent(Container aContainer)
Returns the first Component in the traversal cycle. This method is used
 to determine the next Component to focus when traversal wraps in the
 forward direction.

Specified by:
getFirstComponent in class FocusTraversalPolicy
Parameters:
aContainer - the focus cycle root or focus traversal policy provider whose first
        Component is to be returned
Returns:
the first Component in the traversal cycle of aContainer,
         or null if no suitable Component can be found
Throws:
IllegalArgumentException - if aContainer is null


"
20,ContainerOrderFocusTraversalPolicy,6,Component getLastComponent(Container aContainer),True,Returns the last Component in the traversal cycle.,"

getLastComponent
public Component getLastComponent(Container aContainer)
Returns the last Component in the traversal cycle. This method is used
 to determine the next Component to focus when traversal wraps in the
 reverse direction.

Specified by:
getLastComponent in class FocusTraversalPolicy
Parameters:
aContainer - the focus cycle root or focus traversal policy provider whose last
        Component is to be returned
Returns:
the last Component in the traversal cycle of aContainer,
         or null if no suitable Component can be found
Throws:
IllegalArgumentException - if aContainer is null


"
20,ContainerOrderFocusTraversalPolicy,7,Component getDefaultComponent(Container aContainer),True,Returns the default Component to focus.,"

getDefaultComponent
public Component getDefaultComponent(Container aContainer)
Returns the default Component to focus. This Component will be the first
 to receive focus when traversing down into a new focus traversal cycle
 rooted at aContainer. The default implementation of this method
 returns the same Component as getFirstComponent.

Specified by:
getDefaultComponent in class FocusTraversalPolicy
Parameters:
aContainer - the focus cycle root or focus traversal policy provider whose default
        Component is to be returned
Returns:
the default Component in the traversal cycle of aContainer,
         or null if no suitable Component can be found
Throws:
IllegalArgumentException - if aContainer is null
See Also:
getFirstComponent(java.awt.Container)


"
20,ContainerOrderFocusTraversalPolicy,8,int getComponentCount(Container aContainer),False,,NULL
20,ContainerOrderFocusTraversalPolicy,9,"Component getComponent(Container aContainer, int index)",False,,NULL
20,ContainerOrderFocusTraversalPolicy,10,void addComponentListener(ComponentListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,11,void removeComponentListener(ComponentListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,12,void addFocusListener(FocusListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,13,void removeFocusListener(FocusListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,14,void addKeyListener(KeyListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,15,void removeKeyListener(KeyListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,16,void addMouseListener(MouseListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,17,void removeMouseListener(MouseListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,18,void addMouseMotionListener(MouseMotionListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,19,void removeMouseMotionListener(MouseMotionListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,20,void addMouseWheelListener(MouseWheelListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,21,void removeMouseWheelListener(MouseWheelListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,22,"void addAWTEventListener(AWTEventListener listener, AWTEvent.EventMask mask)",False,,NULL
20,ContainerOrderFocusTraversalPolicy,23,void removeAWTEventListener(AWTEventListener listener),False,,NULL
20,ContainerOrderFocusTraversalPolicy,24,void addHierarchyBoundsListener(HierarchyBoundsListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,25,void removeHierarchyBoundsListener(HierarchyBoundsListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,26,void addHierarchyChangeListener(HierarchyChangeListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,27,void removeHierarchyChangeListener(HierarchyChangeListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,28,void addHierarchyBoundsListener(HierarchyBoundsListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,29,void removeHierarchyBoundsListener(HierarchyBoundsListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,30,void addHierarchyChangeListener(HierarchyChangeListener l),False,,NULL
20,ContainerOrderFocusTraversalPolicy,31,void removeHierarchyChangeListener(HierarchyChangeListener l),False,,NULL
21,Cursor,1,Cursor(int type),False,,NULL
21,Cursor,2,"Cursor(Image image, int hotSpotX, int hotSpotY)",False,,NULL
21,Cursor,3,"Cursor(Image image, Point hotSpot)",False,,NULL
21,Cursor,4,"Cursor(Image image, int hotSpotX, int hotSpotY, int type)",False,,NULL
21,Cursor,5,"Cursor(Image image, Point hotSpot, int type)",False,,NULL
22,DefaultFocusTraversalPolicy,1,boolean getFirstComponent(Container aContainer),False,,NULL
22,DefaultFocusTraversalPolicy,2,boolean getLastComponent(Container aContainer),False,,NULL
22,DefaultFocusTraversalPolicy,3,Component getDefaultComponent(Container aContainer),False,,NULL
22,DefaultFocusTraversalPolicy,4,"Component getComponentAfter(Container aContainer, Component aComponent)",False,,NULL
22,DefaultFocusTraversalPolicy,5,"Component getComponentBefore(Container aContainer, Component aComponent)",False,,NULL
23,DefaultKeyboardFocusManager,1,void addKeyEventDispatcher(KeyEventDispatcher ked),False,,NULL
23,DefaultKeyboardFocusManager,2,void addKeyEventPostProcessor(KeyEventPostProcessor kp),False,,NULL
23,DefaultKeyboardFocusManager,3,void addWindowFocusListener(WindowFocusListener l),False,,NULL
23,DefaultKeyboardFocusManager,4,void dispatchEvent(KeyEvent e),False,,NULL
23,DefaultKeyboardFocusManager,5,void dispatchEvent(WindowEvent e),False,,NULL
23,DefaultKeyboardFocusManager,6,void removeKeyEventDispatcher(KeyEventDispatcher ked),False,,NULL
23,DefaultKeyboardFocusManager,7,void removeKeyEventPostProcessor(KeyEventPostProcessor kp),False,,NULL
23,DefaultKeyboardFocusManager,8,void removeWindowFocusListener(WindowFocusListener l),False,,NULL
23,DefaultKeyboardFocusManager,9,void setDefaultFocusOwner(Component focusOwner),False,,NULL
23,DefaultKeyboardFocusManager,10,void setFocusManagerDelegate(FocusManager delegate),False,,NULL
23,DefaultKeyboardFocusManager,11,"void setFocusTraversalKeys(int nextKey, int previousKey)",False,,NULL
23,DefaultKeyboardFocusManager,12,void setFocusTraversalPolicy(FocusTraversalPolicy policy),False,,NULL
23,DefaultKeyboardFocusManager,13,void setGlobalFocusCycleManager(FocusCycleManager manager),False,,NULL
23,DefaultKeyboardFocusManager,14,"void setWindowFocusTraversalKeys(int nextKey, int previousKey)",False,,NULL
23,DefaultKeyboardFocusManager,15,void setWindowFocusTraversalPolicy(FocusTraversalPolicy policy),False,,NULL
24,Desktop,1,boolean isSupported(URI uri),False,,NULL
24,Desktop,2,void browse(URI uri),True,Launches the default browser to display a URI.,"

browse
public void browse(URI uri)
            throws IOException
Launches the default browser to display a URI.
 If the default browser is not able to handle the specified
 URI, the application registered for handling
 URIs of the specified type is invoked. The application
 is determined from the protocol and path of the URI, as
 defined by the URI class.
 
 If the calling thread does not have the necessary permissions,
 and this is invoked from within an applet,
 AppletContext.showDocument() is used. Similarly, if the calling
 does not have the necessary permissions, and this is invoked from within
 a Java Web Started application, BasicService.showDocument()
 is used.

Parameters:
uri - the URI to be displayed in the user default browser
Throws:
NullPointerException - if uri is null
UnsupportedOperationException - if the current platform
 does not support the Desktop.Action.BROWSE action
IOException - if the user default browser is not found,
 or it fails to be launched, or the default handler application
 failed to be launched
SecurityException - if a security manager exists and it
 denies the
 AWTPermission(""showWindowWithoutWarningBanner"")
 permission, or the calling thread is not allowed to create a
 subprocess; and not invoked from within an applet or Java Web Started
 application
IllegalArgumentException - if the necessary permissions
 are not available and the URI can not be converted to a URL
See Also:
URI, 
AWTPermission, 
AppletContext


"
24,Desktop,3,void mail(URI mailto),True,"Launches the mail composing window of the user default mail client, filling the message fields specified by a mailto: URI.","

mail
public void mail(URI mailtoURI)
          throws IOException
Launches the mail composing window of the user default mail
 client, filling the message fields specified by a mailto: URI.

  A mailto: URI can specify message fields
 including ""to"", ""cc"", ""subject"",
 ""body"", etc.  See The mailto URL
 scheme (RFC 2368) for the mailto: URI specification
 details.

Parameters:
mailtoURI - the specified mailto: URI
Throws:
NullPointerException - if the specified URI is null
IllegalArgumentException - if the URI scheme is not
         ""mailto""
UnsupportedOperationException - if the current platform
 does not support the Desktop.Action.MAIL action
IOException - if the user default mail client is not
 found or fails to be launched
SecurityException - if a security manager exists and it
 denies the
 AWTPermission(""showWindowWithoutWarningBanner"")
 permission, or the calling thread is not allowed to create a
 subprocess
See Also:
URI, 
AWTPermission


"
24,Desktop,4,void edit(File file),True,Launches the associated editor application and opens a file for editing.,"

edit
public void edit(File file)
          throws IOException
Launches the associated editor application and opens a file for
 editing.

Parameters:
file - the file to be opened for editing
Throws:
NullPointerException - if the specified file is null
IllegalArgumentException - if the specified file doesn't
 exist
UnsupportedOperationException - if the current platform
 does not support the Desktop.Action.EDIT action
IOException - if the specified file has no associated
 editor, or the associated application fails to be launched
SecurityException - if a security manager exists and its
 SecurityManager.checkRead(java.lang.String)
 method denies read access to the file, or SecurityManager.checkWrite(java.lang.String) method
 denies write access to the file, or it denies the
 AWTPermission(""showWindowWithoutWarningBanner"")
 permission, or the calling thread is not allowed to create a
 subprocess
See Also:
AWTPermission


"
24,Desktop,5,void print(File file),True,"Prints a file with the native desktop printing facility, using the associated application's print command.","

print
public void print(File file)
           throws IOException
Prints a file with the native desktop printing facility, using
 the associated application's print command.

Parameters:
file - the file to be printed
Throws:
NullPointerException - if the specified file is null
IllegalArgumentException - if the specified file doesn't
 exist
UnsupportedOperationException - if the current platform
         does not support the Desktop.Action.PRINT action
IOException - if the specified file has no associated
 application that can be used to print it
SecurityException - if a security manager exists and its
 SecurityManager.checkRead(java.lang.String)
 method denies read access to the file, or its SecurityManager.checkPrintJobAccess() method denies
 the permission to print the file, or the calling thread is not
 allowed to create a subprocess


"
25,Dialog,1,"Dialog(Frame owner, String title, boolean modal)",False,,NULL
25,Dialog,2,"void setLocation(int x, int y)",False,,NULL
25,Dialog,3,"void setSize(int width, int height)",False,,NULL
25,Dialog,4,void setVisible(boolean b),True,Shows or hides this Dialog depending on the value of parameter b.,"

setVisible
public void setVisible(boolean b)
Shows or hides this Dialog depending on the value of parameter
 b.

Overrides:
setVisible in class Window
Parameters:
b - if true, makes the Dialog visible,
 otherwise hides the Dialog.
 If the dialog and/or its owner
 are not yet displayable, both are made displayable.  The
 dialog will be validated prior to being made visible.
 If false, hides the Dialog and then causes setVisible(true)
 to return if it is currently blocked.
 
Notes for modal dialogs.
 
setVisible(true):  If the dialog is not already
 visible, this call will not return until the dialog is
 hidden by calling setVisible(false) or
 dispose.
 setVisible(false):  Hides the dialog and then
 returns on setVisible(true) if it is currently blocked.
 It is OK to call this method from the event dispatching
 thread because the toolkit ensures that other events are
 not blocked while this method is blocked.
 
See Also:
Window.setVisible(boolean), 
Window.dispose(), 
Component.isDisplayable(), 
Component.validate(), 
isModal()


"
25,Dialog,5,void dispose(),False,,NULL
26,Dimension,1,Dimension(),False,,NULL
26,Dimension,2,"Dimension(int width, int height)",False,,NULL
26,Dimension,3,int getWidth(),False,,NULL
26,Dimension,4,int getHeight(),False,,NULL
26,Dimension,5,"void setSize(int width, int height)",True,Sets the size of this Dimension object to the specified width and height.,"

setSize
public void setSize(int width,
                    int height)
Sets the size of this Dimension object
 to the specified width and height.
 This method is included for completeness, to parallel the
 setSize method defined by Component.

Parameters:
width - the new width for this Dimension object
height - the new height for this Dimension object
Since:
1.1
See Also:
getSize(), 
Component.setSize(int, int)


"
27,DisplayMode,1,DisplayMode getDisplayMode(),False,,NULL
27,DisplayMode,2,int getHeight(),True,"Returns the height of the display, in pixels.","

getHeight
public int getHeight()
Returns the height of the display, in pixels.

Returns:
the height of the display, in pixels


"
27,DisplayMode,3,int getRefreshRate(),True,"Returns the refresh rate of the display, in hertz.","

getRefreshRate
public int getRefreshRate()
Returns the refresh rate of the display, in hertz.  This may be
 REFRESH_RATE_UNKNOWN if the information is not available.

Returns:
the refresh rate of the display, in hertz.
See Also:
REFRESH_RATE_UNKNOWN


"
27,DisplayMode,4,int getWidth(),True,"Returns the width of the display, in pixels.","

getWidth
public int getWidth()
Returns the width of the display, in pixels.

Returns:
the width of the display, in pixels


"
27,DisplayMode,5,int getBitDepth(),True,"Returns the bit depth of the display, in bits per pixel.","

getBitDepth
public int getBitDepth()
Returns the bit depth of the display, in bits per pixel.  This may be
 BIT_DEPTH_MULTI if multiple bit depths are supported in
 this display mode.

Returns:
the bit depth of the display, in bits per pixel.
See Also:
BIT_DEPTH_MULTI


"
28,Event,1,boolean add(E e),False,,NULL
28,Event,2,"void add(int index, E element)",False,,NULL
28,Event,3,boolean addAll(Collection<? extends E> c),False,,NULL
28,Event,4,"boolean addAll(int index, Collection<? extends E> c)",False,,NULL
28,Event,5,void clear(),False,,NULL
29,EventQueue,1,"void addAWTEventListener(AWTEventListener listener, AWTEvent.EventClass eventClass)",False,,NULL
29,EventQueue,2,void dispatchEvent(AWTEvent event),True,Dispatches an event.,"

dispatchEvent
protected void dispatchEvent(AWTEvent event)
Dispatches an event. The manner in which the event is
 dispatched depends upon the type of the event and the
 type of the event's source object:

 

Event Type
Source Type
Dispatched To


ActiveEvent
Any
event.dispatch()


Other
Component
source.dispatchEvent(AWTEvent)


Other
MenuComponent
source.dispatchEvent(AWTEvent)


Other
Other
No action (ignored)




Parameters:
event - an instance of java.awt.AWTEvent,
          or a subclass of it
Throws:
NullPointerException - if event is null
Since:
1.2


"
29,EventQueue,3,void dispatchEvent(EventObject event),False,,NULL
29,EventQueue,4,void dispatchEvent(Object event),False,,NULL
29,EventQueue,5,void invokeAndWait(Runnable runnable),True,Causes runnable to have its run method called in the dispatch thread of the system EventQueue.,"

invokeAndWait
public static void invokeAndWait(Runnable runnable)
                          throws InterruptedException,
                                 InvocationTargetException
Causes runnable to have its run
 method called in the dispatch thread of
 the system EventQueue.
 This will happen after all pending events are processed.
 The call blocks until this has happened.  This method
 will throw an Error if called from the
 event dispatcher thread.

Parameters:
runnable - the Runnable whose run
                  method should be executed
                  synchronously in the
                  event dispatch thread
                  of the system EventQueue
Throws:
InterruptedException - if any thread has
                  interrupted this thread
InvocationTargetException - if an throwable is thrown
                  when running runnable
Since:
1.2
See Also:
invokeLater(java.lang.Runnable), 
Toolkit.getSystemEventQueue(), 
isDispatchThread()


"
30,FileDialog,1,FileDialog(Frame owner),False,,NULL
30,FileDialog,2,void setDirectory(String directory),True,Sets the directory of this file dialog window to be the specified directory.,"

setDirectory
public void setDirectory(String dir)
Sets the directory of this file dialog window to be the
 specified directory. Specifying a null or an
 invalid directory implies an implementation-defined default.
 This default will not be realized, however, until the user
 has selected a file. Until this point, getDirectory()
 will return the value passed into this method.
 
 Specifying """" as the directory is exactly equivalent to
 specifying null as the directory.

Parameters:
dir - the specified directory
See Also:
getDirectory()


"
30,FileDialog,3,String getDirectory(),True,Gets the directory of this file dialog.,"

getDirectory
public String getDirectory()
Gets the directory of this file dialog.

Returns:
the (potentially null or invalid)
          directory of this FileDialog
See Also:
setDirectory(java.lang.String)


"
30,FileDialog,4,void setFile(String file),True,Sets the selected file for this file dialog window to be the specified file.,"

setFile
public void setFile(String file)
Sets the selected file for this file dialog window to be the
 specified file. This file becomes the default file if it is set
 before the file dialog window is first shown.
 
 When the dialog is shown, the specified file is selected. The kind of
 selection depends on the file existence, the dialog type, and the native
 platform. E.g., the file could be highlighted in the file list, or a
 file name editbox could be populated with the file name.
 
 This method accepts either a full file path, or a file name with an
 extension if used together with the setDirectory method.
 
 Specifying """" as the file is exactly equivalent to specifying
 null as the file.

Parameters:
file - the file being set
See Also:
getFile(), 
getFiles()


"
30,FileDialog,5,String getFile(),True,Gets the selected file of this file dialog.,"

getFile
public String getFile()
Gets the selected file of this file dialog.  If the user
 selected CANCEL, the returned file is null.

Returns:
the currently selected file of this file dialog window,
                or null if none is selected
See Also:
setFile(java.lang.String)


"
30,FileDialog,6,void setFilenameFilter(FilenameFilter filter),True,Sets the filename filter for this file dialog window to the specified filter.,"

setFilenameFilter
public void setFilenameFilter(FilenameFilter filter)
Sets the filename filter for this file dialog window to the
 specified filter.
 Filename filters do not function in Sun's reference
 implementation for Microsoft Windows.

Parameters:
filter - the specified filter
See Also:
FilenameFilter, 
getFilenameFilter()


"
30,FileDialog,7,void setVisible(boolean b),False,,NULL
30,FileDialog,8,void dispose(),False,,NULL
30,FileDialog,9,String[] getFileNames(),False,,NULL
30,FileDialog,10,String getPath(),False,,NULL
31,FlowLayout,1,FlowLayout(),False,,NULL
31,FlowLayout,2,"addLayoutComponent(String name, Component comp)",False,,NULL
31,FlowLayout,3,getAlignment(),False,,NULL
31,FlowLayout,4,getHgap(),False,,NULL
31,FlowLayout,5,getVgap(),False,,NULL
31,FlowLayout,6,setAlignment(int alignment),False,,NULL
31,FlowLayout,7,setHgap(int hgap),False,,NULL
31,FlowLayout,8,setVgap(int vgap),False,,NULL
31,FlowLayout,9,layoutContainer(Container target),False,,NULL
31,FlowLayout,10,"addLayoutComponent(Component comp, Object constraints)",False,,NULL
31,FlowLayout,11,removeLayoutComponent(Component comp),False,,NULL
31,FlowLayout,12,preferredLayoutSize(Container target),False,,NULL
31,FlowLayout,13,minimumLayoutSize(Container target),False,,NULL
31,FlowLayout,14,maximumLayoutSize(Container target),False,,NULL
31,FlowLayout,15,getLayoutAlignmentX(Container target),False,,NULL
31,FlowLayout,16,getLayoutAlignmentY(Container target),False,,NULL
31,FlowLayout,17,invalidateLayout(Container target),False,,NULL
31,FlowLayout,18,"addLayoutComponent(String name, Component comp, int index)",False,,NULL
31,FlowLayout,19,"addLayoutComponent(Component comp, Object constraints, int index)",False,,NULL
31,FlowLayout,20,"addLayoutComponent(String name, Component comp, Object constraints)",False,,NULL
31,FlowLayout,21,"addLayoutComponent(String name, Component comp, Object constraints, int index)",False,,NULL
32,FocusTraversalPolicy,1,"abstract boolean getCycleRoot(Container focusCycleRoot, JComponent aComponent)",False,,NULL
32,FocusTraversalPolicy,2,abstract Component getDefaultComponent(Container focusCycleRoot),False,,NULL
32,FocusTraversalPolicy,3,"abstract Component getComponentAfter(Container focusCycleRoot, Component aComponent)",False,,NULL
32,FocusTraversalPolicy,4,"abstract Component getComponentBefore(Container focusCycleRoot, Component aComponent)",False,,NULL
32,FocusTraversalPolicy,5,abstract Component getFirstComponent(Container focusCycleRoot),False,,NULL
32,FocusTraversalPolicy,6,abstract Component getLastComponent(Container focusCycleRoot),False,,NULL
32,FocusTraversalPolicy,7,abstract Component getDefaultComponent(Container focusCycleRoot),False,,NULL
32,FocusTraversalPolicy,8,abstract void install(Container focusCycleRoot),False,,NULL
32,FocusTraversalPolicy,9,abstract void uninstall(Container focusCycleRoot),False,,NULL
32,FocusTraversalPolicy,10,"abstract void focusCycleStarted(Container focusCycleRoot, FocusTraversalPolicy aPolicy)",False,,NULL
32,FocusTraversalPolicy,11,"abstract void focusCycleEnded(Container focusCycleRoot, FocusTraversalPolicy aPolicy)",False,,NULL
32,FocusTraversalPolicy,12,"abstract void focusCycleDirectionChanged(Container focusCycleRoot, FocusTraversalPolicy aPolicy, int direction)",False,,NULL
32,FocusTraversalPolicy,13,"abstract void focusCycleComponentChanged(Container focusCycleRoot, FocusTraversalPolicy aPolicy, Component aComponent)",False,,NULL
32,FocusTraversalPolicy,14,"abstract void focusCycleComponentChanged(Container focusCycleRoot, FocusTraversalPolicy aPolicy, Component aComponent, int direction)",False,,NULL
32,FocusTraversalPolicy,15,"abstract void focusCycleComponentChanged(Container focusCycleRoot, FocusTraversalPolicy aPolicy, Component aComponent, int direction, boolean aTemporary)",False,,NULL
33,Font,1,"Font(String name, int style, int size)",False,,NULL
33,Font,2,"Font(String name, int style, int size, int transform)",False,,NULL
33,Font,3,String getName(),True,Returns the logical name of this Font.,"

getName
public String getName()
Returns the logical name of this Font.
 Use getFamily to get the family name of the font.
 Use getFontName to get the font face name of the font.

Returns:
a String representing the logical name of
          this Font.
Since:
JDK1.0
See Also:
getFamily(), 
getFontName()


"
33,Font,4,int getStyle(),True,Returns the style of this Font.,"

getStyle
public int getStyle()
Returns the style of this Font.  The style can be
 PLAIN, BOLD, ITALIC, or BOLD+ITALIC.

Returns:
the style of this Font
Since:
JDK1.0
See Also:
isPlain(), 
isBold(), 
isItalic()


"
33,Font,5,int getSize(),True,"Returns the point size of this Font, rounded to an integer.","

getSize
public int getSize()
Returns the point size of this Font, rounded to
 an integer.
 Most users are familiar with the idea of using point size to
 specify the size of glyphs in a font. This point size defines a
 measurement between the baseline of one line to the baseline of the
 following line in a single spaced text document. The point size is
 based on typographic points, approximately 1/72 of an inch.
 
 The Java(tm)2D API adopts the convention that one point is
 equivalent to one unit in user coordinates.  When using a
 normalized transform for converting user space coordinates to
 device space coordinates 72 user
 space units equal 1 inch in device space.  In this case one point
 is 1/72 of an inch.

Returns:
the point size of this Font in 1/72 of an
          inch units.
Since:
JDK1.0
See Also:
getSize2D(), 
GraphicsConfiguration.getDefaultTransform(), 
GraphicsConfiguration.getNormalizingTransform()


"
33,Font,6,int getTransform(),False,,NULL
33,Font,7,Font deriveFont(int style),True,Creates a new Font object by replicating the current Font object and applying a new style to it.,"

deriveFont
public Font deriveFont(int style)
Creates a new Font object by replicating the current
 Font object and applying a new style to it.

Parameters:
style - the style for the new Font
Returns:
a new Font object.
Since:
1.2


"
33,Font,8,Font deriveFont(float size),True,Creates a new Font object by replicating the current Font object and applying a new size to it.,"

deriveFont
public Font deriveFont(float size)
Creates a new Font object by replicating the current
 Font object and applying a new size to it.

Parameters:
size - the size for the new Font.
Returns:
a new Font object.
Since:
1.2


"
33,Font,9,"Font deriveFont(int style, float size)",True,Creates a new Font object by replicating this Font object and applying a new style and size.,"

deriveFont
public Font deriveFont(int style,
                       float size)
Creates a new Font object by replicating this
 Font object and applying a new style and size.

Parameters:
style - the style for the new Font
size - the size for the new Font
Returns:
a new Font object.
Since:
1.2


"
33,Font,10,"Font deriveFont(int style, int size)",False,,NULL
33,Font,11,"Font deriveFont(int style, int size, int transform)",False,,NULL
33,Font,12,"Font deriveFont(float size, int transform)",False,,NULL
33,Font,13,"Font deriveFont(int style, float size, int transform)",False,,NULL
33,Font,14,"Font deriveFont(int style, int size, int transform)",False,,NULL
33,Font,15,"Font deriveFont(float size, int style, int transform)",False,,NULL
33,Font,16,"Font deriveFont(int style, float size, int transform)",False,,NULL
33,Font,17,"Font deriveFont(int style, int size, int transform, boolean isBold, boolean isItalic)",False,,NULL
33,Font,18,"Font deriveFont(float size, int style, int transform, boolean isBold, boolean isItalic)",False,,NULL
33,Font,19,"Font deriveFont(int style, float size, int transform, boolean isBold, boolean isItalic)",False,,NULL
33,Font,20,"Font deriveFont(float size, int style, int transform, boolean isBold, boolean isItalic)",False,,NULL
34,FontMetrics,1,int getAscent(),True,Determines the font ascent of the Font described by this FontMetrics object.,"

getAscent
public int getAscent()
Determines the font ascent of the Font
 described by this FontMetrics object. The font ascent
 is the distance from the font's baseline to the top of most
 alphanumeric characters. Some characters in the Font
 might extend above the font ascent line.

Returns:
the font ascent of the Font.
See Also:
getMaxAscent()


"
34,FontMetrics,2,int getDescent(),True,Determines the font descent of the Font described by this FontMetrics object.,"

getDescent
public int getDescent()
Determines the font descent of the Font
 described by this
 FontMetrics object. The font descent is the distance
 from the font's baseline to the bottom of most alphanumeric
 characters with descenders. Some characters in the
 Font might extend
 below the font descent line.

Returns:
the font descent of the Font.
See Also:
getMaxDescent()


"
34,FontMetrics,3,int getHeight(),True,Gets the standard height of a line of text in this font.,"

getHeight
public int getHeight()
Gets the standard height of a line of text in this font.  This
 is the distance between the baseline of adjacent lines of text.
 It is the sum of the leading + ascent + descent. Due to rounding
 this may not be the same as getAscent() + getDescent() + getLeading().
 There is no guarantee that lines of text spaced at this distance are
 disjoint; such lines may overlap if some characters overshoot
 either the standard ascent or the standard descent metric.

Returns:
the standard height of the font.
See Also:
getLeading(), 
getAscent(), 
getDescent()


"
34,FontMetrics,4,int stringWidth(String s),True,Returns the total advance width for showing the specified String in this Font.,"

stringWidth
public int stringWidth(String str)
Returns the total advance width for showing the specified
 String in this Font.  The advance
 is the distance from the leftmost point to the rightmost point
 on the string's baseline.
 
 Note that the advance of a String is
 not necessarily the sum of the advances of its characters.

Parameters:
str - the String to be measured
Returns:
the advance width of the specified String
                  in the Font described by this
                  FontMetrics.
Throws:
NullPointerException - if str is null.
See Also:
bytesWidth(byte[], int, int), 
charsWidth(char[], int, int), 
getStringBounds(String, Graphics)


"
34,FontMetrics,5,int charWidth(char c),True,Returns the advance width of the specified character in this Font.,"

charWidth
public int charWidth(char ch)
Returns the advance width of the specified character in this
 Font.  The advance is the
 distance from the leftmost point to the rightmost point on the
 character's baseline.  Note that the advance of a
 String is not necessarily the sum of the advances
 of its characters.

 Note: This method cannot handle  supplementary
 characters. To support all Unicode characters, including
 supplementary characters, use the charWidth(int) method.

Parameters:
ch - the character to be measured
Returns:
the advance width of the specified character
                  in the Font described by this
                  FontMetrics object.
See Also:
charsWidth(char[], int, int), 
stringWidth(String)


"
35,Frame,1,Frame(),False,,NULL
35,Frame,2,"void setSize(int width, int height)",False,,NULL
35,Frame,3,void setVisible(boolean b),False,,NULL
35,Frame,4,void add(Component comp),False,,NULL
35,Frame,5,void setLayout(LayoutManager mgr),False,,NULL
36,GradientPaint,1,"GradientPaint(float x1, float y1, Color color1, float x2, float y2, Color color2)",False,,NULL
36,GradientPaint,2,"GradientPaint(float x1, float y1, Color color1, float x2, float y2, Color color2, boolean cycle)",False,,NULL
36,GradientPaint,3,Color getColor1(),True,Returns the color C1 anchored by the point P1.,"

getColor1
public Color getColor1()
Returns the color C1 anchored by the point P1.

Returns:
a Color object that is the color
 anchored by P1.


"
36,GradientPaint,4,Color getColor2(),True,Returns the color C2 anchored by the point P2.,"

getColor2
public Color getColor2()
Returns the color C2 anchored by the point P2.

Returns:
a Color object that is the color
 anchored by P2.


"
36,GradientPaint,5,float getPoint1(),False,,NULL
36,GradientPaint,6,float getPoint2(),False,,NULL
36,GradientPaint,7,float getPoint3(),False,,NULL
36,GradientPaint,8,float getPoint4(),False,,NULL
36,GradientPaint,9,boolean isCycle(),False,,NULL
37,Graphics,1,"void drawArc(int x, int y, int width, int height, int startAngle, int arcAngle)",True,Draws the outline of a circular or elliptical arc covering the specified rectangle.,"

drawArc
public abstract void drawArc(int x,
                             int y,
                             int width,
                             int height,
                             int startAngle,
                             int arcAngle)
Draws the outline of a circular or elliptical arc
 covering the specified rectangle.
 
 The resulting arc begins at startAngle and extends
 for arcAngle degrees, using the current color.
 Angles are interpreted such that 0 degrees
 is at the 3 o'clock position.
 A positive value indicates a counter-clockwise rotation
 while a negative value indicates a clockwise rotation.
 
 The center of the arc is the center of the rectangle whose origin
 is (x, y) and whose size is specified by the
 width and height arguments.
 
 The resulting arc covers an area
 width + 1 pixels wide
 by height + 1 pixels tall.
 
 The angles are specified relative to the non-square extents of
 the bounding rectangle such that 45 degrees always falls on the
 line from the center of the ellipse to the upper right corner of
 the bounding rectangle. As a result, if the bounding rectangle is
 noticeably longer in one axis than the other, the angles to the
 start and end of the arc segment will be skewed farther along the
 longer axis of the bounds.

Parameters:
x - the x coordinate of the
                    upper-left corner of the arc to be drawn.
y - the y  coordinate of the
                    upper-left corner of the arc to be drawn.
width - the width of the arc to be drawn.
height - the height of the arc to be drawn.
startAngle - the beginning angle.
arcAngle - the angular extent of the arc,
                    relative to the start angle.
See Also:
fillArc(int, int, int, int, int, int)


"
37,Graphics,2,"void drawImage(Image img, int x, int y, ImageObserver observer)",False,,NULL
37,Graphics,3,"void drawLine(int x1, int y1, int x2, int y2)",True,"Draws a line, using the current color, between the points (x1, y1) and (x2, y2) in this graphics context's coordinate system.","

drawLine
public abstract void drawLine(int x1,
                              int y1,
                              int x2,
                              int y2)
Draws a line, using the current color, between the points
 (x1, y1) and (x2, y2)
 in this graphics context's coordinate system.

Parameters:
x1 - the first point's x coordinate.
y1 - the first point's y coordinate.
x2 - the second point's x coordinate.
y2 - the second point's y coordinate.


"
37,Graphics,4,"void drawOval(int x, int y, int width, int height)",True,Draws the outline of an oval.,"

drawOval
public abstract void drawOval(int x,
                              int y,
                              int width,
                              int height)
Draws the outline of an oval.
 The result is a circle or ellipse that fits within the
 rectangle specified by the x, y,
 width, and height arguments.
 
 The oval covers an area that is
 width + 1 pixels wide
 and height + 1 pixels tall.

Parameters:
x - the x coordinate of the upper left
                     corner of the oval to be drawn.
y - the y coordinate of the upper left
                     corner of the oval to be drawn.
width - the width of the oval to be drawn.
height - the height of the oval to be drawn.
See Also:
fillOval(int, int, int, int)


"
37,Graphics,5,"void drawPolygon(int[] xPoints, int[] yPoints, int nPoints)",True,Draws a closed polygon defined by arrays of x and y coordinates.,"

drawPolygon
public abstract void drawPolygon(int[] xPoints,
                                 int[] yPoints,
                                 int nPoints)
Draws a closed polygon defined by
 arrays of x and y coordinates.
 Each pair of (x, y) coordinates defines a point.
 
 This method draws the polygon defined by nPoint line
 segments, where the first nPoint - 1
 line segments are line segments from
 (xPoints[i - 1], yPoints[i - 1])
 to (xPoints[i], yPoints[i]), for
 1  i  nPoints.
 The figure is automatically closed by drawing a line connecting
 the final point to the first point, if those points are different.

Parameters:
xPoints - a an array of x coordinates.
yPoints - a an array of y coordinates.
nPoints - a the total number of points.
See Also:
fillPolygon(int[], int[], int), 
drawPolyline(int[], int[], int)


"
38,Graphics2D,1,"void clipRect(int x, int y, int width, int height)",False,,NULL
38,Graphics2D,2,"void drawLine(int x1, int y1, int x2, int y2)",False,,NULL
38,Graphics2D,3,"void drawRect(int x, int y, int width, int height)",False,,NULL
38,Graphics2D,4,"void drawOval(int x, int y, int width, int height)",False,,NULL
38,Graphics2D,5,"void drawString(String str, int x, int y)",True,"Renders the text of the specified String, using the current text attribute state in the Graphics2D context.","

drawString
public abstract void drawString(String str,
                                int x,
                                int y)
Renders the text of the specified String, using the
 current text attribute state in the Graphics2D context.
 The baseline of the
 first character is at position (x, y) in
 the User Space.
 The rendering attributes applied include the Clip,
 Transform, Paint, Font and
 Composite attributes.  For characters in script
 systems such as Hebrew and Arabic, the glyphs can be rendered from
 right to left, in which case the coordinate supplied is the
 location of the leftmost character on the baseline.

Specified by:
drawString in class Graphics
Parameters:
str - the string to be rendered
x - the x coordinate of the location where the
 String should be rendered
y - the y coordinate of the location where the
 String should be rendered
Throws:
NullPointerException - if str is
         null
Since:
JDK1.0
See Also:
Graphics.drawBytes(byte[], int, int, int, int), 
Graphics.drawChars(char[], int, int, int, int)


"
39,GraphicsConfigTemplate,1,GraphicsConfigTemplate getInstance(),False,,NULL
39,GraphicsConfigTemplate,2,GraphicsConfiguration getGraphicsConfiguration(),False,,NULL
39,GraphicsConfigTemplate,3,GraphicsConfiguration getGraphicsConfiguration(int screen),False,,NULL
39,GraphicsConfigTemplate,4,GraphicsConfiguration getBestConfiguration(int screen),False,,NULL
39,GraphicsConfigTemplate,5,"GraphicsConfiguration getBestConfiguration(int screen, int width, int height)",False,,NULL
40,GraphicsConfiguration,1,GraphicsConfiguration getDeviceConfiguration(),False,,NULL
40,GraphicsConfiguration,2,Rectangle getBounds(),True,Returns the bounds of the GraphicsConfiguration in the device coordinates.,"

getBounds
public abstract Rectangle getBounds()
Returns the bounds of the GraphicsConfiguration
 in the device coordinates. In a multi-screen environment
 with a virtual device, the bounds can have negative X
 or Y origins.

Returns:
the bounds of the area covered by this
 GraphicsConfiguration.
Since:
1.3


"
40,GraphicsConfiguration,3,GraphicsDevice getDevice(),True,Returns the GraphicsDevice associated with this GraphicsConfiguration.,"

getDevice
public abstract GraphicsDevice getDevice()
Returns the GraphicsDevice associated with this
 GraphicsConfiguration.

Returns:
a GraphicsDevice object that is
 associated with this GraphicsConfiguration.


"
40,GraphicsConfiguration,4,boolean isFullScreen(),False,,NULL
40,GraphicsConfiguration,5,boolean isBitBltCapable(),False,,NULL
41,GraphicsDevice,1,GraphicsDevice getDefaultConfiguration(),False,,NULL
41,GraphicsDevice,2,GraphicsConfiguration[] getConfigurations(),True,Returns all of the GraphicsConfiguration objects associated with this GraphicsDevice.,"

getConfigurations
public abstract GraphicsConfiguration[] getConfigurations()
Returns all of the GraphicsConfiguration
 objects associated with this GraphicsDevice.

Returns:
an array of GraphicsConfiguration
 objects that are associated with this
 GraphicsDevice.


"
41,GraphicsDevice,3,"GraphicsConfiguration getBestConfiguration(Rectangle targetBounds, GraphicsConfiguration[] configurations)",False,,NULL
41,GraphicsDevice,4,"GraphicsConfiguration getBestConfiguration(Rectangle targetBounds, GraphicsConfiguration[] configurations, int typeHint)",False,,NULL
41,GraphicsDevice,5,GraphicsConfiguration getDefaultConfiguration(Rectangle targetBounds),False,,NULL
42,GraphicsEnvironment,1,GraphicsEnvironment getLocalGraphicsEnvironment(),True,Returns the local GraphicsEnvironment.,"

getLocalGraphicsEnvironment
public static GraphicsEnvironment getLocalGraphicsEnvironment()
Returns the local GraphicsEnvironment.

Returns:
the local GraphicsEnvironment


"
42,GraphicsEnvironment,2,GraphicsDevice[] getScreenDevices(),True,Returns an array of all of the screen GraphicsDevice objects.,"

getScreenDevices
public abstract GraphicsDevice[] getScreenDevices()
                                           throws HeadlessException
Returns an array of all of the screen GraphicsDevice
 objects.

Returns:
an array containing all the GraphicsDevice
 objects that represent screen devices
Throws:
HeadlessException - if isHeadless() returns true
See Also:
isHeadless()


"
42,GraphicsEnvironment,3,GraphicsDevice getDefaultScreenDevice(),True,Returns the default screen GraphicsDevice.,"

getDefaultScreenDevice
public abstract GraphicsDevice getDefaultScreenDevice()
                                               throws HeadlessException
Returns the default screen GraphicsDevice.

Returns:
the GraphicsDevice that represents the
 default screen device
Throws:
HeadlessException - if isHeadless() returns true
See Also:
isHeadless()


"
42,GraphicsEnvironment,4,Font[] getAllFonts(),True,Returns an array containing a one-point size instance of all fonts available in this GraphicsEnvironment.,"

getAllFonts
public abstract Font[] getAllFonts()
Returns an array containing a one-point size instance of all fonts
 available in this GraphicsEnvironment.  Typical usage
 would be to allow a user to select a particular font.  Then, the
 application can size the font and set various font attributes by
 calling the deriveFont method on the chosen instance.
 
 This method provides for the application the most precise control
 over which Font instance is used to render text.
 If a font in this GraphicsEnvironment has multiple
 programmable variations, only one
 instance of that Font is returned in the array, and
 other variations must be derived by the application.
 
 If a font in this environment has multiple programmable variations,
 such as Multiple-Master fonts, only one instance of that font is
 returned in the Font array.  The other variations
 must be derived by the application.

Returns:
an array of Font objects
Since:
1.2
See Also:
getAvailableFontFamilyNames(), 
Font, 
Font.deriveFont(int, float), 
Font.getFontName()


"
42,GraphicsEnvironment,5,Font getFont(String fontName),False,,NULL
43,GridBagConstraints,1,void gridwidth,False,,NULL
43,GridBagConstraints,2,void gridheight,False,,NULL
43,GridBagConstraints,3,void weightx,False,,NULL
43,GridBagConstraints,4,void weighty,False,,NULL
43,GridBagConstraints,5,void fill,False,,NULL
43,GridBagConstraints,6,void anchor,False,,NULL
43,GridBagConstraints,7,void insets,False,,NULL
43,GridBagConstraints,8,void ipadx,False,,NULL
43,GridBagConstraints,9,void ipady,False,,NULL
43,GridBagConstraints,10,void gridx,False,,NULL
43,GridBagConstraints,11,void gridy,False,,NULL
44,GridBagLayout,1,"void addLayoutComponent(Component comp, Object constraints)",True,"Adds the specified component to the layout, using the specified constraints object.","

addLayoutComponent
public void addLayoutComponent(Component comp,
                               Object constraints)
Adds the specified component to the layout, using the specified
 constraints object.  Note that constraints
 are mutable and are, therefore, cloned when cached.

Specified by:
addLayoutComponent in interface LayoutManager2
Parameters:
comp - the component to be added
constraints - an object that determines how
                          the component is added to the layout
Throws:
IllegalArgumentException - if constraints
            is not a GridBagConstraint


"
44,GridBagLayout,2,"void addLayoutComponent(String name, Component comp)",True,"Has no effect, since this layout manager does not use a per-component string.","

addLayoutComponent
public void addLayoutComponent(String name,
                               Component comp)
Has no effect, since this layout manager does not use a per-component string.

Specified by:
addLayoutComponent in interface LayoutManager
Parameters:
name - the string to be associated with the component
comp - the component to be added


"
44,GridBagLayout,3,"void addLayoutComponent(Component comp, Object constraints, int index)",False,,NULL
44,GridBagLayout,4,"void addLayoutComponent(String name, Component comp, int index)",False,,NULL
44,GridBagLayout,5,"void addLayoutComponent(String name, Component comp, int x, int y, int width, int height)",False,,NULL
44,GridBagLayout,6,"void addLayoutComponent(Component comp, Object constraints, int x, int y, int width, int height)",False,,NULL
44,GridBagLayout,7,"void addLayoutComponent(String name, Component comp, int x, int y, int width, int height, int maxWidth, int maxHeight)",False,,NULL
44,GridBagLayout,8,"void addLayoutComponent(Component comp, Object constraints, int x, int y, int width, int height, int maxWidth, int maxHeight)",False,,NULL
44,GridBagLayout,9,"void addLayoutComponent(String name, Component comp, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight)",False,,NULL
44,GridBagLayout,10,"void addLayoutComponent(Component comp, Object constraints, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight)",False,,NULL
44,GridBagLayout,11,"void addLayoutComponent(String name, Component comp, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY)",False,,NULL
44,GridBagLayout,12,"void addLayoutComponent(Component comp, Object constraints, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY)",False,,NULL
44,GridBagLayout,13,"void addLayoutComponent(String name, Component comp, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor)",False,,NULL
44,GridBagLayout,14,"void addLayoutComponent(Component comp, Object constraints, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor)",False,,NULL
44,GridBagLayout,15,"void addLayoutComponent(String name, Component comp, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor, int fill)",False,,NULL
44,GridBagLayout,16,"void addLayoutComponent(Component comp, Object constraints, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor, int fill)",False,,NULL
44,GridBagLayout,17,"void addLayoutComponent(String name, Component comp, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor, int fill, int layoutStyle)",False,,NULL
44,GridBagLayout,18,"void addLayoutComponent(Component comp, Object constraints, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor, int fill, int layoutStyle)",False,,NULL
44,GridBagLayout,19,"void addLayoutComponent(String name, Component comp, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor, int fill, int layoutStyle, int layoutStyleIndex)",False,,NULL
44,GridBagLayout,20,"void addLayoutComponent(Component comp, Object constraints, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor, int fill, int layoutStyle, int layoutStyleIndex)",False,,NULL
44,GridBagLayout,21,"void addLayoutComponent(String name, Component comp, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor, int fill, int layoutStyle, int layoutStyleIndex, int alignmentX, int alignmentY)",False,,NULL
44,GridBagLayout,22,"void addLayoutComponent(Component comp, Object constraints, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor, int fill, int layoutStyle, int layoutStyleIndex, int alignmentX, int alignmentY)",False,,NULL
44,GridBagLayout,23,"void addLayoutComponent(String name, Component comp, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor, int fill, int layoutStyle, int layoutStyleIndex, int alignmentX, int alignmentY, int baseline)",False,,NULL
44,GridBagLayout,24,"void addLayoutComponent(Component comp, Object constraints, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor, int fill, int layoutStyle, int layoutStyleIndex, int alignmentX, int alignmentY, int baseline)",False,,NULL
44,GridBagLayout,25,"void addLayoutComponent(String name, Component comp, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor, int fill, int layoutStyle, int layoutStyleIndex, int alignmentX, int alignmentY, int baseline, int visible)",False,,NULL
44,GridBagLayout,26,"void addLayoutComponent(Component comp, Object constraints, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor, int fill, int layoutStyle, int layoutStyleIndex, int alignmentX, int alignmentY, int baseline, int visible)",False,,NULL
44,GridBagLayout,27,"void addLayoutComponent(String name, Component comp, int x, int y, int width, int height, int maxWidth, int maxHeight, int minWidth, int minHeight, int weightX, int weightY, int anchor, int fill, int layoutStyle, int layoutStyleIndex, int alignmentX, int alignmentY, int baseline, int visible, int groupIndex)",False,,NULL
45,GridBagLayoutInfo,1,GridBagLayoutInfo(),False,,NULL
45,GridBagLayoutInfo,2,"void addLayoutComponent(String name, Component comp)",False,,NULL
45,GridBagLayoutInfo,3,"void addLayoutComponent(Component comp, Object constraints)",False,,NULL
45,GridBagLayoutInfo,4,"void addLayoutComponent(String name, Component comp, int width, int height)",False,,NULL
45,GridBagLayoutInfo,5,"void addLayoutComponent(Component comp, Object constraints, int width, int height)",False,,NULL
46,GridLayout,1,"GridLayout(int rows, int cols)",False,,NULL
46,GridLayout,2,"GridLayout(int rows, int cols, int hgap, int vgap)",False,,NULL
46,GridLayout,3,void setRows(int rows),True,Sets the number of rows in this layout to the specified value.,"

setRows
public void setRows(int rows)
Sets the number of rows in this layout to the specified value.

Parameters:
rows - the number of rows in this layout
Throws:
IllegalArgumentException - if the value of both
               rows and cols is set to zero
Since:
JDK1.1


"
46,GridLayout,4,void setColumns(int cols),True,Sets the number of columns in this layout to the specified value.,"

setColumns
public void setColumns(int cols)
Sets the number of columns in this layout to the specified value.
 Setting the number of columns has no affect on the layout
 if the number of rows specified by a constructor or by
 the setRows method is non-zero. In that case, the number
 of columns displayed in the layout is determined by the total
 number of components and the number of rows specified.

Parameters:
cols - the number of columns in this layout
Throws:
IllegalArgumentException - if the value of both
               rows and cols is set to zero
Since:
JDK1.1


"
46,GridLayout,5,void setHgap(int hgap),True,Sets the horizontal gap between components to the specified value.,"

setHgap
public void setHgap(int hgap)
Sets the horizontal gap between components to the specified value.

Parameters:
hgap - the horizontal gap between components
Since:
JDK1.1


"
46,GridLayout,6,void setVgap(int vgap),True,Sets the vertical gap between components to the specified value.,"

setVgap
public void setVgap(int vgap)
Sets the vertical gap between components to the specified value.

Parameters:
vgap - the vertical gap between components
Since:
JDK1.1


"
46,GridLayout,7,void setLayout(LayoutManager mgr),False,,NULL
46,GridLayout,8,"void addLayoutComponent(String name, Component comp)",True,Adds the specified component with the specified name to the layout.,"

addLayoutComponent
public void addLayoutComponent(String name,
                               Component comp)
Adds the specified component with the specified name to the layout.

Specified by:
addLayoutComponent in interface LayoutManager
Parameters:
name - the name of the component
comp - the component to be added


"
46,GridLayout,9,void removeLayoutComponent(Component comp),True,Removes the specified component from the layout.,"

removeLayoutComponent
public void removeLayoutComponent(Component comp)
Removes the specified component from the layout.

Specified by:
removeLayoutComponent in interface LayoutManager
Parameters:
comp - the component to be removed


"
46,GridLayout,10,Dimension preferredLayoutSize(Container parent),True,Determines the preferred size of the container argument using this grid layout.,"

preferredLayoutSize
public Dimension preferredLayoutSize(Container parent)
Determines the preferred size of the container argument using
 this grid layout.
 
 The preferred width of a grid layout is the largest preferred
 width of all of the components in the container times the number of
 columns, plus the horizontal padding times the number of columns
 minus one, plus the left and right insets of the target container.
 
 The preferred height of a grid layout is the largest preferred
 height of all of the components in the container times the number of
 rows, plus the vertical padding times the number of rows minus one,
 plus the top and bottom insets of the target container.

Specified by:
preferredLayoutSize in interface LayoutManager
Parameters:
parent - the container in which to do the layout
Returns:
the preferred dimensions to lay out the
                      subcomponents of the specified container
See Also:
minimumLayoutSize(java.awt.Container), 
Container.getPreferredSize()


"
46,GridLayout,11,Dimension minimumLayoutSize(Container parent),True,Determines the minimum size of the container argument using this grid layout.,"

minimumLayoutSize
public Dimension minimumLayoutSize(Container parent)
Determines the minimum size of the container argument using this
 grid layout.
 
 The minimum width of a grid layout is the largest minimum width
 of all of the components in the container times the number of columns,
 plus the horizontal padding times the number of columns minus one,
 plus the left and right insets of the target container.
 
 The minimum height of a grid layout is the largest minimum height
 of all of the components in the container times the number of rows,
 plus the vertical padding times the number of rows minus one, plus
 the top and bottom insets of the target container.

Specified by:
minimumLayoutSize in interface LayoutManager
Parameters:
parent - the container in which to do the layout
Returns:
the minimum dimensions needed to lay out the
                      subcomponents of the specified container
See Also:
preferredLayoutSize(java.awt.Container), 
Container.doLayout()


"
46,GridLayout,12,void layoutContainer(Container parent),True,Lays out the specified container using this layout.,"

layoutContainer
public void layoutContainer(Container parent)
Lays out the specified container using this layout.
 
 This method reshapes the components in the specified target
 container in order to satisfy the constraints of the
 GridLayout object.
 
 The grid layout manager determines the size of individual
 components by dividing the free space in the container into
 equal-sized portions according to the number of rows and columns
 in the layout. The container's free space equals the container's
 size minus any insets and any specified horizontal or vertical
 gap. All components in a grid layout are given the same size.

Specified by:
layoutContainer in interface LayoutManager
Parameters:
parent - the container in which to do the layout
See Also:
Container, 
Container.doLayout()


"
46,GridLayout,13,"void addLayoutComponent(Component comp, Object constraints)",False,,NULL
46,GridLayout,14,"void removeLayoutComponent(Component comp, Object constraints)",False,,NULL
46,GridLayout,15,"void addLayoutComponent(String name, Component comp, int index)",False,,NULL
46,GridLayout,16,"void removeLayoutComponent(Component comp, int index)",False,,NULL
46,GridLayout,17,"void addLayoutComponent(String name, Component comp, Object constraints)",False,,NULL
46,GridLayout,18,"void removeLayoutComponent(Component comp, Object constraints)",False,,NULL
46,GridLayout,19,"void addLayoutComponent(String name, Component comp, int index)",False,,NULL
46,GridLayout,20,"void removeLayoutComponent(Component comp, int index)",False,,NULL
47,Image,1,int getHeight(ImageObserver observer),True,Determines the height of the image.,"

getHeight
public abstract int getHeight(ImageObserver observer)
Determines the height of the image. If the height is not yet known,
 this method returns -1 and the specified
 ImageObserver object is notified later.

Parameters:
observer - an object waiting for the image to be loaded.
Returns:
the height of this image, or -1
                   if the height is not yet known.
See Also:
getWidth(java.awt.image.ImageObserver), 
ImageObserver


"
47,Image,2,int getWidth(ImageObserver observer),True,Determines the width of the image.,"

getWidth
public abstract int getWidth(ImageObserver observer)
Determines the width of the image. If the width is not yet known,
 this method returns -1 and the specified
 ImageObserver object is notified later.

Parameters:
observer - an object waiting for the image to be loaded.
Returns:
the width of this image, or -1
                   if the width is not yet known.
See Also:
getHeight(java.awt.image.ImageObserver), 
ImageObserver


"
47,Image,3,Object getProperty(String name),False,,NULL
47,Image,4,boolean getPropertyNames(String[] names),False,,NULL
47,Image,5,"boolean getPropertyUpdate(String name, ImageObserver observer)",False,,NULL
48,ImageCapabilities,1,boolean isAccelerated(),True,Returns true if the object whose capabilities are encapsulated in this ImageCapabilities can be or is accelerated.,"

isAccelerated
public boolean isAccelerated()
Returns true if the object whose capabilities are
 encapsulated in this ImageCapabilities can be or is
 accelerated.

Returns:
whether or not an image can be, or is, accelerated.  There are
 various platform-specific ways to accelerate an image, including
 pixmaps, VRAM, AGP.  This is the general acceleration method (as
 opposed to residing in system memory).


"
48,ImageCapabilities,2,boolean isAlphaPremultiplied(),False,,NULL
48,ImageCapabilities,3,boolean isAlphaOnly(),False,,NULL
48,ImageCapabilities,4,boolean isAnimated(),False,,NULL
48,ImageCapabilities,5,boolean isBaselineResolution(),False,,NULL
48,ImageCapabilities,6,boolean isBuffered(),False,,NULL
48,ImageCapabilities,7,boolean isEnhanced(),False,,NULL
48,ImageCapabilities,8,boolean isFloppy(),False,,NULL
48,ImageCapabilities,9,boolean isIndexColorModel(),False,,NULL
48,ImageCapabilities,10,boolean isMask(),False,,NULL
48,ImageCapabilities,11,boolean isReadOnly(),False,,NULL
48,ImageCapabilities,12,boolean isVolatile(),False,,NULL
48,ImageCapabilities,13,boolean isWritable(),False,,NULL
48,ImageCapabilities,14,boolean isWritableRaster(),False,,NULL
48,ImageCapabilities,15,boolean isWritableRenderingHints(),False,,NULL
48,ImageCapabilities,16,boolean isWritableTile(),False,,NULL
48,ImageCapabilities,17,boolean isWritableTileCache(),False,,NULL
48,ImageCapabilities,18,boolean isWritableVolatileImage(),False,,NULL
48,ImageCapabilities,19,boolean isWritableVolatileImage(boolean b),False,,NULL
48,ImageCapabilities,20,"boolean isWritableVolatileImage(boolean b, boolean c)",False,,NULL
49,Insets,1,int getTop(),False,,NULL
49,Insets,2,int getLeft(),False,,NULL
49,Insets,3,int getBottom(),False,,NULL
49,Insets,4,int getRight(),False,,NULL
49,Insets,5,"void set(int top, int left, int bottom, int right)",True,"Set top, left, bottom, and right to the specified values","

set
public void set(int top,
                int left,
                int bottom,
                int right)
Set top, left, bottom, and right to the specified values

Parameters:
top - the inset from the top.
left - the inset from the left.
bottom - the inset from the bottom.
right - the inset from the right.
Since:
1.5


"
50,JobAttributes,1,void setCopies(int copies),True,Specifies the number of copies the application should render for jobs using these attributes.,"

setCopies
public void setCopies(int copies)
Specifies the number of copies the application should render for jobs
 using these attributes. Not specifying this attribute is equivalent to
 specifying 1.

Parameters:
copies - an integer greater than 0
Throws:
IllegalArgumentException - if copies is less than
      or equal to 0


"
50,JobAttributes,2,int getCopies(),True,Returns the number of copies the application should render for jobs using these attributes.,"

getCopies
public int getCopies()
Returns the number of copies the application should render for jobs
 using these attributes. This attribute is updated to the value chosen
 by the user.

Returns:
an integer greater than 0.


"
50,JobAttributes,3,void setMediaPrintQuality(int mediaPrintQuality),False,,NULL
50,JobAttributes,4,int getMediaPrintQuality(),False,,NULL
50,JobAttributes,5,void setMediaPrintType(int mediaPrintType),False,,NULL
50,JobAttributes,6,int getMediaPrintType(),False,,NULL
50,JobAttributes,7,void setMediaSize(int mediaSize),False,,NULL
50,JobAttributes,8,int getMediaSize(),False,,NULL
50,JobAttributes,9,void setMediaType(int mediaType),False,,NULL
50,JobAttributes,10,int getMediaType(),False,,NULL
50,JobAttributes,11,void setOrientation(int orientation),False,,NULL
50,JobAttributes,12,int getOrientation(),False,,NULL
50,JobAttributes,13,void setPageRanges(int[] pageRanges),False,,NULL
50,JobAttributes,14,int[] getPageRanges(),False,,NULL
50,JobAttributes,15,void setPrinterName(String printerName),False,,NULL
50,JobAttributes,16,String getPrinterName(),False,,NULL
50,JobAttributes,17,void setResolution(int resolution),False,,NULL
50,JobAttributes,18,int getResolution(),False,,NULL
50,JobAttributes,19,void setSides(int sides),False,,NULL
50,JobAttributes,20,int getSides(),False,,NULL
51,JobAttributes.DefaultSelectionType,1,final DefaultSelectionType DEFAULT,False,,NULL
51,JobAttributes.DefaultSelectionType,2,final DefaultSelectionType SELECTED,False,,NULL
51,JobAttributes.DefaultSelectionType,3,final DefaultSelectionType UNSELECTED,False,,NULL
51,JobAttributes.DefaultSelectionType,4,final DefaultSelectionType UNSELECTABLE,False,,NULL
51,JobAttributes.DefaultSelectionType,5,final DefaultSelectionType UNSELECTED_UNSELECTABLE,False,,NULL
52,JobAttributes.DestinationType,1,DestinationType getDestinationType(String name),False,,NULL
52,JobAttributes.DestinationType,2,DestinationType[] getDestinationTypes(),False,,NULL
52,JobAttributes.DestinationType,3,DestinationType valueOf(String name),False,,NULL
52,JobAttributes.DestinationType,4,String getName(),False,,NULL
52,JobAttributes.DestinationType,5,String toString(),True,Returns a string representation of the object.,"

toString
public String toString()
Description copied from class: Object
Returns a string representation of the object. In general, the
 toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method.
 
 The toString method for class Object
 returns a string consisting of the name of the class of which the
 object is an instance, the at-sign character `@', and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words, this method returns a string equal to the
 value of:
 

 getClass().getName() + '@' + Integer.toHexString(hashCode())
 

Overrides:
toString in class Object
Returns:
a string representation of the object.


"
53,JobAttributes.DialogType,1,DialogType.getDialogType(String name),False,,NULL
53,JobAttributes.DialogType,2,DialogType.getDialogType(int ordinal),False,,NULL
53,JobAttributes.DialogType,3,DialogType.getName(),False,,NULL
53,JobAttributes.DialogType,4,DialogType.getOrdinal(),False,,NULL
53,JobAttributes.DialogType,5,DialogType.values(),False,,NULL
54,JobAttributes.MultipleDocumentHandlingType,1,MultipleDocumentHandlingType.COPY_ON_OPEN,False,,NULL
54,JobAttributes.MultipleDocumentHandlingType,2,MultipleDocumentHandlingType.COPY_ON_PRINT,False,,NULL
54,JobAttributes.MultipleDocumentHandlingType,3,MultipleDocumentHandlingType.COPY_ON_CLOSE,False,,NULL
54,JobAttributes.MultipleDocumentHandlingType,4,MultipleDocumentHandlingType.COPY_ON_PRINT_OR_CLOSE,False,,NULL
54,JobAttributes.MultipleDocumentHandlingType,5,MultipleDocumentHandlingType.COPY_ON_PRINT_OR_CLOSE_OR_OPEN,False,,NULL
54,JobAttributes.MultipleDocumentHandlingType,6,MultipleDocumentHandlingType.COPY_ON_PRINT_OR_CLOSE_OR_OPEN_OR_SAVE,False,,NULL
54,JobAttributes.MultipleDocumentHandlingType,7,MultipleDocumentHandlingType.COPY_ON_PRINT_OR_CLOSE_OR_OPEN_OR_SAVE_OR_CLOSE,False,,NULL
54,JobAttributes.MultipleDocumentHandlingType,8,MultipleDocumentHandlingType.COPY_ON_PRINT_OR_CLOSE_OR_OPEN_OR_SAVE_OR_CLOSE_OR_OPEN,False,,NULL
54,JobAttributes.MultipleDocumentHandlingType,9,MultipleDocumentHandlingType.COPY_ON_PRINT_OR_CLOSE_OR_OPEN_OR_SAVE_OR_CLOSE_OR_OPEN_OR_SAVE,False,,NULL
54,JobAttributes.MultipleDocumentHandlingType,10,MultipleDocumentHandlingType.COPY_ON_PRINT_OR_CLOSE_OR_OPEN_OR_SAVE_OR_CLOSE_OR_OPEN_OR_SAVE_OR_CLOSE,False,,NULL
55,JobAttributes.SidesType,1,SidesType getInstance(String name),False,,NULL
55,JobAttributes.SidesType,2,SidesType[] values(),False,,NULL
55,JobAttributes.SidesType,3,SidesType valueOf(String name),False,,NULL
55,JobAttributes.SidesType,4,String getName(),False,,NULL
55,JobAttributes.SidesType,5,String toString(),True,Returns a string representation of the object.,"

toString
public String toString()
Description copied from class: Object
Returns a string representation of the object. In general, the
 toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method.
 
 The toString method for class Object
 returns a string consisting of the name of the class of which the
 object is an instance, the at-sign character `@', and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words, this method returns a string equal to the
 value of:
 

 getClass().getName() + '@' + Integer.toHexString(hashCode())
 

Overrides:
toString in class Object
Returns:
a string representation of the object.


"
56,KeyboardFocusManager,1,void addKeyEventDispatcher(KeyEventDispatcher ked),True,Adds a KeyEventDispatcher to this KeyboardFocusManager's dispatcher chain.,"

addKeyEventDispatcher
public void addKeyEventDispatcher(KeyEventDispatcher dispatcher)
Adds a KeyEventDispatcher to this KeyboardFocusManager's dispatcher
 chain. This KeyboardFocusManager will request that each
 KeyEventDispatcher dispatch KeyEvents generated by the user before
 finally dispatching the KeyEvent itself. KeyEventDispatchers will be
 notified in the order in which they were added. Notifications will halt
 as soon as one KeyEventDispatcher returns true from its
 dispatchKeyEvent method. There is no limit to the total
 number of KeyEventDispatchers which can be added, nor to the number of
 times which a particular KeyEventDispatcher instance can be added.
 
 If a null dispatcher is specified, no action is taken and no exception
 is thrown.
 
 In a multithreaded application, KeyEventDispatcher behaves
 the same as other AWT listeners.  See
 AWT Threading Issues for more details.

Parameters:
dispatcher - the KeyEventDispatcher to add to the dispatcher chain
See Also:
removeKeyEventDispatcher(java.awt.KeyEventDispatcher)


"
56,KeyboardFocusManager,2,void addWindowFocusListener(WindowFocusListener l),False,,NULL
56,KeyboardFocusManager,3,void dispatchEvent(KeyEvent e),False,,NULL
56,KeyboardFocusManager,4,void dispatchEvent(WindowEvent e),False,,NULL
56,KeyboardFocusManager,5,KeyEventDispatcher[] getDispatchers(),False,,NULL
56,KeyboardFocusManager,6,WindowFocusListener[] getListeners(),False,,NULL
56,KeyboardFocusManager,7,void removeKeyEventDispatcher(KeyEventDispatcher ked),True,Removes a KeyEventDispatcher which was previously added to this KeyboardFocusManager's dispatcher chain.,"

removeKeyEventDispatcher
public void removeKeyEventDispatcher(KeyEventDispatcher dispatcher)
Removes a KeyEventDispatcher which was previously added to this
 KeyboardFocusManager's dispatcher chain. This KeyboardFocusManager
 cannot itself be removed, unless it was explicitly re-registered via a
 call to addKeyEventDispatcher.
 
 If a null dispatcher is specified, if the specified dispatcher is not
 in the dispatcher chain, or if this KeyboardFocusManager is specified
 without having been explicitly re-registered, no action is taken and no
 exception is thrown.
 
 In a multithreaded application, KeyEventDispatcher behaves
 the same as other AWT listeners.  See
 AWT Threading Issues for more details.

Parameters:
dispatcher - the KeyEventDispatcher to remove from the dispatcher
        chain
See Also:
addKeyEventDispatcher(java.awt.KeyEventDispatcher)


"
56,KeyboardFocusManager,8,void removeWindowFocusListener(WindowFocusListener l),False,,NULL
56,KeyboardFocusManager,9,void setCurrentKeyEventDispatcher(KeyEventDispatcher ked),False,,NULL
56,KeyboardFocusManager,10,"void setDefaultFocusTraversalKeys(int direction, int keyCode)",False,,NULL
56,KeyboardFocusManager,11,void setFocusManager(FocusManager fm),False,,NULL
56,KeyboardFocusManager,12,"void setFocusTraversalKeys(int direction, int keyCode)",False,,NULL
56,KeyboardFocusManager,13,"void setGlobalFocusTraversalKeys(int direction, int keyCode)",False,,NULL
56,KeyboardFocusManager,14,"void setWindowFocusTraversalKeys(int direction, int keyCode)",False,,NULL
56,KeyboardFocusManager,15,"void updateFocusTraversalKeys(int direction, int keyCode)",False,,NULL
56,KeyboardFocusManager,16,"void updateWindowFocusTraversalKeys(int direction, int keyCode)",False,,NULL
57,Label,1,void setAlignment(int alignment),True,Sets the alignment for this label to the specified alignment.,"

setAlignment
public void setAlignment(int alignment)
Sets the alignment for this label to the specified alignment.
 Possible values are Label.LEFT,
 Label.RIGHT, and Label.CENTER.

Parameters:
alignment - the alignment to be set.
Throws:
IllegalArgumentException - if an improper value for
                          alignment is given.
See Also:
getAlignment()


"
57,Label,2,void setText(String text),True,Sets the text for this label to the specified text.,"

setText
public void setText(String text)
Sets the text for this label to the specified text.

Parameters:
text - the text that this label displays. If
             text is null, it is
             treated for display purposes like an empty
             string """".
See Also:
getText()


"
57,Label,3,void setIcon(Icon icon),False,,NULL
57,Label,4,void setIconTextGap(int gap),False,,NULL
57,Label,5,void setLabelFor(Component labelFor),False,,NULL
58,LinearGradientPaint,1,"LinearGradientPaint(float x1, float y1, float x2, float y2, Color[] colors, float[] fractions)",False,,NULL
58,LinearGradientPaint,2,"LinearGradientPaint(float x1, float y1, float x2, float y2, Color color1, Color color2)",False,,NULL
58,LinearGradientPaint,3,Color[] getColors(),False,,NULL
58,LinearGradientPaint,4,float[] getFractions(),False,,NULL
58,LinearGradientPaint,5,float getStartPointX(),False,,NULL
58,LinearGradientPaint,6,float getStartPointY(),False,,NULL
58,LinearGradientPaint,7,float getEndPointX(),False,,NULL
58,LinearGradientPaint,8,float getEndPointY(),False,,NULL
58,LinearGradientPaint,9,"PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)",True,Creates and returns a PaintContext used to generate a linear color gradient pattern.,"

createContext
public PaintContext createContext(ColorModel cm,
                                  Rectangle deviceBounds,
                                  Rectangle2D userBounds,
                                  AffineTransform transform,
                                  RenderingHints hints)
Creates and returns a PaintContext used to
 generate a linear color gradient pattern.
 See the specification of the
 method in the Paint interface for information
 on null parameter handling.

Parameters:
cm - the preferred ColorModel which represents the most convenient
           format for the caller to receive the pixel data, or null
           if there is no preference.
deviceBounds - the device space bounding box
                     of the graphics primitive being rendered.
userBounds - the user space bounding box
                   of the graphics primitive being rendered.
transform - the AffineTransform from user
              space into device space.
hints - the set of hints that the context object can use to
              choose between rendering alternatives.
Returns:
the PaintContext for
         generating color patterns.
See Also:
Paint, 
PaintContext, 
ColorModel, 
Rectangle, 
Rectangle2D, 
AffineTransform, 
RenderingHints


"
58,LinearGradientPaint,10,"PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints, int rule)",False,,NULL
59,List,1,boolean add(E e),False,,NULL
59,List,2,"void add(int index, E element)",False,,NULL
59,List,3,boolean addAll(Collection<? extends E> c),False,,NULL
59,List,4,void clear(),True,"Deprecated. As of JDK version 1.1, replaced by removeAll().","

clear
@Deprecated
public void clear()
Deprecated. As of JDK version 1.1,
 replaced by removeAll().

"
59,List,5,boolean contains(Object o),False,,NULL
60,MediaTracker,1,boolean add(E e),False,,NULL
60,MediaTracker,2,"boolean add(int index, E element)",False,,NULL
60,MediaTracker,3,void clear(),False,,NULL
60,MediaTracker,4,boolean contains(Object o),False,,NULL
60,MediaTracker,5,E get(int index),False,,NULL
60,MediaTracker,6,int indexOf(Object o),False,,NULL
60,MediaTracker,7,boolean isAlive(),False,,NULL
60,MediaTracker,8,int waitForAll(),False,,NULL
60,MediaTracker,9,"int waitForID(int id, long timeout)",False,,NULL
60,MediaTracker,10,int waitForID(int id),False,,NULL
60,MediaTracker,11,int getStatus(int id),False,,NULL
60,MediaTracker,12,int getTotalSize(),False,,NULL
60,MediaTracker,13,int getNumberOfImagesLoaded(),False,,NULL
60,MediaTracker,14,int getNumberOfMediaFailed(),False,,NULL
60,MediaTracker,15,int getNumberOfMediaLoaded(),False,,NULL
60,MediaTracker,16,int getNumberOfMediaStarted(),False,,NULL
60,MediaTracker,17,int getNumberOfMediaComplete(),False,,NULL
60,MediaTracker,18,int getNumberOfMediaAborted(),False,,NULL
60,MediaTracker,19,int getNumberOfMediaErrors(),False,,NULL
60,MediaTracker,20,int getNumberOfMediaStarted(),False,,NULL
60,MediaTracker,21,int getNumberOfMediaComplete(),False,,NULL
60,MediaTracker,22,int getNumberOfMediaAborted(),False,,NULL
60,MediaTracker,23,int getNumberOfMediaErrors(),False,,NULL
60,MediaTracker,24,int getNumberOfMediaStarted(),False,,NULL
60,MediaTracker,25,int getNumberOfMediaComplete(),False,,NULL
60,MediaTracker,26,int getNumberOfMediaAborted(),False,,NULL
60,MediaTracker,27,int getNumberOfMediaErrors(),False,,NULL
60,MediaTracker,28,int getNumberOfMediaStarted(),False,,NULL
60,MediaTracker,29,int getNumberOfMediaComplete(),False,,NULL
60,MediaTracker,30,int getNumberOfMediaAborted(),False,,NULL
60,MediaTracker,31,int getNumberOfMediaErrors(),False,,NULL
60,MediaTracker,32,int getNumberOfMediaStarted(),False,,NULL
60,MediaTracker,33,int getNumberOfMediaComplete(),False,,NULL
60,MediaTracker,34,int getNumberOfMediaAborted(),False,,NULL
60,MediaTracker,35,int getNumberOfMediaErrors(),False,,NULL
61,Menu,1,MenuBar(),False,,NULL
61,Menu,2,add(Menu m),False,,NULL
61,Menu,3,remove(Menu m),False,,NULL
61,Menu,4,getMenuCount(),False,,NULL
61,Menu,5,getMenu(int index),False,,NULL
62,MenuBar,1,MenuBar(),False,,NULL
62,MenuBar,2,void add(Menu menu),False,,NULL
62,MenuBar,3,Menu getMenu(int index),True,Gets the specified menu.,"

getMenu
public Menu getMenu(int i)
Gets the specified menu.

Parameters:
i - the index position of the menu to be returned.
Returns:
the menu at the specified index of this menu bar.


"
62,MenuBar,4,int getMenuCount(),True,Gets the number of menus on the menu bar.,"

getMenuCount
public int getMenuCount()
Gets the number of menus on the menu bar.

Returns:
the number of menus on the menu bar.
Since:
JDK1.1


"
62,MenuBar,5,void remove(int index),True,Removes the menu located at the specified index from this menu bar.,"

remove
public void remove(int index)
Removes the menu located at the specified
 index from this menu bar.

Parameters:
index - the position of the menu to be removed.
See Also:
add(java.awt.Menu)


"
63,MenuComponent,1,boolean add(E e),False,,NULL
63,MenuComponent,2,boolean addAll(Collection<? extends E> c),False,,NULL
63,MenuComponent,3,void clear(),False,,NULL
63,MenuComponent,4,boolean contains(Object o),False,,NULL
63,MenuComponent,5,boolean containsAll(Collection<?> c),False,,NULL
64,MenuItem,1,boolean add(E e),False,,NULL
64,MenuItem,2,boolean addAll(Collection<? extends E> c),False,,NULL
64,MenuItem,3,void addActionListener(ActionListener l),True,Adds the specified action listener to receive action events from this menu item.,"

addActionListener
public void addActionListener(ActionListener l)
Adds the specified action listener to receive action events
 from this menu item.
 If l is null, no exception is thrown and no action is performed.
 Refer to AWT Threading Issues for details on AWT's threading model.

Parameters:
l - the action listener.
Since:
JDK1.1
See Also:
removeActionListener(java.awt.event.ActionListener), 
getActionListeners(), 
ActionEvent, 
ActionListener


"
64,MenuItem,4,void addNotify(),True,Creates the menu item's peer.,"

addNotify
public void addNotify()
Creates the menu item's peer.  The peer allows us to modify the
 appearance of the menu item without changing its functionality.

"
64,MenuItem,5,void addNotify(),True,Creates the menu item's peer.,"

addNotify
public void addNotify()
Creates the menu item's peer.  The peer allows us to modify the
 appearance of the menu item without changing its functionality.

"
65,MenuShortcut,1,MenuShortcut(String shortcut),False,,NULL
65,MenuShortcut,2,String getShortcut(),False,,NULL
65,MenuShortcut,3,void setShortcut(String shortcut),False,,NULL
65,MenuShortcut,4,boolean equals(Object obj),True,Returns whether this MenuShortcut is the same as another: equality is defined to mean that both MenuShortcuts use the same key and both either use or don't use the SHIFT key.,"

equals
public boolean equals(Object obj)
Returns whether this MenuShortcut is the same as another:
 equality is defined to mean that both MenuShortcuts use the same key
 and both either use or don't use the SHIFT key.

Overrides:
equals in class Object
Parameters:
obj - the Object to compare with this.
Returns:
true if this MenuShortcut is the same as another,
 false otherwise.
Since:
1.2
See Also:
Object.hashCode(), 
HashMap


"
65,MenuShortcut,5,int hashCode(),True,Returns the hashcode for this MenuShortcut.,"

hashCode
public int hashCode()
Returns the hashcode for this MenuShortcut.

Overrides:
hashCode in class Object
Returns:
the hashcode for this MenuShortcut.
Since:
1.2
See Also:
Object.equals(java.lang.Object), 
System.identityHashCode(java.lang.Object)


"
66,MouseInfo,1,int getPointerInfo().getLocation().x,False,,NULL
66,MouseInfo,2,int getPointerInfo().getLocation().y,False,,NULL
66,MouseInfo,3,int getNumberOfButtons(),True,Returns the number of buttons on the mouse.,"

getNumberOfButtons
public static int getNumberOfButtons()
                              throws HeadlessException
Returns the number of buttons on the mouse.
 On systems without a mouse, returns -1.

Returns:
number of buttons on the mouse
Throws:
HeadlessException - if GraphicsEnvironment.isHeadless() returns true
Since:
1.5


"
66,MouseInfo,4,boolean isButtonPressed(int button),False,,NULL
66,MouseInfo,5,boolean isButtonDown(int button),False,,NULL
67,MultipleGradientPaint,1,"MultipleGradientPaint(float[] fractions, Color[] colors, CycleMethod cycleMethod)",False,,NULL
67,MultipleGradientPaint,2,"MultipleGradientPaint(float[] fractions, Color[] colors, CycleMethod cycleMethod, Transform transform)",False,,NULL
67,MultipleGradientPaint,3,"MultipleGradientPaint(float[] fractions, Color[] colors, CycleMethod cycleMethod, AffineTransform transform)",False,,NULL
67,MultipleGradientPaint,4,"MultipleGradientPaint(float[] fractions, Color[] colors, CycleMethod cycleMethod, Point2D startPoint, Point2D endPoint)",False,,NULL
67,MultipleGradientPaint,5,"MultipleGradientPaint(float[] fractions, Color[] colors, CycleMethod cycleMethod, Point2D startPoint, Point2D endPoint, Transform transform)",False,,NULL
67,MultipleGradientPaint,6,"MultipleGradientPaint(float[] fractions, Color[] colors, CycleMethod cycleMethod, Point2D startPoint, Point2D endPoint, AffineTransform transform)",False,,NULL
68,PageAttributes,1,boolean equals(Object obj),True,Determines whether two PageAttributes are equal to each other.,"

equals
public boolean equals(Object obj)
Determines whether two PageAttributes are equal to each other.
 
 Two PageAttributes are equal if and only if each of their attributes are
 equal. Attributes of enumeration type are equal if and only if the
 fields refer to the same unique enumeration object. This means that
 an aliased media is equal to its underlying unique media. Printer
 resolutions are equal if and only if the feed resolution, cross feed
 resolution, and units are equal.

Overrides:
equals in class Object
Parameters:
obj - the object whose equality will be checked.
Returns:
whether obj is equal to this PageAttribute according to the
          above criteria.
See Also:
Object.hashCode(), 
HashMap


"
68,PageAttributes,2,int hashCode(),True,Returns a hash code value for this PageAttributes.,"

hashCode
public int hashCode()
Returns a hash code value for this PageAttributes.

Overrides:
hashCode in class Object
Returns:
the hash code.
See Also:
Object.equals(java.lang.Object), 
System.identityHashCode(java.lang.Object)


"
68,PageAttributes,3,Object clone(),True,Creates and returns a copy of this PageAttributes.,"

clone
public Object clone()
Creates and returns a copy of this PageAttributes.

Overrides:
clone in class Object
Returns:
the newly created copy. It is safe to cast this Object into
          a PageAttributes.
See Also:
Cloneable


"
68,PageAttributes,4,PageAttributes getMedia(),False,,NULL
68,PageAttributes,5,PageAttributes getMediaType(),False,,NULL
68,PageAttributes,6,PageAttributes getOrientation(),False,,NULL
68,PageAttributes,7,PageAttributes getCollation(),False,,NULL
68,PageAttributes,8,PageAttributes getCopies(),False,,NULL
68,PageAttributes,9,PageAttributes getDuplex(),False,,NULL
68,PageAttributes,10,PageAttributes getFinishings(),False,,NULL
68,PageAttributes,11,PageAttributes getMediaSize(),False,,NULL
68,PageAttributes,12,PageAttributes getMediaSizeName(),False,,NULL
68,PageAttributes,13,PageAttributes getMediaSizeName(String name),False,,NULL
68,PageAttributes,14,"PageAttributes getMediaSizeName(String name, String name)",False,,NULL
68,PageAttributes,15,"PageAttributes getMediaSizeName(String name, String name, String name)",False,,NULL
68,PageAttributes,16,"PageAttributes getMediaSizeName(String name, String name, String name, String name)",False,,NULL
68,PageAttributes,17,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,18,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,19,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,20,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,21,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,22,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,23,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,24,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,25,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,26,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,27,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,28,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,29,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,30,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,31,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,32,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,33,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,34,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,35,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,36,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
68,PageAttributes,37,"PageAttributes getMediaSizeName(String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name, String name)",False,,NULL
69,PageAttributes.ColorType,1,ColorType getColorType(),False,,NULL
69,PageAttributes.ColorType,2,ColorType getColorType(int index),False,,NULL
69,PageAttributes.ColorType,3,int getColorTypeCount(),False,,NULL
69,PageAttributes.ColorType,4,boolean isColorTypeSupported(ColorType colorType),False,,NULL
69,PageAttributes.ColorType,5,boolean isColorTypeSupported(int index),False,,NULL
70,PageAttributes.MediaType,1,"MediaType(String name, String vendor, String version)",False,,NULL
70,PageAttributes.MediaType,2,String getName(),False,,NULL
70,PageAttributes.MediaType,3,String getVendor(),False,,NULL
70,PageAttributes.MediaType,4,String getVersion(),False,,NULL
70,PageAttributes.MediaType,5,boolean equals(Object obj),False,,NULL
70,PageAttributes.MediaType,6,int hashCode(),True,Returns a hash code value for the object.,"

hashCode
public int hashCode()
Description copied from class: Object
Returns a hash code value for the object. This method is
 supported for the benefit of hash tables such as those provided by
 HashMap.
 
 The general contract of hashCode is:
 
Whenever it is invoked on the same object more than once during
     an execution of a Java application, the hashCode method
     must consistently return the same integer, provided no information
     used in equals comparisons on the object is modified.
     This integer need not remain consistent from one execution of an
     application to another execution of the same application.
 If two objects are equal according to the equals(Object)
     method, then calling the hashCode method on each of
     the two objects must produce the same integer result.
 It is not required that if two objects are unequal
     according to the Object.equals(java.lang.Object)
     method, then calling the hashCode method on each of the
     two objects must produce distinct integer results.  However, the
     programmer should be aware that producing distinct integer results
     for unequal objects may improve the performance of hash tables.
 

 As much as is reasonably practical, the hashCode method defined by
 class Object does return distinct integers for distinct
 objects. (This is typically implemented by converting the internal
 address of the object into an integer, but this implementation
 technique is not required by the
 Java programming language.)

Overrides:
hashCode in class Object
Returns:
a hash code value for this object.
See Also:
Object.equals(java.lang.Object), 
System.identityHashCode(java.lang.Object)


"
70,PageAttributes.MediaType,7,String toString(),True,Returns a string representation of the object.,"

toString
public String toString()
Description copied from class: Object
Returns a string representation of the object. In general, the
 toString method returns a string that
 ""textually represents"" this object. The result should
 be a concise but informative representation that is easy for a
 person to read.
 It is recommended that all subclasses override this method.
 
 The toString method for class Object
 returns a string consisting of the name of the class of which the
 object is an instance, the at-sign character `@', and
 the unsigned hexadecimal representation of the hash code of the
 object. In other words, this method returns a string equal to the
 value of:
 

 getClass().getName() + '@' + Integer.toHexString(hashCode())
 

Overrides:
toString in class Object
Returns:
a string representation of the object.


"
71,PageAttributes.OrientationRequestedType,1,OrientationRequestedType getOrientationRequested(),False,,NULL
71,PageAttributes.OrientationRequestedType,2,boolean isOrientationRequested(),False,,NULL
71,PageAttributes.OrientationRequestedType,3,boolean isOrientationRequested(int orientation),False,,NULL
71,PageAttributes.OrientationRequestedType,4,boolean isOrientationRequested(OrientationRequestedType orientation),False,,NULL
71,PageAttributes.OrientationRequestedType,5,boolean isOrientationRequested(String orientation),False,,NULL
72,PageAttributes.OriginType,1,OriginType getDefaultOriginType(),False,,NULL
72,PageAttributes.OriginType,2,OriginType getOriginType(int originType),False,,NULL
72,PageAttributes.OriginType,3,int getOriginType(OriginType originType),False,,NULL
72,PageAttributes.OriginType,4,boolean isSupported(int originType),False,,NULL
72,PageAttributes.OriginType,5,boolean isSupported(OriginType originType),False,,NULL
73,PageAttributes.PrintQualityType,1,PrintQualityType.DRAFT,False,,NULL
73,PageAttributes.PrintQualityType,2,PrintQualityType.NORMAL,False,,NULL
73,PageAttributes.PrintQualityType,3,PrintQualityType.PHOTOGRAPHIC,False,,NULL
73,PageAttributes.PrintQualityType,4,PrintQualityType.VALUE_OF(String name),False,,NULL
73,PageAttributes.PrintQualityType,5,PrintQualityType.values(),False,,NULL
74,Panel,1,void add(Component comp),False,,NULL
74,Panel,2,"void add(Component comp, Object constraints)",False,,NULL
74,Panel,3,"void add(Component comp, Object constraints, int index)",False,,NULL
74,Panel,4,"void add(Component comp, Object constraints, int index, int width, int height)",False,,NULL
74,Panel,5,"void add(Component comp, Object constraints, int index, double weightx, double weighty)",False,,NULL
75,Point,1,int x,False,,NULL
75,Point,2,int y,False,,NULL
75,Point,3,"void setLocation(int x, int y)",True,Changes the point to have the specified location.,"

setLocation
public void setLocation(int x,
                        int y)
Changes the point to have the specified location.
 
 This method is included for completeness, to parallel the
 setLocation method of Component.
 Its behavior is identical with move(int, int).

Parameters:
x - the X coordinate of the new location
y - the Y coordinate of the new location
Since:
1.1
See Also:
Component.setLocation(int, int), 
getLocation(), 
move(int, int)


"
75,Point,4,void setLocation(Point p),True,Sets the location of the point to the specified location.,"

setLocation
public void setLocation(Point p)
Sets the location of the point to the specified location.
 This method is included for completeness, to parallel the
 setLocation method of Component.

Parameters:
p - a point, the new location for this point
Since:
1.1
See Also:
Component.setLocation(java.awt.Point), 
getLocation()


"
75,Point,5,"void translate(int x, int y)",True,"Translates this point, at location (x,y), by dx along the x axis and dy along the y axis so that it now represents the point (x+dx,y+dy).","

translate
public void translate(int dx,
                      int dy)
Translates this point, at location (x,y),
 by dx along the x axis and dy
 along the y axis so that it now represents the point
 (x+dx,y+dy).

Parameters:
dx - the distance to move this point
                            along the X axis
dy - the distance to move this point
                            along the Y axis


"
76,PointerInfo,1,PointerInfo getPointerInfo(),False,,NULL
76,PointerInfo,2,Point getLocation(),True,Returns the Point that represents the coordinates of the pointer on the screen.,"

getLocation
public Point getLocation()
Returns the Point that represents the coordinates of the pointer
 on the screen. See MouseInfo.getPointerInfo() for more information
 about coordinate calculation for multiscreen systems.

Returns:
coordinates of mouse pointer
Since:
1.5
See Also:
MouseInfo, 
MouseInfo.getPointerInfo()


"
76,PointerInfo,3,Rectangle getBounds(),False,,NULL
76,PointerInfo,4,boolean isVisible(),False,,NULL
76,PointerInfo,5,boolean isValid(),False,,NULL
77,Polygon,1,"boolean addPoint(int x, int y)",False,,NULL
77,Polygon,2,int[] getXPoints(),False,,NULL
77,Polygon,3,int[] getYPoints(),False,,NULL
77,Polygon,4,int npoints(),False,,NULL
77,Polygon,5,"void setPolygon(int[] xpoints, int[] ypoints, int npoints)",False,,NULL
78,PopupMenu,1,boolean add(E e),False,,NULL
78,PopupMenu,2,void addSeparator(),False,,NULL
78,PopupMenu,3,void add(String label),False,,NULL
78,PopupMenu,4,"void add(String label, ActionListener listener)",False,,NULL
78,PopupMenu,5,void remove(int index),False,,NULL
79,PrintJob,1,"PrintJob(Graphics graphics, PageFormat pageFormat, int dialogType)",False,,NULL
79,PrintJob,2,void end(),True,Ends the print job and does any necessary cleanup.,"

end
public abstract void end()
Ends the print job and does any necessary cleanup.

"
79,PrintJob,3,"void print(Graphics graphics, PageFormat pageFormat, int pageIndex)",False,,NULL
79,PrintJob,4,void setJobName(String jobName),False,,NULL
79,PrintJob,5,void setPrintService(PrintService printService),False,,NULL
80,RadialGradientPaint,1,"RadialGradientPaint(float focusX, float focusY, float focusRadius, float[] fractions, Color[] colors)",False,,NULL
80,RadialGradientPaint,2,"RadialGradientPaint(float focusX, float focusY, float focusRadius, float[] fractions, Color[] colors, CycleMethod cycleMethod)",False,,NULL
80,RadialGradientPaint,3,float getFocusX(),False,,NULL
80,RadialGradientPaint,4,float getFocusY(),False,,NULL
80,RadialGradientPaint,5,float getFocusRadius(),False,,NULL
80,RadialGradientPaint,6,float[] getFractions(),False,,NULL
80,RadialGradientPaint,7,Color[] getColors(),False,,NULL
80,RadialGradientPaint,8,CycleMethod getCycleMethod(),False,,NULL
80,RadialGradientPaint,9,"PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints)",True,Creates and returns a PaintContext used to generate a circular radial color gradient pattern.,"

createContext
public PaintContext createContext(ColorModel cm,
                                  Rectangle deviceBounds,
                                  Rectangle2D userBounds,
                                  AffineTransform transform,
                                  RenderingHints hints)
Creates and returns a PaintContext used to
 generate a circular radial color gradient pattern.
 See the description of the createContext method
 for information on null parameter handling.

Parameters:
cm - the preferred ColorModel which represents the most convenient
           format for the caller to receive the pixel data, or null
           if there is no preference.
deviceBounds - the device space bounding box
                     of the graphics primitive being rendered.
userBounds - the user space bounding box
                   of the graphics primitive being rendered.
transform - the AffineTransform from user
              space into device space.
hints - the set of hints that the context object can use to
              choose between rendering alternatives.
Returns:
the PaintContext for
         generating color patterns.
See Also:
Paint, 
PaintContext, 
ColorModel, 
Rectangle, 
Rectangle2D, 
AffineTransform, 
RenderingHints


"
80,RadialGradientPaint,10,"PaintContext createContext(ColorModel cm, Rectangle deviceBounds, Rectangle2D userBounds, AffineTransform xform, RenderingHints hints, int rule)",False,,NULL
81,Rectangle,1,int getX(),False,,NULL
81,Rectangle,2,int getY(),False,,NULL
81,Rectangle,3,int getWidth(),False,,NULL
81,Rectangle,4,int getHeight(),False,,NULL
81,Rectangle,5,"void setRect(int x, int y, int w, int h)",False,,NULL
82,RenderingHints,1,boolean contains(Object o),False,,NULL
82,RenderingHints,2,boolean containsAll(Collection<?> c),False,,NULL
82,RenderingHints,3,boolean remove(Object o),False,,NULL
82,RenderingHints,4,boolean removeAll(Collection<?> c),False,,NULL
82,RenderingHints,5,boolean retainAll(Collection<?> c),False,,NULL
83,RenderingHints.Key,1,RenderingHints.Key.ALPHA_INTERPOLATION,False,,NULL
83,RenderingHints.Key,2,RenderingHints.Key.ANTIALIASING,False,,NULL
83,RenderingHints.Key,3,RenderingHints.Key.COLOR_RENDERING,False,,NULL
83,RenderingHints.Key,4,RenderingHints.Key.DITHERING,False,,NULL
83,RenderingHints.Key,5,RenderingHints.Key.FRACTIONALMETRICS,False,,NULL
83,RenderingHints.Key,6,RenderingHints.Key.INTERPOLATION,False,,NULL
83,RenderingHints.Key,7,RenderingHints.Key.KEY_ANTIALIASING,False,,NULL
83,RenderingHints.Key,8,RenderingHints.Key.KEY_COLOR_RENDERING,False,,NULL
83,RenderingHints.Key,9,RenderingHints.Key.KEY_DITHERING,False,,NULL
83,RenderingHints.Key,10,RenderingHints.Key.KEY_FRACTIONALMETRICS,False,,NULL
83,RenderingHints.Key,11,RenderingHints.Key.KEY_INTERPOLATION,False,,NULL
83,RenderingHints.Key,12,RenderingHints.Key.KEY_RENDERING,False,,NULL
83,RenderingHints.Key,13,RenderingHints.Key.KEY_STROKE_CONTROL,False,,NULL
83,RenderingHints.Key,14,RenderingHints.Key.KEY_TEXT_ANTIALIASING,False,,NULL
83,RenderingHints.Key,15,RenderingHints.Key.RENDERING,False,,NULL
83,RenderingHints.Key,16,RenderingHints.Key.STROKE_CONTROL,False,,NULL
83,RenderingHints.Key,17,RenderingHints.Key.TEXT_ANTIALIASING,False,,NULL
84,Robot,1,void keyPress(int keycode),True,Presses a given key.,"

keyPress
public void keyPress(int keycode)
Presses a given key.  The key should be released using the
 keyRelease method.
 
 Key codes that have more than one physical key associated with them
 (e.g. KeyEvent.VK_SHIFT could mean either the
 left or right shift key) will map to the left key.

Parameters:
keycode - Key to press (e.g. KeyEvent.VK_A)
Throws:
IllegalArgumentException - if keycode is not
          a valid key
See Also:
keyRelease(int), 
KeyEvent


"
84,Robot,2,void keyRelease(int keycode),True,Releases a given key.,"

keyRelease
public void keyRelease(int keycode)
Releases a given key.
 
 Key codes that have more than one physical key associated with them
 (e.g. KeyEvent.VK_SHIFT could mean either the
 left or right shift key) will map to the left key.

Parameters:
keycode - Key to release (e.g. KeyEvent.VK_A)
Throws:
IllegalArgumentException - if keycode is not a
          valid key
See Also:
keyPress(int), 
KeyEvent


"
84,Robot,3,void mousePress(int buttons),True,Presses one or more mouse buttons.,"

mousePress
public void mousePress(int buttons)
Presses one or more mouse buttons.  The mouse buttons should
 be released using the mouseRelease(int) method.

Parameters:
buttons - the Button mask; a combination of one or more
 mouse button masks.
 
 It is allowed to use only a combination of valid values as a buttons parameter.
 A valid combination consists of InputEvent.BUTTON1_DOWN_MASK,
 InputEvent.BUTTON2_DOWN_MASK, InputEvent.BUTTON3_DOWN_MASK
 and values returned by the
 InputEvent.getMaskForButton(button) method.

 The valid combination also depends on a
 Toolkit.areExtraMouseButtonsEnabled() value as follows:
 
 If support for extended mouse buttons is
 disabled by Java
 then it is allowed to use only the following standard button masks:
 InputEvent.BUTTON1_DOWN_MASK, InputEvent.BUTTON2_DOWN_MASK,
 InputEvent.BUTTON3_DOWN_MASK.
  If support for extended mouse buttons is
 enabled by Java
 then it is allowed to use the standard button masks
 and masks for existing extended mouse buttons, if the mouse has more then three buttons.
 In that way, it is allowed to use the button masks corresponding to the buttons
 in the range from 1 to MouseInfo.getNumberOfButtons().
 
 It is recommended to use the InputEvent.getMaskForButton(button)
 method to obtain the mask for any mouse button by its number.
 

 The following standard button masks are also accepted:
 
InputEvent.BUTTON1_MASK
InputEvent.BUTTON2_MASK
InputEvent.BUTTON3_MASK

 However, it is recommended to use InputEvent.BUTTON1_DOWN_MASK,
 InputEvent.BUTTON2_DOWN_MASK,  InputEvent.BUTTON3_DOWN_MASK instead.
 Either extended _DOWN_MASK or old _MASK values
 should be used, but both those models should not be mixed.
Throws:
IllegalArgumentException - if the buttons mask contains the mask for extra mouse button
         and support for extended mouse buttons is disabled by Java
IllegalArgumentException - if the buttons mask contains the mask for extra mouse button
         that does not exist on the mouse and support for extended mouse buttons is enabled by Java
See Also:
mouseRelease(int), 
InputEvent.getMaskForButton(int), 
Toolkit.areExtraMouseButtonsEnabled(), 
MouseInfo.getNumberOfButtons(), 
MouseEvent


"
84,Robot,4,void mouseRelease(int buttons),True,Releases one or more mouse buttons.,"

mouseRelease
public void mouseRelease(int buttons)
Releases one or more mouse buttons.

Parameters:
buttons - the Button mask; a combination of one or more
 mouse button masks.
 
 It is allowed to use only a combination of valid values as a buttons parameter.
 A valid combination consists of InputEvent.BUTTON1_DOWN_MASK,
 InputEvent.BUTTON2_DOWN_MASK, InputEvent.BUTTON3_DOWN_MASK
 and values returned by the
 InputEvent.getMaskForButton(button) method.

 The valid combination also depends on a
 Toolkit.areExtraMouseButtonsEnabled() value as follows:
 
 If the support for extended mouse buttons is
 disabled by Java
 then it is allowed to use only the following standard button masks:
 InputEvent.BUTTON1_DOWN_MASK, InputEvent.BUTTON2_DOWN_MASK,
 InputEvent.BUTTON3_DOWN_MASK.
  If the support for extended mouse buttons is
 enabled by Java
 then it is allowed to use the standard button masks
 and masks for existing extended mouse buttons, if the mouse has more then three buttons.
 In that way, it is allowed to use the button masks corresponding to the buttons
 in the range from 1 to MouseInfo.getNumberOfButtons().
 
 It is recommended to use the InputEvent.getMaskForButton(button)
 method to obtain the mask for any mouse button by its number.
 

 The following standard button masks are also accepted:
 
InputEvent.BUTTON1_MASK
InputEvent.BUTTON2_MASK
InputEvent.BUTTON3_MASK

 However, it is recommended to use InputEvent.BUTTON1_DOWN_MASK,
 InputEvent.BUTTON2_DOWN_MASK,  InputEvent.BUTTON3_DOWN_MASK instead.
 Either extended _DOWN_MASK or old _MASK values
 should be used, but both those models should not be mixed.
Throws:
IllegalArgumentException - if the buttons mask contains the mask for extra mouse button
         and support for extended mouse buttons is disabled by Java
IllegalArgumentException - if the buttons mask contains the mask for extra mouse button
         that does not exist on the mouse and support for extended mouse buttons is enabled by Java
See Also:
mousePress(int), 
InputEvent.getMaskForButton(int), 
Toolkit.areExtraMouseButtonsEnabled(), 
MouseInfo.getNumberOfButtons(), 
MouseEvent


"
84,Robot,5,"void mouseMove(int x, int y)",True,Moves mouse pointer to given screen coordinates.,"

mouseMove
public void mouseMove(int x,
                      int y)
Moves mouse pointer to given screen coordinates.

Parameters:
x - X position
y - Y position


"
84,Robot,6,void delay(int time),True,Sleeps for the specified time.,"

delay
public void delay(int ms)
Sleeps for the specified time.
 To catch any InterruptedExceptions that occur,
 Thread.sleep() may be used instead.

Parameters:
ms - time to sleep in milliseconds
Throws:
IllegalArgumentException - if ms is not between 0 and 60,000 milliseconds inclusive
See Also:
Thread.sleep(long)


"
84,Robot,7,void mouseWheel(int wheelAmt),True,Rotates the scroll wheel on wheel-equipped mice.,"

mouseWheel
public void mouseWheel(int wheelAmt)
Rotates the scroll wheel on wheel-equipped mice.

Parameters:
wheelAmt - number of ""notches"" to move the mouse wheel
                  Negative values indicate movement up/away from the user,
                  positive values indicate movement down/towards the user.
Since:
1.4


"
84,Robot,8,"void mouseDrag(InputEvent origin, InputEvent destination)",False,,NULL
84,Robot,9,"void mouseDrag(InputEvent origin, InputEvent destination, int button)",False,,NULL
84,Robot,10,void mousePress(InputEvent e),False,,NULL
84,Robot,11,void mouseRelease(InputEvent e),False,,NULL
84,Robot,12,void mouseMove(InputEvent e),False,,NULL
84,Robot,13,void keyPress(InputEvent e),False,,NULL
84,Robot,14,void keyRelease(InputEvent e),False,,NULL
84,Robot,15,void mouseWheel(InputEvent e),False,,NULL
84,Robot,16,"void mousePress(int x, int y, int button)",False,,NULL
84,Robot,17,"void mouseRelease(int x, int y, int button)",False,,NULL
84,Robot,18,"void mouseMove(int x, int y)",True,Moves mouse pointer to given screen coordinates.,"

mouseMove
public void mouseMove(int x,
                      int y)
Moves mouse pointer to given screen coordinates.

Parameters:
x - X position
y - Y position


"
84,Robot,19,"void keyPress(int keycode, int modifiers)",False,,NULL
84,Robot,20,"void keyRelease(int keycode, int modifiers)",False,,NULL
84,Robot,21,"void mousePress(int x, int y, int button, int modifiers)",False,,NULL
84,Robot,22,"void mouseRelease(int x, int y, int button, int modifiers)",False,,NULL
84,Robot,23,"void mouseMove(int x, int y, int modifiers)",False,,NULL
84,Robot,24,"void keyPress(int keycode, int modifiers, int when)",False,,NULL
84,Robot,25,"void keyRelease(int keycode, int modifiers, int when)",False,,NULL
84,Robot,26,"void mousePress(int x, int y, int button, int modifiers, int when)",False,,NULL
84,Robot,27,"void mouseRelease(int x, int y, int button, int modifiers, int when)",False,,NULL
84,Robot,28,"void mouseMove(int x, int y, int modifiers, int when)",False,,NULL
84,Robot,29,"void mousePress(int x, int y, int button, int modifiers, int when, int delay)",False,,NULL
84,Robot,30,"void mouseRelease(int x, int y, int button, int modifiers, int when, int delay)",False,,NULL
84,Robot,31,"void mouseMove(int x, int y, int modifiers, int when, int delay)",False,,NULL
84,Robot,32,"void keyPress(int keycode, int modifiers, int when, int delay)",False,,NULL
84,Robot,33,"void keyRelease(int keycode, int modifiers, int when, int delay)",False,,NULL
84,Robot,34,"void mousePress(int x, int y, int button, int modifiers, int when, int delay)",False,,NULL
84,Robot,35,"void mouseRelease(int x, int y, int button, int modifiers, int when, int delay)",False,,NULL
84,Robot,36,"void mouseMove(int x, int y, int modifiers, int when, int delay)",False,,NULL
84,Robot,37,"void mousePress(int x, int y, int button, int modifiers, int when, int delay, int xOrigin, int yOrigin)",False,,NULL
84,Robot,38,"void mouseRelease(int x, int y, int button, int modifiers, int when, int delay, int xOrigin, int yOrigin)",False,,NULL
84,Robot,39,"void mouseMove(int x, int y, int modifiers, int when, int delay, int xOrigin, int yOrigin)",False,,NULL
84,Robot,40,"void keyPress(int keycode, int modifiers, int when, int delay, int xOrigin, int yOrigin)",False,,NULL
84,Robot,41,"void keyRelease(int keycode, int modifiers, int when, int delay, int xOrigin, int yOrigin)",False,,NULL
84,Robot,42,"void mousePress(int x, int y, int button, int modifiers, int when, int delay, int xOrigin, int yOrigin)",False,,NULL
84,Robot,43,"void mouseRelease(int x, int y, int button, int modifiers, int when, int delay, int xOrigin, int yOrigin)",False,,NULL
84,Robot,44,"void mouseMove(int x, int y, int modifiers, int when, int delay, int xOrigin, int yOrigin)",False,,NULL
84,Robot,45,"void mousePress(int x, int y, int button, int modifiers, int when, int delay, int xOrigin, int yOrigin, int xRoot, int yRoot)",False,,NULL
84,Robot,46,"void mouseRelease(int x, int y, int button, int modifiers, int when, int delay, int xOrigin, int yOrigin, int xRoot, int yRoot)",False,,NULL
84,Robot,47,"void mouseMove(int x, int y, int modifiers, int when, int delay, int xOrigin, int yOrigin, int xRoot, int yRoot)",False,,NULL
84,Robot,48,"void keyPress(int keycode, int modifiers, int when, int delay, int xOrigin, int yOrigin, int xRoot, int yRoot)",False,,NULL
84,Robot,49,"void keyRelease(int keycode, int modifiers, int when, int delay, int xOrigin, int yOrigin, int xRoot, int yRoot)",False,,NULL
84,Robot,50,"void mousePress(int x, int y, int button, int modifiers, int when, int delay, int xOrigin, int yOrigin, int xRoot, int yRoot)",False,,NULL
84,Robot,51,"void mouseRelease(int x, int y, int button, int modifiers, int when, int delay, int xOrigin, int yOrigin, int xRoot, int yRoot)",False,,NULL
85,Scrollbar,1,"Scrollbar(int orientation, int value, int extent, int min, int max)",False,,NULL
85,Scrollbar,2,int getBlockIncrement(),True,Gets the block increment of this scroll bar.,"

getBlockIncrement
public int getBlockIncrement()
Gets the block increment of this scroll bar.
 
 The block increment is the value that is added or subtracted
 when the user activates the block increment area of the
 scroll bar, generally through a mouse or keyboard gesture
 that the scroll bar receives as an adjustment event.
 The block increment must be greater than zero.

Specified by:
getBlockIncrement in interface Adjustable
Returns:
the block increment of this scroll bar
Since:
JDK1.1
See Also:
setBlockIncrement(int)


"
85,Scrollbar,3,int getMaximum(),True,Gets the maximum value of this scroll bar.,"

getMaximum
public int getMaximum()
Gets the maximum value of this scroll bar.

Specified by:
getMaximum in interface Adjustable
Returns:
the maximum value of this scroll bar
See Also:
getValue(), 
getMinimum()


"
85,Scrollbar,4,int getMinimum(),True,Gets the minimum value of this scroll bar.,"

getMinimum
public int getMinimum()
Gets the minimum value of this scroll bar.

Specified by:
getMinimum in interface Adjustable
Returns:
the minimum value of this scroll bar
See Also:
getValue(), 
getMaximum()


"
85,Scrollbar,5,int getValue(),True,Gets the current value of this scroll bar.,"

getValue
public int getValue()
Gets the current value of this scroll bar.

Specified by:
getValue in interface Adjustable
Returns:
the current value of this scroll bar
See Also:
getMinimum(), 
getMaximum()


"
85,Scrollbar,6,void setBlockIncrement(int blockIncrement),True,Sets the block increment for this scroll bar.,"

setBlockIncrement
public void setBlockIncrement(int v)
Sets the block increment for this scroll bar.
 
 The block increment is the value that is added or subtracted
 when the user activates the block increment area of the
 scroll bar, generally through a mouse or keyboard gesture
 that the scroll bar receives as an adjustment event.
 The block increment must be greater than zero.
 Attepts to set the block increment to a value lower than 1
 will result in a value of 1 being set.

Specified by:
setBlockIncrement in interface Adjustable
Parameters:
v - the amount by which to increment or decrement
                         the scroll bar's value
Since:
JDK1.1
See Also:
getBlockIncrement()


"
85,Scrollbar,7,void setMaximum(int maximum),True,Sets the maximum value of this scroll bar.,"

setMaximum
public void setMaximum(int newMaximum)
Sets the maximum value of this scroll bar.
 
 When setMaximum is called, the maximum value
 is changed, and other values (including the minimum, the
 visible amount, and the current scroll bar value)
 are changed to be consistent with the new maximum.
 
 Normally, a program should change a scroll bar's maximum
 value only by calling setValues.
 The setValues method simultaneously
 and synchronously sets the minimum, maximum, visible amount,
 and value properties of a scroll bar, so that they are
 mutually consistent.
 
 Note that setting the maximum value to Integer.MIN_VALUE
 will result in the new maximum value being set to
 Integer.MIN_VALUE + 1.

Specified by:
setMaximum in interface Adjustable
Parameters:
newMaximum - the new maximum value
                     for this scroll bar
Since:
JDK1.1
See Also:
setValues(int, int, int, int), 
setMinimum(int)


"
85,Scrollbar,8,void setMinimum(int minimum),True,Sets the minimum value of this scroll bar.,"

setMinimum
public void setMinimum(int newMinimum)
Sets the minimum value of this scroll bar.
 
 When setMinimum is called, the minimum value
 is changed, and other values (including the maximum, the
 visible amount, and the current scroll bar value)
 are changed to be consistent with the new minimum.
 
 Normally, a program should change a scroll bar's minimum
 value only by calling setValues.
 The setValues method simultaneously
 and synchronously sets the minimum, maximum, visible amount,
 and value properties of a scroll bar, so that they are
 mutually consistent.
 
 Note that setting the minimum value to Integer.MAX_VALUE
 will result in the new minimum value being set to
 Integer.MAX_VALUE - 1.

Specified by:
setMinimum in interface Adjustable
Parameters:
newMinimum - the new minimum value for this scroll bar
Since:
JDK1.1
See Also:
setValues(int, int, int, int), 
setMaximum(int)


"
85,Scrollbar,9,void setValue(int value),True,Sets the value of this scroll bar to the specified value.,"

setValue
public void setValue(int newValue)
Sets the value of this scroll bar to the specified value.
 
 If the value supplied is less than the current minimum
 or greater than the current maximum - visibleAmount,
 then either minimum or maximum - visibleAmount
 is substituted, as appropriate.
 
 Normally, a program should change a scroll bar's
 value only by calling setValues.
 The setValues method simultaneously
 and synchronously sets the minimum, maximum, visible amount,
 and value properties of a scroll bar, so that they are
 mutually consistent.
 
 Calling this method does not fire an
 AdjustmentEvent.

Specified by:
setValue in interface Adjustable
Parameters:
newValue - the new value of the scroll bar
See Also:
setValues(int, int, int, int), 
getValue(), 
getMinimum(), 
getMaximum()


"
85,Scrollbar,10,void addAdjustmentListener(AdjustmentListener l),True,Adds the specified adjustment listener to receive instances of AdjustmentEvent from this scroll bar.,"

addAdjustmentListener
public void addAdjustmentListener(AdjustmentListener l)
Adds the specified adjustment listener to receive instances of
 AdjustmentEvent from this scroll bar.
 If l is null, no exception is thrown and no
 action is performed.
 Refer to AWT Threading Issues for details on AWT's threading model.

Specified by:
addAdjustmentListener in interface Adjustable
Parameters:
l - the adjustment listener
Since:
JDK1.1
See Also:
removeAdjustmentListener(java.awt.event.AdjustmentListener), 
getAdjustmentListeners(), 
AdjustmentEvent, 
AdjustmentListener


"
85,Scrollbar,11,void removeAdjustmentListener(AdjustmentListener l),True,Removes the specified adjustment listener so that it no longer receives instances of AdjustmentEvent from this scroll bar.,"

removeAdjustmentListener
public void removeAdjustmentListener(AdjustmentListener l)
Removes the specified adjustment listener so that it no longer
 receives instances of AdjustmentEvent from this scroll bar.
 If l is null, no exception is thrown and no action
 is performed.
 Refer to AWT Threading Issues for details on AWT's threading model.

Specified by:
removeAdjustmentListener in interface Adjustable
Parameters:
l - the adjustment listener
Since:
JDK1.1
See Also:
addAdjustmentListener(java.awt.event.AdjustmentListener), 
getAdjustmentListeners(), 
AdjustmentEvent, 
AdjustmentListener


"
85,Scrollbar,12,void setUnitIncrement(int unitIncrement),True,Sets the unit increment for this scroll bar.,"

setUnitIncrement
public void setUnitIncrement(int v)
Sets the unit increment for this scroll bar.
 
 The unit increment is the value that is added or subtracted
 when the user activates the unit increment area of the
 scroll bar, generally through a mouse or keyboard gesture
 that the scroll bar receives as an adjustment event.
 The unit increment must be greater than zero.
 Attepts to set the unit increment to a value lower than 1
 will result in a value of 1 being set.
 
 In some operating systems, this property
 can be ignored by the underlying controls.

Specified by:
setUnitIncrement in interface Adjustable
Parameters:
v - the amount by which to increment or decrement
                         the scroll bar's value
Since:
JDK1.1
See Also:
getUnitIncrement()


"
85,Scrollbar,13,int getUnitIncrement(),True,Gets the unit increment for this scrollbar.,"

getUnitIncrement
public int getUnitIncrement()
Gets the unit increment for this scrollbar.
 
 The unit increment is the value that is added or subtracted
 when the user activates the unit increment area of the
 scroll bar, generally through a mouse or keyboard gesture
 that the scroll bar receives as an adjustment event.
 The unit increment must be greater than zero.
 
 In some operating systems, this property
 can be ignored by the underlying controls.

Specified by:
getUnitIncrement in interface Adjustable
Returns:
the unit increment of this scroll bar
Since:
JDK1.1
See Also:
setUnitIncrement(int)


"
85,Scrollbar,14,int getVisibleAmount(),True,Gets the visible amount of this scroll bar.,"

getVisibleAmount
public int getVisibleAmount()
Gets the visible amount of this scroll bar.
 
 When a scroll bar is used to select a range of values,
 the visible amount is used to represent the range of values
 that are currently visible.  The size of the scroll bar's
 bubble (also called a thumb or scroll box), usually gives a
 visual representation of the relationship of the visible
 amount to the range of the scroll bar.
 Note that depending on platform, the value of the visible amount property
 may not be visually indicated by the size of the bubble.
 
 The scroll bar's bubble may not be displayed when it is not
 moveable (e.g. when it takes up the entire length of the
 scroll bar's track, or when the scroll bar is disabled).
 Whether the bubble is displayed or not will not affect
 the value returned by getVisibleAmount.

Specified by:
getVisibleAmount in interface Adjustable
Returns:
the visible amount of this scroll bar
Since:
JDK1.1
See Also:
setVisibleAmount(int)


"
85,Scrollbar,15,void setVisibleAmount(int visibleAmount),True,Sets the visible amount of this scroll bar.,"

setVisibleAmount
public void setVisibleAmount(int newAmount)
Sets the visible amount of this scroll bar.
 
 When a scroll bar is used to select a range of values,
 the visible amount is used to represent the range of values
 that are currently visible.  The size of the scroll bar's
 bubble (also called a thumb or scroll box), usually gives a
 visual representation of the relationship of the visible
 amount to the range of the scroll bar.
 Note that depending on platform, the value of the visible amount property
 may not be visually indicated by the size of the bubble.
 
 The scroll bar's bubble may not be displayed when it is not
 moveable (e.g. when it takes up the entire length of the
 scroll bar's track, or when the scroll bar is disabled).
 Whether the bubble is displayed or not will not affect
 the value returned by getVisibleAmount.
 
 If the visible amount supplied is less than one
 or greater than the current maximum - minimum,
 then either one or maximum - minimum
 is substituted, as appropriate.
 
 Normally, a program should change a scroll bar's
 value only by calling setValues.
 The setValues method simultaneously
 and synchronously sets the minimum, maximum, visible amount,
 and value properties of a scroll bar, so that they are
 mutually consistent.

Specified by:
setVisibleAmount in interface Adjustable
Parameters:
newAmount - the new visible amount
Since:
JDK1.1
See Also:
getVisibleAmount(), 
setValues(int, int, int, int)


"
86,ScrollPane,1,ScrollPane(),False,,NULL
86,ScrollPane,2,void setViewportView(Component view),False,,NULL
86,ScrollPane,3,void setHorizontalScrollBarPolicy(int policy),False,,NULL
86,ScrollPane,4,void setVerticalScrollBarPolicy(int policy),False,,NULL
86,ScrollPane,5,void setPreferredSize(Dimension preferredSize),False,,NULL
87,ScrollPaneAdjustable,1,int getBlockIncrement(),True,Gets the block value increment for the adjustable object.,"

getBlockIncrement
public int getBlockIncrement()
Description copied from interface: Adjustable
Gets the block value increment for the adjustable object.

Specified by:
getBlockIncrement in interface Adjustable
Returns:
the block value increment for the adjustable object


"
87,ScrollPaneAdjustable,2,int getMaximum(),True,Gets the maximum value of the adjustable object.,"

getMaximum
public int getMaximum()
Description copied from interface: Adjustable
Gets the maximum value of the adjustable object.

Specified by:
getMaximum in interface Adjustable
Returns:
the maximum value of the adjustable object


"
87,ScrollPaneAdjustable,3,int getMinimum(),True,Gets the minimum value of the adjustable object.,"

getMinimum
public int getMinimum()
Description copied from interface: Adjustable
Gets the minimum value of the adjustable object.

Specified by:
getMinimum in interface Adjustable
Returns:
the minimum value of the adjustable object


"
87,ScrollPaneAdjustable,4,int getUnitIncrement(),True,Gets the unit value increment for the adjustable object.,"

getUnitIncrement
public int getUnitIncrement()
Description copied from interface: Adjustable
Gets the unit value increment for the adjustable object.

Specified by:
getUnitIncrement in interface Adjustable
Returns:
the unit value increment for the adjustable object


"
87,ScrollPaneAdjustable,5,int getValue(),True,Gets the current value of the adjustable object.,"

getValue
public int getValue()
Description copied from interface: Adjustable
Gets the current value of the adjustable object.

Specified by:
getValue in interface Adjustable
Returns:
the current value of the adjustable object


"
88,SplashScreen,1,boolean isVisible(),True,Determines whether the splash screen is visible.,"

isVisible
public boolean isVisible()
Determines whether the splash screen is visible. The splash screen may
 be hidden using close(), it is also hidden automatically when
 the first AWT/Swing window is made visible.
 
 Note that the native platform may delay presenting the splash screen
 native window on the screen. The return value of true for this
 method only guarantees that the conditions to hide the splash screen
 window have not occurred yet.

Returns:
true if the splash screen is visible (has not been closed yet),
         false otherwise


"
88,SplashScreen,2,void close(),True,"Hides the splash screen, closes the window, and releases all associated resources.","

close
public void close()
           throws IllegalStateException
Hides the splash screen, closes the window, and releases all associated
 resources.

Throws:
IllegalStateException - if the splash screen has already been closed


"
88,SplashScreen,3,BufferedImage getImage(),False,,NULL
88,SplashScreen,4,Rectangle getBounds(),True,Returns the bounds of the splash screen window as a Rectangle.,"

getBounds
public Rectangle getBounds()
                    throws IllegalStateException
Returns the bounds of the splash screen window as a Rectangle.
 This may be useful if, for example, you want to replace the splash
 screen with your window at the same location.
 
 You cannot control the size or position of the splash screen.
 The splash screen size is adjusted automatically when the image changes.
 
 The image may contain transparent areas, and thus the reported bounds may
 be larger than the visible splash screen image on the screen.

Returns:
a Rectangle containing the splash screen bounds
Throws:
IllegalStateException - if the splash screen has already been closed


"
88,SplashScreen,5,Graphics2D createGraphics(),True,"Creates a graphics context (as a Graphics2D object) for the splash screen overlay image, which allows you to draw over the splash screen.","

createGraphics
public Graphics2D createGraphics()
                          throws IllegalStateException
Creates a graphics context (as a Graphics2D object) for the splash
 screen overlay image, which allows you to draw over the splash screen.
 Note that you do not draw on the main image but on the image that is
 displayed over the main image using alpha blending. Also note that drawing
 on the overlay image does not necessarily update the contents of splash
 screen window. You should call update() on the
 SplashScreen when you want the splash screen to be
 updated immediately.
 
 The pixel (0, 0) in the coordinate space of the graphics context
 corresponds to the origin of the splash screen native window bounds (see
 getBounds()).

Returns:
graphics context for the splash screen overlay surface
Throws:
IllegalStateException - if the splash screen has already been closed


"
89,SystemColor,1,Color getControl(),False,,NULL
89,SystemColor,2,Color getControlHighlight(),False,,NULL
89,SystemColor,3,Color getControlLtHighlight(),False,,NULL
89,SystemColor,4,Color getControlShadow(),False,,NULL
89,SystemColor,5,Color getDesktop(),False,,NULL
89,SystemColor,6,Color getHighlight(),False,,NULL
89,SystemColor,7,Color getInfo(),False,,NULL
89,SystemColor,8,Color getInfoText(),False,,NULL
89,SystemColor,9,Color getMenu(),False,,NULL
89,SystemColor,10,Color getMenuText(),False,,NULL
89,SystemColor,11,Color getScrollbar(),False,,NULL
89,SystemColor,12,Color getShadow(),False,,NULL
89,SystemColor,13,Color getText(),False,,NULL
89,SystemColor,14,Color getTextHighlight(),False,,NULL
89,SystemColor,15,Color getTextInactiveText(),False,,NULL
89,SystemColor,16,Color getWindow(),False,,NULL
89,SystemColor,17,Color getWindowBorder(),False,,NULL
89,SystemColor,18,Color getWindowText(),False,,NULL
90,SystemTray,1,boolean isSupported(),True,Returns whether the system tray is supported on the current platform.,"

isSupported
public static boolean isSupported()
Returns whether the system tray is supported on the current
 platform.  In addition to displaying the tray icon, minimal
 system tray support includes either a popup menu (see TrayIcon.setPopupMenu(PopupMenu)) or an action event (see
 TrayIcon.addActionListener(ActionListener)).

 Developers should not assume that all of the system tray
 functionality is supported.  To guarantee that the tray icon's
 default action is always accessible, add the default action to
 both the action listener and the popup menu.  See the example for an example of how to do this.

 Note: When implementing SystemTray and
 TrayIcon it is strongly recommended that
 you assign different gestures to the popup menu and an action
 event.  Overloading a gesture for both purposes is confusing
 and may prevent the user from accessing one or the other.

Returns:
false if no system tray access is supported; this
 method returns true if the minimal system tray access is
 supported but does not guarantee that all system tray
 functionality is supported for the current platform
See Also:
getSystemTray()


"
90,SystemTray,2,TrayIcon[] getTrayIcons(),True,Returns an array of all icons added to the tray by this application.,"

getTrayIcons
public TrayIcon[] getTrayIcons()
Returns an array of all icons added to the tray by this
 application.  You can't access the icons added by another
 application.  Some browsers partition applets in different
 code bases into separate contexts, and establish walls between
 these contexts.  In such a scenario, only the tray icons added
 from this context will be returned.

  The returned array is a copy of the actual array and may be
 modified in any way without affecting the system tray.  To
 remove a TrayIcon from the
 SystemTray, use the remove(TrayIcon) method.

Returns:
an array of all tray icons added to this tray, or an
 empty array if none has been added
See Also:
add(TrayIcon), 
TrayIcon


"
90,SystemTray,3,void setTrayIcon(TrayIcon trayIcon),False,,NULL
90,SystemTray,4,void remove(TrayIcon trayIcon),True,Removes the specified TrayIcon from the SystemTray.,"

remove
public void remove(TrayIcon trayIcon)
Removes the specified TrayIcon from the
 SystemTray.

  All icons added by the application are automatically
 removed from the SystemTray upon application exit
 and also when the desktop system tray becomes unavailable.

  If trayIcon is null or was not
 added to the system tray, no exception is thrown and no action
 is performed.

Parameters:
trayIcon - the TrayIcon to be removed
See Also:
add(TrayIcon), 
TrayIcon


"
90,SystemTray,5,void add(TrayIcon trayIcon),True,Adds a TrayIcon to the SystemTray.,"

add
public void add(TrayIcon trayIcon)
         throws AWTException
Adds a TrayIcon to the SystemTray.
 The tray icon becomes visible in the system tray once it is
 added.  The order in which icons are displayed in a tray is not
 specified - it is platform and implementation-dependent.

  All icons added by the application are automatically
 removed from the SystemTray upon application exit
 and also when the desktop system tray becomes unavailable.

Parameters:
trayIcon - the TrayIcon to be added
Throws:
NullPointerException - if trayIcon is
 null
IllegalArgumentException - if the same instance of
 a TrayIcon is added more than once
AWTException - if the desktop system tray is missing
See Also:
remove(TrayIcon), 
getSystemTray(), 
TrayIcon, 
Image


"
91,TextArea,1,void append(String str),True,Appends the given text to the text area's current text.,"

append
public void append(String str)
Appends the given text to the text area's current text.
 Note that passing null or inconsistent
 parameters is invalid and will result in unspecified
 behavior.

Parameters:
str - the non-null text to append
Since:
JDK1.1
See Also:
insert(java.lang.String, int)


"
91,TextArea,2,"void setBounds(int x, int y, int width, int height)",False,,NULL
91,TextArea,3,void setColumns(int columns),True,Sets the number of columns for this text area.,"

setColumns
public void setColumns(int columns)
Sets the number of columns for this text area.

Parameters:
columns - the number of columns
Throws:
IllegalArgumentException - if the value
                 supplied for columns
                 is less than 0
Since:
JDK1.1
See Also:
getColumns(), 
setRows(int)


"
91,TextArea,4,void setRows(int rows),True,Sets the number of rows for this text area.,"

setRows
public void setRows(int rows)
Sets the number of rows for this text area.

Parameters:
rows - the number of rows
Throws:
IllegalArgumentException - if the value
                 supplied for rows
                 is less than 0
Since:
JDK1.1
See Also:
getRows(), 
setColumns(int)


"
91,TextArea,5,void setEditable(boolean b),False,,NULL
92,TextComponent,1,boolean add(E e),False,,NULL
92,TextComponent,2,"void add(int index, E element)",False,,NULL
92,TextComponent,3,boolean addAll(Collection<? extends E> c),False,,NULL
92,TextComponent,4,"boolean addAll(int index, Collection<? extends E> c)",False,,NULL
92,TextComponent,5,void clear(),False,,NULL
93,TextField,1,TextField(),False,,NULL
93,TextField,2,void setColumns(int columns),True,Sets the number of columns in this text field.,"

setColumns
public void setColumns(int columns)
Sets the number of columns in this text field. A column is an
 approximate average character width that is platform-dependent.

Parameters:
columns - the number of columns.
Throws:
IllegalArgumentException - if the value
                 supplied for columns
                 is less than 0.
Since:
JDK1.1
See Also:
getColumns()


"
93,TextField,3,int getColumns(),True,Gets the number of columns in this text field.,"

getColumns
public int getColumns()
Gets the number of columns in this text field. A column is an
 approximate average character width that is platform-dependent.

Returns:
the number of columns.
Since:
JDK1.1
See Also:
setColumns(int)


"
93,TextField,4,void setEchoChar(char echoChar),True,Sets the echo character for this text field.,"

setEchoChar
public void setEchoChar(char c)
Sets the echo character for this text field.
 
 An echo character is useful for text fields where
 user input should not be echoed to the screen, as in
 the case of a text field for entering a password.
 Setting echoChar = 0 allows
 user input to be echoed to the screen again.
 
 A Java platform implementation may support only a limited,
 non-empty set of echo characters. Attempts to set an
 unsupported echo character will cause the default echo
 character to be used instead. Subsequent calls to getEchoChar()
 will return the echo character originally requested. This might
 or might not be identical to the echo character actually
 used by the TextField implementation.

Parameters:
c - the echo character for this text field.
Since:
JDK1.1
See Also:
echoCharIsSet(), 
getEchoChar()


"
93,TextField,5,char getEchoChar(),True,Gets the character that is to be used for echoing.,"

getEchoChar
public char getEchoChar()
Gets the character that is to be used for echoing.
 
 An echo character is useful for text fields where
 user input should not be echoed to the screen, as in
 the case of a text field for entering a password.
 If echoChar = 0, user
 input is echoed to the screen unchanged.
 
 A Java platform implementation may support only a limited,
 non-empty set of echo characters. This function returns the
 echo character originally requested via setEchoChar(). The echo
 character actually used by the TextField implementation might be
 different.

Returns:
the echo character for this text field.
See Also:
echoCharIsSet(), 
setEchoChar(char)


"
93,TextField,6,void setEditable(boolean b),False,,NULL
93,TextField,7,boolean isEditable(),False,,NULL
93,TextField,8,void setText(String text),True,Sets the text that is presented by this text component to be the specified text.,"

setText
public void setText(String t)
Sets the text that is presented by this
 text component to be the specified text.

Overrides:
setText in class TextComponent
Parameters:
t - the new text.
See Also:
TextComponent.getText()


"
93,TextField,9,String getText(),False,,NULL
93,TextField,10,void setCaretPosition(int caretPosition),False,,NULL
93,TextField,11,int getCaretPosition(),False,,NULL
93,TextField,12,void setSelectionStart(int selectionStart),False,,NULL
93,TextField,13,int getSelectionStart(),False,,NULL
93,TextField,14,void setSelectionEnd(int selectionEnd),False,,NULL
93,TextField,15,int getSelectionEnd(),False,,NULL
93,TextField,16,void setActionCommand(String actionCommand),False,,NULL
93,TextField,17,String getActionCommand(),False,,NULL
93,TextField,18,void setActionListener(ActionListener l),False,,NULL
93,TextField,19,ActionListener getActionListener(),False,,NULL
93,TextField,20,"void setBounds(int x, int y, int width, int height)",False,,NULL
93,TextField,21,void setBounds(Rectangle r),False,,NULL
93,TextField,22,void setFont(Font font),False,,NULL
93,TextField,23,Font getFont(),False,,NULL
93,TextField,24,void setForeground(Color c),False,,NULL
93,TextField,25,Color getForeground(),False,,NULL
93,TextField,26,void setBackground(Color c),False,,NULL
93,TextField,27,Color getBackground(),False,,NULL
93,TextField,28,void setEnabled(boolean b),False,,NULL
93,TextField,29,boolean isEnabled(),False,,NULL
93,TextField,30,void setVisible(boolean b),False,,NULL
93,TextField,31,boolean isVisible(),False,,NULL
93,TextField,32,void setFocusable(boolean b),False,,NULL
93,TextField,33,boolean isFocusable(),False,,NULL
93,TextField,34,void setFocusTraversalKeysEnabled(boolean b),False,,NULL
93,TextField,35,boolean isFocusTraversalKeysEnabled(),False,,NULL
93,TextField,36,void setComponentOrientation(ComponentOrientation orientation),False,,NULL
93,TextField,37,ComponentOrientation getComponentOrientation(),False,,NULL
93,TextField,38,void setToolTipText(String toolTipText),False,,NULL
93,TextField,39,String getToolTipText(),False,,NULL
93,TextField,40,void setName(String name),False,,NULL
93,TextField,41,String getName(),False,,NULL
93,TextField,42,void setLabel(String label),False,,NULL
93,TextField,43,String getLabel(),False,,NULL
93,TextField,44,void setLabelFor(String labelFor),False,,NULL
93,TextField,45,String getLabelFor(),False,,NULL
93,TextField,46,void setLabelTable(LabelTable labelTable),False,,NULL
93,TextField,47,LabelTable getLabelTable(),False,,NULL
93,TextField,48,void setLabelTable(LabelTable labelTable),False,,NULL
93,TextField,49,LabelTable getLabelTable(),False,,NULL
93,TextField,50,void setLabelTable(LabelTable labelTable),False,,NULL
93,TextField,51,LabelTable getLabelTable(),False,,NULL
93,TextField,52,void setLabelTable(LabelTable labelTable),False,,NULL
93,TextField,53,LabelTable getLabelTable(),False,,NULL
93,TextField,54,void setLabelTable(LabelTable labelTable),False,,NULL
93,TextField,55,LabelTable getLabelTable(),False,,NULL
93,TextField,56,void setLabelTable(LabelTable labelTable),False,,NULL
93,TextField,57,LabelTable getLabelTable(),False,,NULL
93,TextField,58,void setLabelTable(LabelTable labelTable),False,,NULL
93,TextField,59,LabelTable getLabelTable(),False,,NULL
93,TextField,60,void setLabelTable(LabelTable labelTable),False,,NULL
93,TextField,61,LabelTable getLabelTable(),False,,NULL
93,TextField,62,void setLabelTable(LabelTable labelTable),False,,NULL
93,TextField,63,LabelTable getLabelTable(),False,,NULL
93,TextField,64,void setLabelTable(LabelTable labelTable),False,,NULL
93,TextField,65,LabelTable getLabelTable(),False,,NULL
93,TextField,66,void setLabelTable(LabelTable labelTable),False,,NULL
93,TextField,67,LabelTable getLabelTable(),False,,NULL
93,TextField,68,void setLabelTable(LabelTable labelTable),False,,NULL
93,TextField,69,LabelTable getLabelTable(),False,,NULL
94,TexturePaint,1,"TexturePaint(BufferedImage image, Rectangle2D texRect)",False,,NULL
94,TexturePaint,2,"TexturePaint(BufferedImage image, Rectangle2D texRect, TexturePaint.Transform tx)",False,,NULL
94,TexturePaint,3,BufferedImage getImage(),True,Returns the BufferedImage texture used to fill the shapes.,"

getImage
public BufferedImage getImage()
Returns the BufferedImage texture used to
 fill the shapes.

Returns:
a BufferedImage.


"
94,TexturePaint,4,Rectangle2D getTextureRect(),False,,NULL
94,TexturePaint,5,TexturePaint.Transform getTransform(),False,,NULL
95,Toolkit,1,Dimension getScreenSize(),True,Gets the size of the screen.,"

getScreenSize
public abstract Dimension getScreenSize()
                                 throws HeadlessException
Gets the size of the screen.  On systems with multiple displays, the
 primary display is used.  Multi-screen aware display dimensions are
 available from GraphicsConfiguration and
 GraphicsDevice.

Returns:
the size of this toolkit's screen, in pixels.
Throws:
HeadlessException - if GraphicsEnvironment.isHeadless()
 returns true
See Also:
GraphicsConfiguration.getBounds(), 
GraphicsDevice.getDisplayMode(), 
GraphicsEnvironment.isHeadless()


"
95,Toolkit,2,Rectangle getScreenRect(),False,,NULL
95,Toolkit,3,GraphicsConfiguration[] getScreenConfigurations(),False,,NULL
95,Toolkit,4,void beep(),True,Emits an audio beep depending on native system settings and hardware capabilities.,"

beep
public abstract void beep()
Emits an audio beep depending on native system settings and hardware
 capabilities.

Since:
JDK1.1


"
95,Toolkit,5,"void showSystemEvent(String title, String message)",False,,NULL
95,Toolkit,6,void openWindows(),False,,NULL
95,Toolkit,7,void openWindows(Frame f),False,,NULL
95,Toolkit,8,"void openWindows(Frame f, String title)",False,,NULL
95,Toolkit,9,"void openWindows(Frame f, String title, int x, int y, int w, int h)",False,,NULL
95,Toolkit,10,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type)",False,,NULL
95,Toolkit,11,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable)",False,,NULL
95,Toolkit,12,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal)",False,,NULL
95,Toolkit,13,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront)",False,,NULL
95,Toolkit,14,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify)",False,,NULL
95,Toolkit,15,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify, boolean decorate)",False,,NULL
95,Toolkit,16,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify, boolean decorate, boolean focusable)",False,,NULL
95,Toolkit,17,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify, boolean decorate, boolean focusable, boolean hasPopupMenu)",False,,NULL
95,Toolkit,18,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify, boolean decorate, boolean focusable, boolean hasPopupMenu, boolean hasMenuBar)",False,,NULL
95,Toolkit,19,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify, boolean decorate, boolean focusable, boolean hasPopupMenu, boolean hasMenuBar, boolean hasToolBar)",False,,NULL
95,Toolkit,20,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify, boolean decorate, boolean focusable, boolean hasPopupMenu, boolean hasMenuBar, boolean hasToolBar, boolean isUndecorated)",False,,NULL
95,Toolkit,21,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify, boolean decorate, boolean focusable, boolean hasPopupMenu, boolean hasMenuBar, boolean hasToolBar, boolean isUndecorated, boolean isModalBlocked)",False,,NULL
95,Toolkit,22,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify, boolean decorate, boolean focusable, boolean hasPopupMenu, boolean hasMenuBar, boolean hasToolBar, boolean isUndecorated, boolean isModalBlocked, boolean isModalExclusive)",False,,NULL
95,Toolkit,23,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify, boolean decorate, boolean focusable, boolean hasPopupMenu, boolean hasMenuBar, boolean hasToolBar, boolean isUndecorated, boolean isModalBlocked, boolean isModalExclusive, boolean isModalType)",False,,NULL
95,Toolkit,24,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify, boolean decorate, boolean focusable, boolean hasPopupMenu, boolean hasMenuBar, boolean hasToolBar, boolean isUndecorated, boolean isModalBlocked, boolean isModalExclusive, boolean isModalType, boolean isModalTransparencyType)",False,,NULL
95,Toolkit,25,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify, boolean decorate, boolean focusable, boolean hasPopupMenu, boolean hasMenuBar, boolean hasToolBar, boolean isUndecorated, boolean isModalBlocked, boolean isModalExclusive, boolean isModalType, boolean isModalTransparencyType, boolean isModalFullScreenType)",False,,NULL
95,Toolkit,26,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify, boolean decorate, boolean focusable, boolean hasPopupMenu, boolean hasMenuBar, boolean hasToolBar, boolean isUndecorated, boolean isModalBlocked, boolean isModalExclusive, boolean isModalType, boolean isModalTransparencyType, boolean isModalFullScreenType, boolean isModalFullScreenBlocked)",False,,NULL
95,Toolkit,27,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify, boolean decorate, boolean focusable, boolean hasPopupMenu, boolean hasMenuBar, boolean hasToolBar, boolean isUndecorated, boolean isModalBlocked, boolean isModalExclusive, boolean isModalType, boolean isModalTransparencyType, boolean isModalFullScreenType, boolean isModalFullScreenBlocked, boolean isModalFullScreenExclusive)",False,,NULL
95,Toolkit,28,"void openWindows(Frame f, String title, int x, int y, int w, int h, int type, boolean resizable, boolean modal, boolean closeToFront, boolean iconify, boolean decorate, boolean focusable, boolean hasPopupMenu, boolean hasMenuBar, boolean hasToolBar, boolean isUndecorated, boolean isModalBlocked, boolean isModalExclusive, boolean isModalType, boolean isModalTransparencyType, boolean isModalFullScreenType, boolean isModalFullScreenBlocked, boolean isModalFullScreenExclusive, boolean isModalFullScreenType)",False,,NULL
96,TrayIcon,1,TrayIcon(Image image),False,,NULL
96,TrayIcon,2,"void displayMessage(String caption, String text, TrayIcon.MessageType type)",True,Displays a popup message near the tray icon.,"

displayMessage
public void displayMessage(String caption,
                           String text,
                           TrayIcon.MessageType messageType)
Displays a popup message near the tray icon.  The message will
 disappear after a time or if the user clicks on it.  Clicking
 on the message may trigger an ActionEvent.

 Either the caption or the text may be null, but an
 NullPointerException is thrown if both are
 null.

 When displayed, the caption or text strings may be truncated on
 some platforms; the number of characters that may be displayed is
 platform-dependent.

 Note: Some platforms may not support
 showing a message.

Parameters:
caption - the caption displayed above the text, usually in
 bold; may be null
text - the text displayed for the particular message; may be
 null
messageType - an enum indicating the message type
Throws:
NullPointerException - if both caption
 and text are null


"
96,TrayIcon,3,void setImage(Image image),True,Sets the image for this TrayIcon.,"

setImage
public void setImage(Image image)
Sets the image for this TrayIcon.  The previous
 tray icon image is discarded without calling the Image.flush() method  you will need to call it
 manually.

  If the image represents an animated image, it will be
 animated automatically.

  See the setImageAutoSize(boolean) property for
 details on the size of the displayed image.

  Calling this method with the same image that is currently
 being used has no effect.

Parameters:
image - the non-null Image to be used
Throws:
NullPointerException - if image is null
See Also:
getImage(), 
Image, 
SystemTray.add(TrayIcon), 
TrayIcon(Image, String)


"
96,TrayIcon,4,void setToolTip(String tooltip),True,Sets the tooltip string for this TrayIcon.,"

setToolTip
public void setToolTip(String tooltip)
Sets the tooltip string for this TrayIcon. The
 tooltip is displayed automatically when the mouse hovers over
 the icon.  Setting the tooltip to null removes any
 tooltip text.

 When displayed, the tooltip string may be truncated on some platforms;
 the number of characters that may be displayed is platform-dependent.

Parameters:
tooltip - the string for the tooltip; if the value is
 null no tooltip is shown
See Also:
getToolTip()


"
96,TrayIcon,5,void setPopupMenu(PopupMenu popup),True,Sets the popup menu for this TrayIcon.,"

setPopupMenu
public void setPopupMenu(PopupMenu popup)
Sets the popup menu for this TrayIcon.  If
 popup is null, no popup menu will be
 associated with this TrayIcon.

 Note that this popup must not be added to any
 parent before or after it is set on the tray icon.  If you add
 it to some parent, the popup may be removed from
 that parent.

 The popup can be set on one TrayIcon only.
 Setting the same popup on multiple TrayIcons will cause
 an IllegalArgumentException.

 Note: Some platforms may not support
 showing the user-specified popup menu component when the user
 right-clicks the tray icon.  In this situation, either no menu
 will be displayed or, on some systems, a native version of the
 menu may be displayed.

Parameters:
popup - a PopupMenu or null to
 remove any popup menu
Throws:
IllegalArgumentException - if the popup is already
 set for another TrayIcon
See Also:
getPopupMenu()


"
97,Window,1,Window(),False,,NULL
97,Window,2,void setTitle(String title),False,,NULL
97,Window,3,"void setSize(int width, int height)",True,Resizes this component so that it has width width and height height.,"

setSize
public void setSize(int width,
                    int height)
Resizes this component so that it has width width
 and height height.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
 The width and height values
 are automatically enlarged if either is less than
 the minimum size as specified by previous call to
 setMinimumSize.
 
 The method changes the geometry-related data. Therefore,
 the native windowing system may ignore such requests, or it may modify
 the requested data, so that the Window object is placed and sized
 in a way that corresponds closely to the desktop settings.

Overrides:
setSize in class Component
Parameters:
width - the new width of this component in pixels
height - the new height of this component in pixels
Since:
1.6
See Also:
Component.getSize(), 
setBounds(int, int, int, int), 
setMinimumSize(java.awt.Dimension)


"
97,Window,4,"void setLocation(int x, int y)",True,Moves this component to a new location.,"

setLocation
public void setLocation(int x,
                        int y)
Moves this component to a new location. The top-left corner of
 the new location is specified by the x and y
 parameters in the coordinate space of this component's parent.
 
 This method changes layout-related information, and therefore,
 invalidates the component hierarchy.
 
 The method changes the geometry-related data. Therefore,
 the native windowing system may ignore such requests, or it may modify
 the requested data, so that the Window object is placed and sized
 in a way that corresponds closely to the desktop settings.

Overrides:
setLocation in class Component
Parameters:
x - the x-coordinate of the new location's
          top-left corner in the parent's coordinate space
y - the y-coordinate of the new location's
          top-left corner in the parent's coordinate space
See Also:
Component.getLocation(), 
Component.setBounds(int, int, int, int), 
Component.invalidate()


"
97,Window,5,void setVisible(boolean b),True,Shows or hides this Window depending on the value of parameter b.,"

setVisible
public void setVisible(boolean b)
Shows or hides this Window depending on the value of parameter
 b.
 
 If the method shows the window then the window is also made
 focused under the following conditions:
 
 The Window meets the requirements outlined in the
      isFocusableWindow() method.
  The Window's autoRequestFocus property is of the true value.
  Native windowing system allows the Window to get focused.
 
 There is an exception for the second condition (the value of the
 autoRequestFocus property). The property is not taken into account if the
 window is a modal dialog, which blocks the currently focused window.
 
 Developers must never assume that the window is the focused or active window
 until it receives a WINDOW_GAINED_FOCUS or WINDOW_ACTIVATED event.

Overrides:
setVisible in class Component
Parameters:
b - if true, makes the Window visible,
 otherwise hides the Window.
 If the Window and/or its owner
 are not yet displayable, both are made displayable.  The
 Window will be validated prior to being made visible.
 If the Window is already visible, this will bring the
 Window to the front.
 If false, hides this Window, its subcomponents, and all
 of its owned children.
 The Window and its subcomponents can be made visible again
 with a call to #setVisible(true).
See Also:
Component.isDisplayable(), 
Component.setVisible(boolean), 
toFront(), 
dispose(), 
setAutoRequestFocus(boolean), 
isFocusableWindow()


"
97,Window,6,void dispose(),True,"Releases all of the native screen resources used by this Window, its subcomponents, and all of its owned children.","

dispose
public void dispose()
Releases all of the native screen resources used by this
 Window, its subcomponents, and all of its owned
 children. That is, the resources for these Components
 will be destroyed, any memory they consume will be returned to the
 OS, and they will be marked as undisplayable.
 
 The Window and its subcomponents can be made displayable
 again by rebuilding the native resources with a subsequent call to
 pack or show. The states of the recreated
 Window and its subcomponents will be identical to the
 states of these objects at the point where the Window
 was disposed (not accounting for additional modifications between
 those actions).
 
Note: When the last displayable window
 within the Java virtual machine (VM) is disposed of, the VM may
 terminate.  See 
 AWT Threading Issues for more information.

See Also:
Component.isDisplayable(), 
pack(), 
show()


"
97,Window,7,void add(Component comp),False,,NULL
97,Window,8,void remove(Component comp),False,,NULL
97,Window,9,void repaint(),False,,NULL
97,Window,10,void update(Graphics g),False,,NULL
97,Window,11,void paint(Graphics g),True,Paints the container.,"

paint
public void paint(Graphics g)
Paints the container. This forwards the paint to any lightweight
 components that are children of this container. If this method is
 reimplemented, super.paint(g) should be called so that lightweight
 components are properly rendered. If a child component is entirely
 clipped by the current clipping setting in g, paint() will not be
 forwarded to that child.

Overrides:
paint in class Container
Parameters:
g - the specified Graphics window
Since:
1.7
See Also:
Component.update(Graphics)


"
97,Window,12,void setBackground(Color c),True,Sets the background color of this window.,"

setBackground
public void setBackground(Color bgColor)
Sets the background color of this window.
 
 If the windowing system supports the PERPIXEL_TRANSLUCENT
 translucency, the alpha component of the given background color
 may effect the mode of operation for this window: it indicates whether
 this window must be opaque (alpha equals 1.0f) or per-pixel translucent
 (alpha is less than 1.0f). If the given background color is
 null, the window is considered completely opaque.
 
 All the following conditions must be met to enable the per-pixel
 transparency mode for this window:
 
The PERPIXEL_TRANSLUCENT translucency must be supported by the graphics
 device where this window is located
 The window must be undecorated (see Frame.setUndecorated(boolean)
 and Dialog.setUndecorated(boolean))
 The window must not be in full-screen mode (see GraphicsDevice.setFullScreenWindow(Window))
 

 If the alpha component of the requested background color is less than
 1.0f, and any of the above conditions are not met, the background
 color of this window will not change, the alpha component of the given
 background color will not affect the mode of operation for this window,
 and either the UnsupportedOperationException or IllegalComponentStateException will be thrown.
 
 When the window is per-pixel translucent, the drawing sub-system
 respects the alpha value of each individual pixel. If a pixel gets
 painted with the alpha color component equal to zero, it becomes
 visually transparent. If the alpha of the pixel is equal to 1.0f, the
 pixel is fully opaque. Interim values of the alpha color component make
 the pixel semi-transparent. In this mode, the background of the window
 gets painted with the alpha value of the given background color. If the
 alpha value of the argument of this method is equal to 0, the
 background is not painted at all.
 
 The actual level of translucency of a given pixel also depends on window
 opacity (see setOpacity(float)), as well as the current shape of
 this window (see setShape(Shape)).
 
 Note that painting a pixel with the alpha value of 0 may or may
 not disable the mouse event handling on this pixel. This is a
 platform-dependent behavior. To make sure the mouse events do not get
 dispatched to a particular pixel, the pixel must be excluded from the
 shape of the window.
 
 Enabling the per-pixel translucency mode may change the graphics
 configuration of this window due to the native platform requirements.

Overrides:
setBackground in class Component
Parameters:
bgColor - the color to become this window's background color.
Throws:
IllegalComponentStateException - if the alpha value of the given
     background color is less than 1.0f and the window is decorated
IllegalComponentStateException - if the alpha value of the given
     background color is less than 1.0f and the window is in
     full-screen mode
UnsupportedOperationException - if the alpha value of the given
     background color is less than 1.0f and PERPIXEL_TRANSLUCENT translucency is not supported
See Also:
getBackground(), 
isOpaque(), 
setOpacity(float), 
setShape(Shape), 
Frame.isUndecorated(), 
Dialog.isUndecorated(), 
GraphicsDevice.WindowTranslucency, 
GraphicsDevice.isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency), 
GraphicsConfiguration.isTranslucencyCapable()


"
97,Window,13,void setForeground(Color c),False,,NULL
97,Window,14,void setFont(Font f),False,,NULL
97,Window,15,void setCursor(Cursor c),True,Set the cursor image to a specified cursor.,"

setCursor
public void setCursor(Cursor cursor)
Set the cursor image to a specified cursor.
 
 The method may have no visual effect if the Java platform
 implementation and/or the native system do not support
 changing the mouse cursor shape.

Overrides:
setCursor in class Component
Parameters:
cursor - One of the constants defined
            by the Cursor class. If this parameter is null
            then the cursor for this window will be set to the type
            Cursor.DEFAULT_CURSOR.
Since:
JDK1.1
See Also:
Component.getCursor(), 
Cursor


"
97,Window,16,void setIconImages(List<Image> images),False,,NULL
97,Window,17,void setAlwaysOnTop(boolean b),True,Sets whether this window should always be above other windows.,"

setAlwaysOnTop
public final void setAlwaysOnTop(boolean alwaysOnTop)
                          throws SecurityException
Sets whether this window should always be above other windows.  If
 there are multiple always-on-top windows, their relative order is
 unspecified and platform dependent.
 
 If some other window is already always-on-top then the
 relative order between these windows is unspecified (depends on
 platform).  No window can be brought to be over the always-on-top
 window except maybe another always-on-top window.
 
 All windows owned by an always-on-top window inherit this state and
 automatically become always-on-top.  If a window ceases to be
 always-on-top, the windows that it owns will no longer be
 always-on-top.  When an always-on-top window is sent toBack, its always-on-top state is set to false.

  When this method is called on a window with a value of
 true, and the window is visible and the platform
 supports always-on-top for this window, the window is immediately
 brought forward, ""sticking"" it in the top-most position. If the
 window isn`t currently visible, this method sets the always-on-top
 state to true but does not bring the window forward.
 When the window is later shown, it will be always-on-top.

  When this method is called on a window with a value of
 false the always-on-top state is set to normal. It may also
 cause an unspecified, platform-dependent change in the z-order of
 top-level windows, but other always-on-top windows will remain in
 top-most position. Calling this method with a value of false
 on a window that has a normal state has no effect.

 Note: some platforms might not support always-on-top
 windows.  To detect if always-on-top windows are supported by the
 current platform, use Toolkit.isAlwaysOnTopSupported() and
 isAlwaysOnTopSupported().  If always-on-top mode
 isn't supported for this window or this window's toolkit does not
 support always-on-top windows, calling this method has no effect.
 
 If a SecurityManager is installed, the calling thread must be
 granted the AWTPermission ""setWindowAlwaysOnTop"" in
 order to set the value of this property. If this
 permission is not granted, this method will throw a
 SecurityException, and the current value of the property will
 be left unchanged.

Parameters:
alwaysOnTop - true if the window should always be above other
        windows
Throws:
SecurityException - if the calling thread does not have
         permission to set the value of always-on-top property
Since:
1.5
See Also:
isAlwaysOnTop(), 
toFront(), 
toBack(), 
AWTPermission, 
isAlwaysOnTopSupported(), 
getToolkit(), 
Toolkit.isAlwaysOnTopSupported()


"
97,Window,18,void setOpacity(float opacity),True,Sets the opacity of the window.,"

setOpacity
public void setOpacity(float opacity)
Sets the opacity of the window.
 
 The opacity value is in the range [0..1]. Note that setting the opacity
 level of 0 may or may not disable the mouse event handling on this
 window. This is a platform-dependent behavior.
 
 The following conditions must be met in order to set the opacity value
 less than 1.0f:
 
The TRANSLUCENT
 translucency must be supported by the underlying system
 The window must be undecorated (see Frame.setUndecorated(boolean)
 and Dialog.setUndecorated(boolean))
 The window must not be in full-screen mode (see GraphicsDevice.setFullScreenWindow(Window))
 

 If the requested opacity value is less than 1.0f, and any of the
 above conditions are not met, the window opacity will not change,
 and the IllegalComponentStateException will be thrown.
 
 The translucency levels of individual pixels may also be effected by the
 alpha component of their color (see setBackground(Color)) and the
 current shape of this window (see setShape(Shape)).

Parameters:
opacity - the opacity level to set to the window
Throws:
IllegalArgumentException - if the opacity is out of the range
     [0..1]
IllegalComponentStateException - if the window is decorated and
     the opacity is less than 1.0f
IllegalComponentStateException - if the window is in full screen
     mode, and the opacity is less than 1.0f
UnsupportedOperationException - if the GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT
     translucency is not supported and the opacity is less than
     1.0f
Since:
1.7
See Also:
getOpacity(), 
setBackground(Color), 
setShape(Shape), 
Frame.isUndecorated(), 
Dialog.isUndecorated(), 
GraphicsDevice.WindowTranslucency, 
GraphicsDevice.isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)


"
97,Window,19,void setFocusableWindowState(boolean focusable),True,Sets whether this Window can become the focused Window if it meets the other requirements outlined in isFocusableWindow.,"

setFocusableWindowState
public void setFocusableWindowState(boolean focusableWindowState)
Sets whether this Window can become the focused Window if it meets
 the other requirements outlined in isFocusableWindow. If
 this Window's focusable Window state is set to false, then
 isFocusableWindow will return false. If this
 Window's focusable Window state is set to true, then
 isFocusableWindow may return true or
 false depending upon the other requirements which must be
 met in order for a Window to be focusable.
 
 Setting a Window's focusability state to false is the
 standard mechanism for an application to identify to the AWT a Window
 which will be used as a floating palette or toolbar, and thus should be
 a non-focusable Window.

 Setting the focusability state on a visible Window
 can have a delayed effect on some platforms  the actual
 change may happen only when the Window becomes
 hidden and then visible again.  To ensure consistent behavior
 across platforms, set the Window's focusable state
 when the Window is invisible and then show it.

Parameters:
focusableWindowState - whether this Window can be the focused
        Window
Since:
1.4
See Also:
isFocusableWindow(), 
getFocusableWindowState(), 
isShowing(), 
Component.setFocusable(boolean)


"
97,Window,20,"void setFocusableWindowState(boolean focusable, Rectangle bounds)",False,,NULL
97,Window,21,void setMinimumSize(Dimension size),True,Sets the minimum size of this window to a constant value.,"

setMinimumSize
public void setMinimumSize(Dimension minimumSize)
Sets the minimum size of this window to a constant
 value.  Subsequent calls to getMinimumSize
 will always return this value. If current window's
 size is less than minimumSize the size of the
 window is automatically enlarged to honor the minimum size.
 
 If the setSize or setBounds methods
 are called afterwards with a width or height less than
 that was specified by the setMinimumSize method
 the window is automatically enlarged to meet
 the minimumSize value. The minimumSize
 value also affects the behaviour of the pack method.
 
 The default behavior is restored by setting the minimum size
 parameter to the null value.
 
 Resizing operation may be restricted if the user tries
 to resize window below the minimumSize value.
 This behaviour is platform-dependent.

Overrides:
setMinimumSize in class Component
Parameters:
minimumSize - the new minimum size of this window
Since:
1.6
See Also:
Component.setMinimumSize(java.awt.Dimension), 
Container.getMinimumSize(), 
Component.isMinimumSizeSet(), 
setSize(Dimension), 
pack()


"
97,Window,22,void setMaximumSize(Dimension size),False,,NULL
97,Window,23,void setPreferredSize(Dimension size),False,,NULL
97,Window,24,void setResizable(boolean resizable),False,,NULL
97,Window,25,void setLayout(LayoutManager mgr),False,,NULL
97,Window,26,"void setLayout(LayoutManager mgr, Dimension preferredSize)",False,,NULL
97,Window,27,"void setLayout(LayoutManager mgr, Insets insets)",False,,NULL
97,Window,28,"void setLayout(LayoutManager mgr, Dimension preferredSize, Insets insets)",False,,NULL
97,Window,29,"void setLayout(LayoutManager mgr, Dimension preferredSize, Insets insets, int alignment)",False,,NULL
97,Window,30,"void setLayout(LayoutManager mgr, Dimension preferredSize, Insets insets, int alignment, boolean useDefaults)",False,,NULL
97,Window,31,"void setLayout(LayoutManager mgr, Dimension preferredSize, Insets insets, int alignment, boolean useDefaults, boolean useParentProperties)",False,,NULL
97,Window,32,"void setLayout(LayoutManager mgr, Dimension preferredSize, Insets insets, int alignment, boolean useDefaults, boolean useParentProperties, boolean useParentPropertiesForSizing)",False,,NULL
97,Window,33,"void setLayout(LayoutManager mgr, Dimension preferredSize, Insets insets, int alignment, boolean useDefaults, boolean useParentProperties, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing)",False,,NULL
97,Window,34,"void setLayout(LayoutManager mgr, Dimension preferredSize, Insets insets, int alignment, boolean useDefaults, boolean useParentProperties, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing)",False,,NULL
97,Window,35,"void setLayout(LayoutManager mgr, Dimension preferredSize, Insets insets, int alignment, boolean useDefaults, boolean useParentProperties, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing)",False,,NULL
97,Window,36,"void setLayout(LayoutManager mgr, Dimension preferredSize, Insets insets, int alignment, boolean useDefaults, boolean useParentProperties, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing)",False,,NULL
97,Window,37,"void setLayout(LayoutManager mgr, Dimension preferredSize, Insets insets, int alignment, boolean useDefaults, boolean useParentProperties, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing)",False,,NULL
97,Window,38,"void setLayout(LayoutManager mgr, Dimension preferredSize, Insets insets, int alignment, boolean useDefaults, boolean useParentProperties, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing, boolean useParentPropertiesForSizing)",False,,NULL
