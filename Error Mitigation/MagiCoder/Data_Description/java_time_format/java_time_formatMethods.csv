ClassName,Method,Return Type,Description,Full Description
DateTimeFormatter,format(TemporalAccessor temporal),String,Formats a date-time object using this formatter.,"

format
public String format(TemporalAccessor temporal)
Formats a date-time object using this formatter.
 
 This formats the date-time to a String using the rules of the formatter.

Parameters:
temporal - the temporal object to format, not null
Returns:
the formatted string, not null
Throws:
DateTimeException - if an error occurs during formatting


"
DateTimeFormatter,"formatTo(TemporalAccessor temporal, Appendable appendable)",void,Formats a date-time object to an Appendable using this formatter.,"

formatTo
public void formatTo(TemporalAccessor temporal,
                     Appendable appendable)
Formats a date-time object to an Appendable using this formatter.
 
 This outputs the formatted date-time to the specified destination.
 Appendable is a general purpose interface that is implemented by all
 key character output classes including StringBuffer, StringBuilder,
 PrintStream and Writer.
 
 Although Appendable methods throw an IOException, this method does not.
 Instead, any IOException is wrapped in a runtime exception.

Parameters:
temporal - the temporal object to format, not null
appendable - the appendable to format to, not null
Throws:
DateTimeException - if an error occurs during formatting


"
DateTimeFormatter,getChronology(),Chronology,Gets the overriding chronology to be used during formatting.,"

getChronology
public Chronology getChronology()
Gets the overriding chronology to be used during formatting.
 
 This returns the override chronology, used to convert dates.
 By default, a formatter has no override chronology, returning null.
 See withChronology(Chronology) for more details on overriding.

Returns:
the override chronology of this formatter, null if no override


"
DateTimeFormatter,getDecimalStyle(),DecimalStyle,Gets the DecimalStyle to be used during formatting.,"

getDecimalStyle
public DecimalStyle getDecimalStyle()
Gets the DecimalStyle to be used during formatting.

Returns:
the locale of this formatter, not null


"
DateTimeFormatter,getLocale(),Locale,Gets the locale to be used during formatting.,"

getLocale
public Locale getLocale()
Gets the locale to be used during formatting.
 
 This is used to lookup any part of the formatter needing specific
 localization, such as the text or localized pattern.

Returns:
the locale of this formatter, not null


"
DateTimeFormatter,getResolverFields(),Set<TemporalField>,Gets the resolver fields to use during parsing.,"

getResolverFields
public Set<TemporalField> getResolverFields()
Gets the resolver fields to use during parsing.
 
 This returns the resolver fields, used during the second phase of parsing
 when fields are resolved into dates and times.
 By default, a formatter has no resolver fields, and thus returns null.
 See withResolverFields(Set) for more details.

Returns:
the immutable set of resolver fields of this formatter, null if no fields


"
DateTimeFormatter,getResolverStyle(),ResolverStyle,Gets the resolver style to use during parsing.,"

getResolverStyle
public ResolverStyle getResolverStyle()
Gets the resolver style to use during parsing.
 
 This returns the resolver style, used during the second phase of parsing
 when fields are resolved into dates and times.
 By default, a formatter has the SMART resolver style.
 See withResolverStyle(ResolverStyle) for more details.

Returns:
the resolver style of this formatter, not null


"
DateTimeFormatter,getZone(),ZoneId,Gets the overriding zone to be used during formatting.,"

getZone
public ZoneId getZone()
Gets the overriding zone to be used during formatting.
 
 This returns the override zone, used to convert instants.
 By default, a formatter has no override zone, returning null.
 See withZone(ZoneId) for more details on overriding.

Returns:
the override zone of this formatter, null if no override


"
DateTimeFormatter,ofLocalizedDate(FormatStyle dateStyle),static DateTimeFormatter,Returns a locale specific date format for the ISO chronology.,"

ofLocalizedDate
public static DateTimeFormatter ofLocalizedDate(FormatStyle dateStyle)
Returns a locale specific date format for the ISO chronology.
 
 This returns a formatter that will format or parse a date.
 The exact format pattern used varies by locale.
 
 The locale is determined from the formatter. The formatter returned directly by
 this method will use the default FORMAT locale.
 The locale can be controlled using withLocale(Locale)
 on the result of this method.
 
 Note that the localized pattern is looked up lazily.
 This DateTimeFormatter holds the style required and the locale,
 looking up the pattern required on demand.
 
 The returned formatter has a chronology of ISO set to ensure dates in
 other calendar systems are correctly converted.
 It has no override zone and uses the SMART resolver style.

Parameters:
dateStyle - the formatter style to obtain, not null
Returns:
the date formatter, not null


"
DateTimeFormatter,ofLocalizedDateTime(FormatStyle dateTimeStyle),static DateTimeFormatter,Returns a locale specific date-time formatter for the ISO chronology.,"

ofLocalizedDateTime
public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateTimeStyle)
Returns a locale specific date-time formatter for the ISO chronology.
 
 This returns a formatter that will format or parse a date-time.
 The exact format pattern used varies by locale.
 
 The locale is determined from the formatter. The formatter returned directly by
 this method will use the default FORMAT locale.
 The locale can be controlled using withLocale(Locale)
 on the result of this method.
 
 Note that the localized pattern is looked up lazily.
 This DateTimeFormatter holds the style required and the locale,
 looking up the pattern required on demand.
 
 The returned formatter has a chronology of ISO set to ensure dates in
 other calendar systems are correctly converted.
 It has no override zone and uses the SMART resolver style.

Parameters:
dateTimeStyle - the formatter style to obtain, not null
Returns:
the date-time formatter, not null


"
DateTimeFormatter,"ofLocalizedDateTime(FormatStyle dateStyle, FormatStyle timeStyle)",static DateTimeFormatter,Returns a locale specific date and time format for the ISO chronology.,"

ofLocalizedDateTime
public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateStyle,
                                                    FormatStyle timeStyle)
Returns a locale specific date and time format for the ISO chronology.
 
 This returns a formatter that will format or parse a date-time.
 The exact format pattern used varies by locale.
 
 The locale is determined from the formatter. The formatter returned directly by
 this method will use the default FORMAT locale.
 The locale can be controlled using withLocale(Locale)
 on the result of this method.
 
 Note that the localized pattern is looked up lazily.
 This DateTimeFormatter holds the style required and the locale,
 looking up the pattern required on demand.
 
 The returned formatter has a chronology of ISO set to ensure dates in
 other calendar systems are correctly converted.
 It has no override zone and uses the SMART resolver style.

Parameters:
dateStyle - the date formatter style to obtain, not null
timeStyle - the time formatter style to obtain, not null
Returns:
the date, time or date-time formatter, not null


"
DateTimeFormatter,ofLocalizedTime(FormatStyle timeStyle),static DateTimeFormatter,Returns a locale specific time format for the ISO chronology.,"

ofLocalizedTime
public static DateTimeFormatter ofLocalizedTime(FormatStyle timeStyle)
Returns a locale specific time format for the ISO chronology.
 
 This returns a formatter that will format or parse a time.
 The exact format pattern used varies by locale.
 
 The locale is determined from the formatter. The formatter returned directly by
 this method will use the default FORMAT locale.
 The locale can be controlled using withLocale(Locale)
 on the result of this method.
 
 Note that the localized pattern is looked up lazily.
 This DateTimeFormatter holds the style required and the locale,
 looking up the pattern required on demand.
 
 The returned formatter has a chronology of ISO set to ensure dates in
 other calendar systems are correctly converted.
 It has no override zone and uses the SMART resolver style.

Parameters:
timeStyle - the formatter style to obtain, not null
Returns:
the time formatter, not null


"
DateTimeFormatter,ofPattern(String pattern),static DateTimeFormatter,Creates a formatter using the specified pattern.,"

ofPattern
public static DateTimeFormatter ofPattern(String pattern)
Creates a formatter using the specified pattern.
 
 This method will create a formatter based on a simple
 pattern of letters and symbols
 as described in the class documentation.
 For example, d MMM uuuu will format 2011-12-03 as '3 Dec 2011'.
 
 The formatter will use the default FORMAT locale.
 This can be changed using withLocale(Locale) on the returned formatter
 Alternatively use the ofPattern(String, Locale) variant of this method.
 
 The returned formatter has no override chronology or zone.
 It uses SMART resolver style.

Parameters:
pattern - the pattern to use, not null
Returns:
the formatter based on the pattern, not null
Throws:
IllegalArgumentException - if the pattern is invalid
See Also:
DateTimeFormatterBuilder.appendPattern(String)


"
DateTimeFormatter,"ofPattern(String pattern, Locale locale)",static DateTimeFormatter,Creates a formatter using the specified pattern and locale.,"

ofPattern
public static DateTimeFormatter ofPattern(String pattern,
                                          Locale locale)
Creates a formatter using the specified pattern and locale.
 
 This method will create a formatter based on a simple
 pattern of letters and symbols
 as described in the class documentation.
 For example, d MMM uuuu will format 2011-12-03 as '3 Dec 2011'.
 
 The formatter will use the specified locale.
 This can be changed using withLocale(Locale) on the returned formatter
 
 The returned formatter has no override chronology or zone.
 It uses SMART resolver style.

Parameters:
pattern - the pattern to use, not null
locale - the locale to use, not null
Returns:
the formatter based on the pattern, not null
Throws:
IllegalArgumentException - if the pattern is invalid
See Also:
DateTimeFormatterBuilder.appendPattern(String)


"
DateTimeFormatter,parse(CharSequence text),TemporalAccessor,Fully parses the text producing a temporal object.,"

parse
public TemporalAccessor parse(CharSequence text)
Fully parses the text producing a temporal object.
 
 This parses the entire text producing a temporal object.
 It is typically more useful to use parse(CharSequence, TemporalQuery).
 The result of this method is TemporalAccessor which has been resolved,
 applying basic validation checks to help ensure a valid date-time.
 
 If the parse completes without reading the entire length of the text,
 or a problem occurs during parsing or merging, then an exception is thrown.

Parameters:
text - the text to parse, not null
Returns:
the parsed temporal object, not null
Throws:
DateTimeParseException - if unable to parse the requested result


"
DateTimeFormatter,"parse(CharSequence text, ParsePosition position)",TemporalAccessor,"Parses the text using this formatter, providing control over the text position.","

parse
public TemporalAccessor parse(CharSequence text,
                              ParsePosition position)
Parses the text using this formatter, providing control over the text position.
 
 This parses the text without requiring the parse to start from the beginning
 of the string or finish at the end.
 The result of this method is TemporalAccessor which has been resolved,
 applying basic validation checks to help ensure a valid date-time.
 
 The text will be parsed from the specified start ParsePosition.
 The entire length of the text does not have to be parsed, the ParsePosition
 will be updated with the index at the end of parsing.
 
 The operation of this method is slightly different to similar methods using
 ParsePosition on java.text.Format. That class will return
 errors using the error index on the ParsePosition. By contrast, this
 method will throw a DateTimeParseException if an error occurs, with
 the exception containing the error index.
 This change in behavior is necessary due to the increased complexity of
 parsing and resolving dates/times in this API.
 
 If the formatter parses the same field more than once with different values,
 the result will be an error.

Parameters:
text - the text to parse, not null
position - the position to parse from, updated with length parsed
  and the index of any error, not null
Returns:
the parsed temporal object, not null
Throws:
DateTimeParseException - if unable to parse the requested result
IndexOutOfBoundsException - if the position is invalid


"
DateTimeFormatter,"parse(CharSequence text, TemporalQuery<T> query)",<T> T,Fully parses the text producing an object of the specified type.,"

parse
public <T> T parse(CharSequence text,
                   TemporalQuery<T> query)
Fully parses the text producing an object of the specified type.
 
 Most applications should use this method for parsing.
 It parses the entire text to produce the required date-time.
 The query is typically a method reference to a from(TemporalAccessor) method.
 For example:
 
  LocalDateTime dt = parser.parse(str, LocalDateTime::from);
 
 If the parse completes without reading the entire length of the text,
 or a problem occurs during parsing or merging, then an exception is thrown.

Type Parameters:
T - the type of the parsed date-time
Parameters:
text - the text to parse, not null
query - the query defining the type to parse to, not null
Returns:
the parsed date-time, not null
Throws:
DateTimeParseException - if unable to parse the requested result


"
DateTimeFormatter,"parseBest(CharSequence text, TemporalQuery<?>... queries)",TemporalAccessor,Fully parses the text producing an object of one of the specified types.,"

parseBest
public TemporalAccessor parseBest(CharSequence text,
                                  TemporalQuery<?>... queries)
Fully parses the text producing an object of one of the specified types.
 
 This parse method is convenient for use when the parser can handle optional elements.
 For example, a pattern of 'uuuu-MM-dd HH.mm[ VV]' can be fully parsed to a ZonedDateTime,
 or partially parsed to a LocalDateTime.
 The queries must be specified in order, starting from the best matching full-parse option
 and ending with the worst matching minimal parse option.
 The query is typically a method reference to a from(TemporalAccessor) method.
 
 The result is associated with the first type that successfully parses.
 Normally, applications will use instanceof to check the result.
 For example:
 
  TemporalAccessor dt = parser.parseBest(str, ZonedDateTime::from, LocalDateTime::from);
  if (dt instanceof ZonedDateTime) {
   ...
  } else {
   ...
  }
 
 If the parse completes without reading the entire length of the text,
 or a problem occurs during parsing or merging, then an exception is thrown.

Parameters:
text - the text to parse, not null
queries - the queries defining the types to attempt to parse to,
  must implement TemporalAccessor, not null
Returns:
the parsed date-time, not null
Throws:
IllegalArgumentException - if less than 2 types are specified
DateTimeParseException - if unable to parse the requested result


"
DateTimeFormatter,parsedExcessDays(),static TemporalQuery<Period>,A query that provides access to the excess days that were parsed.,"

parsedExcessDays
public static final TemporalQuery<Period> parsedExcessDays()
A query that provides access to the excess days that were parsed.
 
 This returns a singleton query that provides
 access to additional information from the parse. The query always returns
 a non-null period, with a zero period returned instead of null.
 
 There are two situations where this query may return a non-zero period.
 
If the ResolverStyle is LENIENT and a time is parsed
  without a date, then the complete result of the parse consists of a
  LocalTime and an excess Period in days.

 If the ResolverStyle is SMART and a time is parsed
  without a date where the time is 24:00:00, then the complete result of
  the parse consists of a LocalTime of 00:00:00 and an excess
  Period of one day.
 

 In both cases, if a complete ChronoLocalDateTime or Instant
 is parsed, then the excess days are added to the date part.
 As a result, this query will return a zero period.
 
 The SMART behaviour handles the common ""end of day"" 24:00 value.
 Processing in LENIENT mode also produces the same result:
 
  Text to parse        Parsed object                         Excess days
  ""2012-12-03T00:00""   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO
  ""2012-12-03T24:00""   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO
  ""00:00""              LocalTime.of(0, 0)                    ZERO
  ""24:00""              LocalTime.of(0, 0)                    Period.ofDays(1)
 
 The query can be used as follows:
 
  TemporalAccessor parsed = formatter.parse(str);
  LocalTime time = parsed.query(LocalTime::from);
  Period extraDays = parsed.query(DateTimeFormatter.parsedExcessDays());
 

Returns:
a query that provides access to the excess days that were parsed


"
DateTimeFormatter,parsedLeapSecond(),static TemporalQuery<Boolean>,A query that provides access to whether a leap-second was parsed.,"

parsedLeapSecond
public static final TemporalQuery<Boolean> parsedLeapSecond()
A query that provides access to whether a leap-second was parsed.
 
 This returns a singleton query that provides
 access to additional information from the parse. The query always returns
 a non-null boolean, true if parsing saw a leap-second, false if not.
 
 Instant parsing handles the special ""leap second"" time of '23:59:60'.
 Leap seconds occur at '23:59:60' in the UTC time-zone, but at other
 local times in different time-zones. To avoid this potential ambiguity,
 the handling of leap-seconds is limited to
 DateTimeFormatterBuilder.appendInstant(), as that method
 always parses the instant with the UTC zone offset.
 
 If the time '23:59:60' is received, then a simple conversion is applied,
 replacing the second-of-minute of 60 with 59. This query can be used
 on the parse result to determine if the leap-second adjustment was made.
 The query will return true if it did adjust to remove the
 leap-second, and false if not. Note that applying a leap-second
 smoothing mechanism, such as UTC-SLS, is the responsibility of the
 application, as follows:
 
  TemporalAccessor parsed = formatter.parse(str);
  Instant instant = parsed.query(Instant::from);
  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {
    // validate leap-second is correct and apply correct smoothing
  }
 

Returns:
a query that provides access to whether a leap-second was parsed


"
DateTimeFormatter,"parseUnresolved(CharSequence text, ParsePosition position)",TemporalAccessor,"Parses the text using this formatter, without resolving the result, intended for advanced use cases.","

parseUnresolved
public TemporalAccessor parseUnresolved(CharSequence text,
                                        ParsePosition position)
Parses the text using this formatter, without resolving the result, intended
 for advanced use cases.
 
 Parsing is implemented as a two-phase operation.
 First, the text is parsed using the layout defined by the formatter, producing
 a Map of field to value, a ZoneId and a Chronology.
 Second, the parsed data is resolved, by validating, combining and
 simplifying the various fields into more useful ones.
 This method performs the parsing stage but not the resolving stage.
 
 The result of this method is TemporalAccessor which represents the
 data as seen in the input. Values are not validated, thus parsing a date string
 of '2012-00-65' would result in a temporal with three fields - year of '2012',
 month of '0' and day-of-month of '65'.
 
 The text will be parsed from the specified start ParsePosition.
 The entire length of the text does not have to be parsed, the ParsePosition
 will be updated with the index at the end of parsing.
 
 Errors are returned using the error index field of the ParsePosition
 instead of DateTimeParseException.
 The returned error index will be set to an index indicative of the error.
 Callers must check for errors before using the result.
 
 If the formatter parses the same field more than once with different values,
 the result will be an error.
 
 This method is intended for advanced use cases that need access to the
 internal state during parsing. Typical application code should use
 parse(CharSequence, TemporalQuery) or the parse method on the target type.

Parameters:
text - the text to parse, not null
position - the position to parse from, updated with length parsed
  and the index of any error, not null
Returns:
the parsed text, null if the parse results in an error
Throws:
DateTimeException - if some problem occurs during parsing
IndexOutOfBoundsException - if the position is invalid


"
DateTimeFormatter,toFormat(),Format,Returns this formatter as a java.text.Format instance.,"

toFormat
public Format toFormat()
Returns this formatter as a java.text.Format instance.
 
 The returned Format instance will format any TemporalAccessor
 and parses to a resolved TemporalAccessor.
 
 Exceptions will follow the definitions of Format, see those methods
 for details about IllegalArgumentException during formatting and
 ParseException or null during parsing.
 The format does not support attributing of the returned format string.

Returns:
this formatter as a classic format instance, not null


"
DateTimeFormatter,toFormat(TemporalQuery<?> parseQuery),Format,Returns this formatter as a java.text.Format instance that will parse using the specified query.,"

toFormat
public Format toFormat(TemporalQuery<?> parseQuery)
Returns this formatter as a java.text.Format instance that will
 parse using the specified query.
 
 The returned Format instance will format any TemporalAccessor
 and parses to the type specified.
 The type must be one that is supported by parse(java.lang.CharSequence).
 
 Exceptions will follow the definitions of Format, see those methods
 for details about IllegalArgumentException during formatting and
 ParseException or null during parsing.
 The format does not support attributing of the returned format string.

Parameters:
parseQuery - the query defining the type to parse to, not null
Returns:
this formatter as a classic format instance, not null


"
DateTimeFormatter,toString(),String,Returns a description of the underlying formatters.,"

toString
public String toString()
Returns a description of the underlying formatters.

Overrides:
toString in class Object
Returns:
a description of this formatter, not null


"
DateTimeFormatter,withChronology(Chronology chrono),DateTimeFormatter,Returns a copy of this formatter with a new override chronology.,"

withChronology
public DateTimeFormatter withChronology(Chronology chrono)
Returns a copy of this formatter with a new override chronology.
 
 This returns a formatter with similar state to this formatter but
 with the override chronology set.
 By default, a formatter has no override chronology, returning null.
 
 If an override is added, then any date that is formatted or parsed will be affected.
 
 When formatting, if the temporal object contains a date, then it will
 be converted to a date in the override chronology.
 Whether the temporal contains a date is determined by querying the
 EPOCH_DAY field.
 Any time or zone will be retained unaltered unless overridden.
 
 If the temporal object does not contain a date, but does contain one
 or more ChronoField date fields, then a DateTimeException
 is thrown. In all other cases, the override chronology is added to the temporal,
 replacing any previous chronology, but without changing the date/time.
 
 When parsing, there are two distinct cases to consider.
 If a chronology has been parsed directly from the text, perhaps because
 DateTimeFormatterBuilder.appendChronologyId() was used, then
 this override chronology has no effect.
 If no zone has been parsed, then this override chronology will be used
 to interpret the ChronoField values into a date according to the
 date resolving rules of the chronology.
 
 This instance is immutable and unaffected by this method call.

Parameters:
chrono - the new chronology, null if no override
Returns:
a formatter based on this formatter with the requested override chronology, not null


"
DateTimeFormatter,withDecimalStyle(DecimalStyle decimalStyle),DateTimeFormatter,Returns a copy of this formatter with a new DecimalStyle.,"

withDecimalStyle
public DateTimeFormatter withDecimalStyle(DecimalStyle decimalStyle)
Returns a copy of this formatter with a new DecimalStyle.
 
 This instance is immutable and unaffected by this method call.

Parameters:
decimalStyle - the new DecimalStyle, not null
Returns:
a formatter based on this formatter with the requested DecimalStyle, not null


"
DateTimeFormatter,withLocale(Locale locale),DateTimeFormatter,Returns a copy of this formatter with a new locale.,"

withLocale
public DateTimeFormatter withLocale(Locale locale)
Returns a copy of this formatter with a new locale.
 
 This is used to lookup any part of the formatter needing specific
 localization, such as the text or localized pattern.
 
 This instance is immutable and unaffected by this method call.

Parameters:
locale - the new locale, not null
Returns:
a formatter based on this formatter with the requested locale, not null


"
DateTimeFormatter,withResolverFields(Set<TemporalField> resolverFields),DateTimeFormatter,Returns a copy of this formatter with a new set of resolver fields.,"

withResolverFields
public DateTimeFormatter withResolverFields(Set<TemporalField> resolverFields)
Returns a copy of this formatter with a new set of resolver fields.
 
 This returns a formatter with similar state to this formatter but with
 the resolver fields set. By default, a formatter has no resolver fields.
 
 Changing the resolver fields only has an effect during parsing.
 Parsing a text string occurs in two phases.
 Phase 1 is a basic text parse according to the fields added to the builder.
 Phase 2 resolves the parsed field-value pairs into date and/or time objects.
 The resolver fields are used to filter the field-value pairs between phase 1 and 2.
 
 This can be used to select between two or more ways that a date or time might
 be resolved. For example, if the formatter consists of year, month, day-of-month
 and day-of-year, then there are two ways to resolve a date.
 Calling this method with the arguments YEAR and
 DAY_OF_YEAR will ensure that the date is
 resolved using the year and day-of-year, effectively meaning that the month
 and day-of-month are ignored during the resolving phase.
 
 In a similar manner, this method can be used to ignore secondary fields that
 would otherwise be cross-checked. For example, if the formatter consists of year,
 month, day-of-month and day-of-week, then there is only one way to resolve a
 date, but the parsed value for day-of-week will be cross-checked against the
 resolved date. Calling this method with the arguments YEAR,
 MONTH_OF_YEAR and
 DAY_OF_MONTH will ensure that the date is
 resolved correctly, but without any cross-check for the day-of-week.
 
 In implementation terms, this method behaves as follows. The result of the
 parsing phase can be considered to be a map of field to value. The behavior
 of this method is to cause that map to be filtered between phase 1 and 2,
 removing all fields other than those specified as arguments to this method.
 
 This instance is immutable and unaffected by this method call.

Parameters:
resolverFields - the new set of resolver fields, null if no fields
Returns:
a formatter based on this formatter with the requested resolver style, not null


"
DateTimeFormatter,withResolverFields(TemporalField... resolverFields),DateTimeFormatter,Returns a copy of this formatter with a new set of resolver fields.,"

withResolverFields
public DateTimeFormatter withResolverFields(TemporalField... resolverFields)
Returns a copy of this formatter with a new set of resolver fields.
 
 This returns a formatter with similar state to this formatter but with
 the resolver fields set. By default, a formatter has no resolver fields.
 
 Changing the resolver fields only has an effect during parsing.
 Parsing a text string occurs in two phases.
 Phase 1 is a basic text parse according to the fields added to the builder.
 Phase 2 resolves the parsed field-value pairs into date and/or time objects.
 The resolver fields are used to filter the field-value pairs between phase 1 and 2.
 
 This can be used to select between two or more ways that a date or time might
 be resolved. For example, if the formatter consists of year, month, day-of-month
 and day-of-year, then there are two ways to resolve a date.
 Calling this method with the arguments YEAR and
 DAY_OF_YEAR will ensure that the date is
 resolved using the year and day-of-year, effectively meaning that the month
 and day-of-month are ignored during the resolving phase.
 
 In a similar manner, this method can be used to ignore secondary fields that
 would otherwise be cross-checked. For example, if the formatter consists of year,
 month, day-of-month and day-of-week, then there is only one way to resolve a
 date, but the parsed value for day-of-week will be cross-checked against the
 resolved date. Calling this method with the arguments YEAR,
 MONTH_OF_YEAR and
 DAY_OF_MONTH will ensure that the date is
 resolved correctly, but without any cross-check for the day-of-week.
 
 In implementation terms, this method behaves as follows. The result of the
 parsing phase can be considered to be a map of field to value. The behavior
 of this method is to cause that map to be filtered between phase 1 and 2,
 removing all fields other than those specified as arguments to this method.
 
 This instance is immutable and unaffected by this method call.

Parameters:
resolverFields - the new set of resolver fields, null if no fields
Returns:
a formatter based on this formatter with the requested resolver style, not null


"
DateTimeFormatter,withResolverStyle(ResolverStyle resolverStyle),DateTimeFormatter,Returns a copy of this formatter with a new resolver style.,"

withResolverStyle
public DateTimeFormatter withResolverStyle(ResolverStyle resolverStyle)
Returns a copy of this formatter with a new resolver style.
 
 This returns a formatter with similar state to this formatter but
 with the resolver style set. By default, a formatter has the
 SMART resolver style.
 
 Changing the resolver style only has an effect during parsing.
 Parsing a text string occurs in two phases.
 Phase 1 is a basic text parse according to the fields added to the builder.
 Phase 2 resolves the parsed field-value pairs into date and/or time objects.
 The resolver style is used to control how phase 2, resolving, happens.
 See ResolverStyle for more information on the options available.
 
 This instance is immutable and unaffected by this method call.

Parameters:
resolverStyle - the new resolver style, not null
Returns:
a formatter based on this formatter with the requested resolver style, not null


"
DateTimeFormatter,withZone(ZoneId zone),DateTimeFormatter,Returns a copy of this formatter with a new override zone.,"

withZone
public DateTimeFormatter withZone(ZoneId zone)
Returns a copy of this formatter with a new override zone.
 
 This returns a formatter with similar state to this formatter but
 with the override zone set.
 By default, a formatter has no override zone, returning null.
 
 If an override is added, then any instant that is formatted or parsed will be affected.
 
 When formatting, if the temporal object contains an instant, then it will
 be converted to a zoned date-time using the override zone.
 Whether the temporal is an instant is determined by querying the
 INSTANT_SECONDS field.
 If the input has a chronology then it will be retained unless overridden.
 If the input does not have a chronology, such as Instant, then
 the ISO chronology will be used.
 
 If the temporal object does not contain an instant, but does contain
 an offset then an additional check is made. If the normalized override
 zone is an offset that differs from the offset of the temporal, then
 a DateTimeException is thrown. In all other cases, the override
 zone is added to the temporal, replacing any previous zone, but without
 changing the date/time.
 
 When parsing, there are two distinct cases to consider.
 If a zone has been parsed directly from the text, perhaps because
 DateTimeFormatterBuilder.appendZoneId() was used, then
 this override zone has no effect.
 If no zone has been parsed, then this override zone will be included in
 the result of the parse where it can be used to build instants and date-times.
 
 This instance is immutable and unaffected by this method call.

Parameters:
zone - the new override zone, null if no override
Returns:
a formatter based on this formatter with the requested override zone, not null


"
DateTimeFormatterBuilder,append(DateTimeFormatter formatter),DateTimeFormatterBuilder,Appends all the elements of a formatter to the builder.,"

append
public DateTimeFormatterBuilder append(DateTimeFormatter formatter)
Appends all the elements of a formatter to the builder.
 
 This method has the same effect as appending each of the constituent
 parts of the formatter directly to this builder.

Parameters:
formatter - the formatter to add, not null
Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,appendChronologyId(),DateTimeFormatterBuilder,"Appends the chronology ID, such as 'ISO' or 'ThaiBuddhist', to the formatter.","

appendChronologyId
public DateTimeFormatterBuilder appendChronologyId()
Appends the chronology ID, such as 'ISO' or 'ThaiBuddhist', to the formatter.
 
 This appends an instruction to format/parse the chronology ID to the builder.
 
 During formatting, the chronology is obtained using a mechanism equivalent
 to querying the temporal with TemporalQueries.chronology().
 It will be printed using the result of Chronology.getId().
 If the chronology cannot be obtained then an exception is thrown unless the
 section of the formatter is optional.
 
 During parsing, the chronology is parsed and must match one of the chronologies
 in Chronology.getAvailableChronologies().
 If the chronology cannot be parsed then an exception is thrown unless the
 section of the formatter is optional.
 The parser uses the case sensitive setting.

Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,appendChronologyText(TextStyle textStyle),DateTimeFormatterBuilder,Appends the chronology name to the formatter.,"

appendChronologyText
public DateTimeFormatterBuilder appendChronologyText(TextStyle textStyle)
Appends the chronology name to the formatter.
 
 The calendar system name will be output during a format.
 If the chronology cannot be obtained then an exception will be thrown.

Parameters:
textStyle - the text style to use, not null
Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,"appendFraction(TemporalField field, int minWidth, int maxWidth, boolean decimalPoint)",DateTimeFormatterBuilder,Appends the fractional value of a date-time field to the formatter.,"

appendFraction
public DateTimeFormatterBuilder appendFraction(TemporalField field,
                                               int minWidth,
                                               int maxWidth,
                                               boolean decimalPoint)
Appends the fractional value of a date-time field to the formatter.
 
 The fractional value of the field will be output including the
 preceding decimal point. The preceding value is not output.
 For example, the second-of-minute value of 15 would be output as .25.
 
 The width of the printed fraction can be controlled. Setting the
 minimum width to zero will cause no output to be generated.
 The printed fraction will have the minimum width necessary between
 the minimum and maximum widths - trailing zeroes are omitted.
 No rounding occurs due to the maximum width - digits are simply dropped.
 
 When parsing in strict mode, the number of parsed digits must be between
 the minimum and maximum width. When parsing in lenient mode, the minimum
 width is considered to be zero and the maximum is nine.
 
 If the value cannot be obtained then an exception will be thrown.
 If the value is negative an exception will be thrown.
 If the field does not have a fixed set of valid values then an
 exception will be thrown.
 If the field value in the date-time to be printed is invalid it
 cannot be printed and an exception will be thrown.

Parameters:
field - the field to append, not null
minWidth - the minimum width of the field excluding the decimal point, from 0 to 9
maxWidth - the maximum width of the field excluding the decimal point, from 1 to 9
decimalPoint - whether to output the localized decimal point symbol
Returns:
this, for chaining, not null
Throws:
IllegalArgumentException - if the field has a variable set of valid values or
  either width is invalid


"
DateTimeFormatterBuilder,appendInstant(),DateTimeFormatterBuilder,"Appends an instant using ISO-8601 to the formatter, formatting fractional digits in groups of three.","

appendInstant
public DateTimeFormatterBuilder appendInstant()
Appends an instant using ISO-8601 to the formatter, formatting fractional
 digits in groups of three.
 
 Instants have a fixed output format.
 They are converted to a date-time with a zone-offset of UTC and formatted
 using the standard ISO-8601 format.
 With this method, formatting nano-of-second outputs zero, three, six
 or nine digits digits as necessary.
 The localized decimal style is not used.
 
 The instant is obtained using INSTANT_SECONDS
 and optionally (@code NANO_OF_SECOND). The value of INSTANT_SECONDS
 may be outside the maximum range of LocalDateTime.
 
 The resolver style has no effect on instant parsing.
 The end-of-day time of '24:00' is handled as midnight at the start of the following day.
 The leap-second time of '23:59:59' is handled to some degree, see
 DateTimeFormatter.parsedLeapSecond() for full details.
 
 An alternative to this method is to format/parse the instant as a single
 epoch-seconds value. That is achieved using appendValue(INSTANT_SECONDS).

Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,appendInstant(int fractionalDigits),DateTimeFormatterBuilder,Appends an instant using ISO-8601 to the formatter with control over the number of fractional digits.,"

appendInstant
public DateTimeFormatterBuilder appendInstant(int fractionalDigits)
Appends an instant using ISO-8601 to the formatter with control over
 the number of fractional digits.
 
 Instants have a fixed output format, although this method provides some
 control over the fractional digits. They are converted to a date-time
 with a zone-offset of UTC and printed using the standard ISO-8601 format.
 The localized decimal style is not used.
 
 The fractionalDigits parameter allows the output of the fractional
 second to be controlled. Specifying zero will cause no fractional digits
 to be output. From 1 to 9 will output an increasing number of digits, using
 zero right-padding if necessary. The special value -1 is used to output as
 many digits as necessary to avoid any trailing zeroes.
 
 When parsing in strict mode, the number of parsed digits must match the
 fractional digits. When parsing in lenient mode, any number of fractional
 digits from zero to nine are accepted.
 
 The instant is obtained using INSTANT_SECONDS
 and optionally (@code NANO_OF_SECOND). The value of INSTANT_SECONDS
 may be outside the maximum range of LocalDateTime.
 
 The resolver style has no effect on instant parsing.
 The end-of-day time of '24:00' is handled as midnight at the start of the following day.
 The leap-second time of '23:59:60' is handled to some degree, see
 DateTimeFormatter.parsedLeapSecond() for full details.
 
 An alternative to this method is to format/parse the instant as a single
 epoch-seconds value. That is achieved using appendValue(INSTANT_SECONDS).

Parameters:
fractionalDigits - the number of fractional second digits to format with,
  from 0 to 9, or -1 to use as many digits as necessary
Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,appendLiteral(char literal),DateTimeFormatterBuilder,Appends a character literal to the formatter.,"

appendLiteral
public DateTimeFormatterBuilder appendLiteral(char literal)
Appends a character literal to the formatter.
 
 This character will be output during a format.

Parameters:
literal - the literal to append, not null
Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,appendLiteral(String literal),DateTimeFormatterBuilder,Appends a string literal to the formatter.,"

appendLiteral
public DateTimeFormatterBuilder appendLiteral(String literal)
Appends a string literal to the formatter.
 
 This string will be output during a format.
 
 If the literal is empty, nothing is added to the formatter.

Parameters:
literal - the literal to append, not null
Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,"appendLocalized(FormatStyle dateStyle, FormatStyle timeStyle)",DateTimeFormatterBuilder,Appends a localized date-time pattern to the formatter.,"

appendLocalized
public DateTimeFormatterBuilder appendLocalized(FormatStyle dateStyle,
                                                FormatStyle timeStyle)
Appends a localized date-time pattern to the formatter.
 
 This appends a localized section to the builder, suitable for outputting
 a date, time or date-time combination. The format of the localized
 section is lazily looked up based on four items:
 
the dateStyle specified to this method
 the timeStyle specified to this method
 the Locale of the DateTimeFormatter
the Chronology, selecting the best available
 
 During formatting, the chronology is obtained from the temporal object
 being formatted, which may have been overridden by
 DateTimeFormatter.withChronology(Chronology).
 
 During parsing, if a chronology has already been parsed, then it is used.
 Otherwise the default from DateTimeFormatter.withChronology(Chronology)
 is used, with IsoChronology as the fallback.
 
 Note that this method provides similar functionality to methods on
 DateFormat such as DateFormat.getDateTimeInstance(int, int).

Parameters:
dateStyle - the date style to use, null means no date required
timeStyle - the time style to use, null means no time required
Returns:
this, for chaining, not null
Throws:
IllegalArgumentException - if both the date and time styles are null


"
DateTimeFormatterBuilder,appendLocalizedOffset(TextStyle style),DateTimeFormatterBuilder,"Appends the localized zone offset, such as 'GMT+01:00', to the formatter.","

appendLocalizedOffset
public DateTimeFormatterBuilder appendLocalizedOffset(TextStyle style)
Appends the localized zone offset, such as 'GMT+01:00', to the formatter.
 
 This appends a localized zone offset to the builder, the format of the
 localized offset is controlled by the specified style
 to this method:
 
full - formats with localized offset text, such
 as 'GMT, 2-digit hour and minute field, optional second field if non-zero,
 and colon.
 short - formats with localized offset text,
 such as 'GMT, hour without leading zero, optional 2-digit minute and
 second if non-zero, and colon.
 

 During formatting, the offset is obtained using a mechanism equivalent
 to querying the temporal with TemporalQueries.offset().
 If the offset cannot be obtained then an exception is thrown unless the
 section of the formatter is optional.
 
 During parsing, the offset is parsed using the format defined above.
 If the offset cannot be parsed then an exception is thrown unless the
 section of the formatter is optional.
 

Parameters:
style - the format style to use, not null
Returns:
this, for chaining, not null
Throws:
IllegalArgumentException - if style is neither full nor short


"
DateTimeFormatterBuilder,"appendOffset(String pattern, String noOffsetText)",DateTimeFormatterBuilder,"Appends the zone offset, such as '+01:00', to the formatter.","

appendOffset
public DateTimeFormatterBuilder appendOffset(String pattern,
                                             String noOffsetText)
Appends the zone offset, such as '+01:00', to the formatter.
 
 This appends an instruction to format/parse the offset ID to the builder.
 
 During formatting, the offset is obtained using a mechanism equivalent
 to querying the temporal with TemporalQueries.offset().
 It will be printed using the format defined below.
 If the offset cannot be obtained then an exception is thrown unless the
 section of the formatter is optional.
 
 During parsing, the offset is parsed using the format defined below.
 If the offset cannot be parsed then an exception is thrown unless the
 section of the formatter is optional.
 
 The format of the offset is controlled by a pattern which must be one
 of the following:
 
+HH - hour only, ignoring minute and second
 +HHmm - hour, with minute if non-zero, ignoring second, no colon
 +HH:mm - hour, with minute if non-zero, ignoring second, with colon
 +HHMM - hour and minute, ignoring second, no colon
 +HH:MM - hour and minute, ignoring second, with colon
 +HHMMss - hour and minute, with second if non-zero, no colon
 +HH:MM:ss - hour and minute, with second if non-zero, with colon
 +HHMMSS - hour, minute and second, no colon
 +HH:MM:SS - hour, minute and second, with colon
 
 The ""no offset"" text controls what text is printed when the total amount of
 the offset fields to be output is zero.
 Example values would be 'Z', '+00:00', 'UTC' or 'GMT'.
 Three formats are accepted for parsing UTC - the ""no offset"" text, and the
 plus and minus versions of zero defined by the pattern.

Parameters:
pattern - the pattern to use, not null
noOffsetText - the text to use when the offset is zero, not null
Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,appendOffsetId(),DateTimeFormatterBuilder,"Appends the zone offset, such as '+01:00', to the formatter.","

appendOffsetId
public DateTimeFormatterBuilder appendOffsetId()
Appends the zone offset, such as '+01:00', to the formatter.
 
 This appends an instruction to format/parse the offset ID to the builder.
 This is equivalent to calling appendOffset(""+HH:MM:ss"", ""Z"").

Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,appendOptional(DateTimeFormatter formatter),DateTimeFormatterBuilder,Appends a formatter to the builder which will optionally format/parse.,"

appendOptional
public DateTimeFormatterBuilder appendOptional(DateTimeFormatter formatter)
Appends a formatter to the builder which will optionally format/parse.
 
 This method has the same effect as appending each of the constituent
 parts directly to this builder surrounded by an optionalStart() and
 optionalEnd().
 
 The formatter will format if data is available for all the fields contained within it.
 The formatter will parse if the string matches, otherwise no error is returned.

Parameters:
formatter - the formatter to add, not null
Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,appendPattern(String pattern),DateTimeFormatterBuilder,Appends the elements defined by the specified pattern to the builder.,"

appendPattern
public DateTimeFormatterBuilder appendPattern(String pattern)
Appends the elements defined by the specified pattern to the builder.
 
 All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.
 The characters '#', '{' and '}' are reserved for future use.
 The characters '[' and ']' indicate optional patterns.
 The following pattern letters are defined:
 
  Symbol  Meaning                     Presentation      Examples
  ------  -------                     ------------      -------
   G       era                         text              AD; Anno Domini; A
   u       year                        year              2004; 04
   y       year-of-era                 year              2004; 04
   D       day-of-year                 number            189
   M/L     month-of-year               number/text       7; 07; Jul; July; J
   d       day-of-month                number            10

   Q/q     quarter-of-year             number/text       3; 03; Q3; 3rd quarter
   Y       week-based-year             year              1996; 96
   w       week-of-week-based-year     number            27
   W       week-of-month               number            4
   E       day-of-week                 text              Tue; Tuesday; T
   e/c     localized day-of-week       number/text       2; 02; Tue; Tuesday; T
   F       week-of-month               number            3

   a       am-pm-of-day                text              PM
   h       clock-hour-of-am-pm (1-12)  number            12
   K       hour-of-am-pm (0-11)        number            0
   k       clock-hour-of-am-pm (1-24)  number            0

   H       hour-of-day (0-23)          number            0
   m       minute-of-hour              number            30
   s       second-of-minute            number            55
   S       fraction-of-second          fraction          978
   A       milli-of-day                number            1234
   n       nano-of-second              number            987654321
   N       nano-of-day                 number            1234000000

   V       time-zone ID                zone-id           America/Los_Angeles; Z; -08:30
   z       time-zone name              zone-name         Pacific Standard Time; PST
   O       localized zone-offset       offset-O          GMT+8; GMT+08:00; UTC-08:00;
   X       zone-offset 'Z' for zero    offset-X          Z; -08; -0830; -08:30; -083015; -08:30:15;
   x       zone-offset                 offset-x          +0000; -08; -0830; -08:30; -083015; -08:30:15;
   Z       zone-offset                 offset-Z          +0000; -0800; -08:00;

   p       pad next                    pad modifier      1

   '       escape for text             delimiter
   ''      single quote                literal           '
   [       optional section start
   ]       optional section end
   #       reserved for future use
   {       reserved for future use
   }       reserved for future use
 

 The count of pattern letters determine the format.
 See DateTimeFormatter for a user-focused description of the patterns.
 The following tables define how the pattern letters map to the builder.
 
Date fields: Pattern letters to output a date.
 
  Pattern  Count  Equivalent builder methods
  -------  -----  --------------------------
    G       1      appendText(ChronoField.ERA, TextStyle.SHORT)
    GG      2      appendText(ChronoField.ERA, TextStyle.SHORT)
    GGG     3      appendText(ChronoField.ERA, TextStyle.SHORT)
    GGGG    4      appendText(ChronoField.ERA, TextStyle.FULL)
    GGGGG   5      appendText(ChronoField.ERA, TextStyle.NARROW)

    u       1      appendValue(ChronoField.YEAR, 1, 19, SignStyle.NORMAL);
    uu      2      appendValueReduced(ChronoField.YEAR, 2, 2000);
    uuu     3      appendValue(ChronoField.YEAR, 3, 19, SignStyle.NORMAL);
    u..u    4..n   appendValue(ChronoField.YEAR, n, 19, SignStyle.EXCEEDS_PAD);
    y       1      appendValue(ChronoField.YEAR_OF_ERA, 1, 19, SignStyle.NORMAL);
    yy      2      appendValueReduced(ChronoField.YEAR_OF_ERA, 2, 2000);
    yyy     3      appendValue(ChronoField.YEAR_OF_ERA, 3, 19, SignStyle.NORMAL);
    y..y    4..n   appendValue(ChronoField.YEAR_OF_ERA, n, 19, SignStyle.EXCEEDS_PAD);
    Y       1      append special localized WeekFields element for numeric week-based-year
    YY      2      append special localized WeekFields element for reduced numeric week-based-year 2 digits;
    YYY     3      append special localized WeekFields element for numeric week-based-year (3, 19, SignStyle.NORMAL);
    Y..Y    4..n   append special localized WeekFields element for numeric week-based-year (n, 19, SignStyle.EXCEEDS_PAD);

    Q       1      appendValue(IsoFields.QUARTER_OF_YEAR);
    QQ      2      appendValue(IsoFields.QUARTER_OF_YEAR, 2);
    QQQ     3      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.SHORT)
    QQQQ    4      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.FULL)
    QQQQQ   5      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.NARROW)
    q       1      appendValue(IsoFields.QUARTER_OF_YEAR);
    qq      2      appendValue(IsoFields.QUARTER_OF_YEAR, 2);
    qqq     3      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.SHORT_STANDALONE)
    qqqq    4      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.FULL_STANDALONE)
    qqqqq   5      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.NARROW_STANDALONE)

    M       1      appendValue(ChronoField.MONTH_OF_YEAR);
    MM      2      appendValue(ChronoField.MONTH_OF_YEAR, 2);
    MMM     3      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.SHORT)
    MMMM    4      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.FULL)
    MMMMM   5      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.NARROW)
    L       1      appendValue(ChronoField.MONTH_OF_YEAR);
    LL      2      appendValue(ChronoField.MONTH_OF_YEAR, 2);
    LLL     3      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.SHORT_STANDALONE)
    LLLL    4      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.FULL_STANDALONE)
    LLLLL   5      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.NARROW_STANDALONE)

    w       1      append special localized WeekFields element for numeric week-of-year
    ww      2      append special localized WeekFields element for numeric week-of-year, zero-padded
    W       1      append special localized WeekFields element for numeric week-of-month
    d       1      appendValue(ChronoField.DAY_OF_MONTH)
    dd      2      appendValue(ChronoField.DAY_OF_MONTH, 2)
    D       1      appendValue(ChronoField.DAY_OF_YEAR)
    DD      2      appendValue(ChronoField.DAY_OF_YEAR, 2)
    DDD     3      appendValue(ChronoField.DAY_OF_YEAR, 3)
    F       1      appendValue(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH)
    E       1      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
    EE      2      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
    EEE     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
    EEEE    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL)
    EEEEE   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW)
    e       1      append special localized WeekFields element for numeric day-of-week
    ee      2      append special localized WeekFields element for numeric day-of-week, zero-padded
    eee     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
    eeee    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL)
    eeeee   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW)
    c       1      append special localized WeekFields element for numeric day-of-week
    ccc     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT_STANDALONE)
    cccc    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL_STANDALONE)
    ccccc   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW_STANDALONE)
 

Time fields: Pattern letters to output a time.
 
  Pattern  Count  Equivalent builder methods
  -------  -----  --------------------------
    a       1      appendText(ChronoField.AMPM_OF_DAY, TextStyle.SHORT)
    h       1      appendValue(ChronoField.CLOCK_HOUR_OF_AMPM)
    hh      2      appendValue(ChronoField.CLOCK_HOUR_OF_AMPM, 2)
    H       1      appendValue(ChronoField.HOUR_OF_DAY)
    HH      2      appendValue(ChronoField.HOUR_OF_DAY, 2)
    k       1      appendValue(ChronoField.CLOCK_HOUR_OF_DAY)
    kk      2      appendValue(ChronoField.CLOCK_HOUR_OF_DAY, 2)
    K       1      appendValue(ChronoField.HOUR_OF_AMPM)
    KK      2      appendValue(ChronoField.HOUR_OF_AMPM, 2)
    m       1      appendValue(ChronoField.MINUTE_OF_HOUR)
    mm      2      appendValue(ChronoField.MINUTE_OF_HOUR, 2)
    s       1      appendValue(ChronoField.SECOND_OF_MINUTE)
    ss      2      appendValue(ChronoField.SECOND_OF_MINUTE, 2)

    S..S    1..n   appendFraction(ChronoField.NANO_OF_SECOND, n, n, false)
    A       1      appendValue(ChronoField.MILLI_OF_DAY)
    A..A    2..n   appendValue(ChronoField.MILLI_OF_DAY, n)
    n       1      appendValue(ChronoField.NANO_OF_SECOND)
    n..n    2..n   appendValue(ChronoField.NANO_OF_SECOND, n)
    N       1      appendValue(ChronoField.NANO_OF_DAY)
    N..N    2..n   appendValue(ChronoField.NANO_OF_DAY, n)
 

Zone ID: Pattern letters to output ZoneId.
 
  Pattern  Count  Equivalent builder methods
  -------  -----  --------------------------
    VV      2      appendZoneId()
    z       1      appendZoneText(TextStyle.SHORT)
    zz      2      appendZoneText(TextStyle.SHORT)
    zzz     3      appendZoneText(TextStyle.SHORT)
    zzzz    4      appendZoneText(TextStyle.FULL)
 

Zone offset: Pattern letters to output ZoneOffset.
 
  Pattern  Count  Equivalent builder methods
  -------  -----  --------------------------
    O       1      appendLocalizedOffsetPrefixed(TextStyle.SHORT);
    OOOO    4      appendLocalizedOffsetPrefixed(TextStyle.FULL);
    X       1      appendOffset(""+HHmm"",""Z"")
    XX      2      appendOffset(""+HHMM"",""Z"")
    XXX     3      appendOffset(""+HH:MM"",""Z"")
    XXXX    4      appendOffset(""+HHMMss"",""Z"")
    XXXXX   5      appendOffset(""+HH:MM:ss"",""Z"")
    x       1      appendOffset(""+HHmm"",""+00"")
    xx      2      appendOffset(""+HHMM"",""+0000"")
    xxx     3      appendOffset(""+HH:MM"",""+00:00"")
    xxxx    4      appendOffset(""+HHMMss"",""+0000"")
    xxxxx   5      appendOffset(""+HH:MM:ss"",""+00:00"")
    Z       1      appendOffset(""+HHMM"",""+0000"")
    ZZ      2      appendOffset(""+HHMM"",""+0000"")
    ZZZ     3      appendOffset(""+HHMM"",""+0000"")
    ZZZZ    4      appendLocalizedOffset(TextStyle.FULL);
    ZZZZZ   5      appendOffset(""+HH:MM:ss"",""Z"")
 

Modifiers: Pattern letters that modify the rest of the pattern:
 
  Pattern  Count  Equivalent builder methods
  -------  -----  --------------------------
    [       1      optionalStart()
    ]       1      optionalEnd()
    p..p    1..n   padNext(n)
 

 Any sequence of letters not specified above, unrecognized letter or
 reserved character will throw an exception.
 Future versions may add to the set of patterns.
 It is recommended to use single quotes around all characters that you want
 to output directly to ensure that future changes do not break your application.
 
 Note that the pattern string is similar, but not identical, to
 SimpleDateFormat.
 The pattern string is also similar, but not identical, to that defined by the
 Unicode Common Locale Data Repository (CLDR/LDML).
 Pattern letters 'X' and 'u' are aligned with Unicode CLDR/LDML.
 By contrast, SimpleDateFormat uses 'u' for the numeric day of week.
 Pattern letters 'y' and 'Y' parse years of two digits and more than 4 digits differently.
 Pattern letters 'n', 'A', 'N', and 'p' are added.
 Number types will reject large numbers.

Parameters:
pattern - the pattern to add, not null
Returns:
this, for chaining, not null
Throws:
IllegalArgumentException - if the pattern is invalid


"
DateTimeFormatterBuilder,appendText(TemporalField field),DateTimeFormatterBuilder,Appends the text of a date-time field to the formatter using the full text style.,"

appendText
public DateTimeFormatterBuilder appendText(TemporalField field)
Appends the text of a date-time field to the formatter using the full
 text style.
 
 The text of the field will be output during a format.
 The value must be within the valid range of the field.
 If the value cannot be obtained then an exception will be thrown.
 If the field has no textual representation, then the numeric value will be used.
 
 The value will be printed as per the normal format of an integer value.
 Only negative numbers will be signed. No padding will be added.

Parameters:
field - the field to append, not null
Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,"appendText(TemporalField field, Map<Long,String> textLookup)",DateTimeFormatterBuilder,Appends the text of a date-time field to the formatter using the specified map to supply the text.,"

appendText
public DateTimeFormatterBuilder appendText(TemporalField field,
                                           Map<Long,String> textLookup)
Appends the text of a date-time field to the formatter using the specified
 map to supply the text.
 
 The standard text outputting methods use the localized text in the JDK.
 This method allows that text to be specified directly.
 The supplied map is not validated by the builder to ensure that formatting or
 parsing is possible, thus an invalid map may throw an error during later use.
 
 Supplying the map of text provides considerable flexibility in formatting and parsing.
 For example, a legacy application might require or supply the months of the
 year as ""JNY"", ""FBY"", ""MCH"" etc. These do not match the standard set of text
 for localized month names. Using this method, a map can be created which
 defines the connection between each value and the text:
 
 Map<Long, String> map = new HashMap<>();
 map.put(1L, ""JNY"");
 map.put(2L, ""FBY"");
 map.put(3L, ""MCH"");
 ...
 builder.appendText(MONTH_OF_YEAR, map);
 

 Other uses might be to output the value with a suffix, such as ""1st"", ""2nd"", ""3rd"",
 or as Roman numerals ""I"", ""II"", ""III"", ""IV"".
 
 During formatting, the value is obtained and checked that it is in the valid range.
 If text is not available for the value then it is output as a number.
 During parsing, the parser will match against the map of text and numeric values.

Parameters:
field - the field to append, not null
textLookup - the map from the value to the text
Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,"appendText(TemporalField field, TextStyle textStyle)",DateTimeFormatterBuilder,Appends the text of a date-time field to the formatter.,"

appendText
public DateTimeFormatterBuilder appendText(TemporalField field,
                                           TextStyle textStyle)
Appends the text of a date-time field to the formatter.
 
 The text of the field will be output during a format.
 The value must be within the valid range of the field.
 If the value cannot be obtained then an exception will be thrown.
 If the field has no textual representation, then the numeric value will be used.
 
 The value will be printed as per the normal format of an integer value.
 Only negative numbers will be signed. No padding will be added.

Parameters:
field - the field to append, not null
textStyle - the text style to use, not null
Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,appendValue(TemporalField field),DateTimeFormatterBuilder,Appends the value of a date-time field to the formatter using a normal output style.,"

appendValue
public DateTimeFormatterBuilder appendValue(TemporalField field)
Appends the value of a date-time field to the formatter using a normal
 output style.
 
 The value of the field will be output during a format.
 If the value cannot be obtained then an exception will be thrown.
 
 The value will be printed as per the normal format of an integer value.
 Only negative numbers will be signed. No padding will be added.
 
 The parser for a variable width value such as this normally behaves greedily,
 requiring one digit, but accepting as many digits as possible.
 This behavior can be affected by 'adjacent value parsing'.
 See appendValue(java.time.temporal.TemporalField, int) for full details.

Parameters:
field - the field to append, not null
Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,"appendValue(TemporalField field, int width)",DateTimeFormatterBuilder,"Appends the value of a date-time field to the formatter using a fixed width, zero-padded approach.","

appendValue
public DateTimeFormatterBuilder appendValue(TemporalField field,
                                            int width)
Appends the value of a date-time field to the formatter using a fixed
 width, zero-padded approach.
 
 The value of the field will be output during a format.
 If the value cannot be obtained then an exception will be thrown.
 
 The value will be zero-padded on the left. If the size of the value
 means that it cannot be printed within the width then an exception is thrown.
 If the value of the field is negative then an exception is thrown during formatting.
 
 This method supports a special technique of parsing known as 'adjacent value parsing'.
 This technique solves the problem where a value, variable or fixed width, is followed by one or more
 fixed length values. The standard parser is greedy, and thus it would normally
 steal the digits that are needed by the fixed width value parsers that follow the
 variable width one.
 
 No action is required to initiate 'adjacent value parsing'.
 When a call to appendValue is made, the builder
 enters adjacent value parsing setup mode. If the immediately subsequent method
 call or calls on the same builder are for a fixed width value, then the parser will reserve
 space so that the fixed width values can be parsed.
 
 For example, consider builder.appendValue(YEAR).appendValue(MONTH_OF_YEAR, 2);
 The year is a variable width parse of between 1 and 19 digits.
 The month is a fixed width parse of 2 digits.
 Because these were appended to the same builder immediately after one another,
 the year parser will reserve two digits for the month to parse.
 Thus, the text '201106' will correctly parse to a year of 2011 and a month of 6.
 Without adjacent value parsing, the year would greedily parse all six digits and leave
 nothing for the month.
 
 Adjacent value parsing applies to each set of fixed width not-negative values in the parser
 that immediately follow any kind of value, variable or fixed width.
 Calling any other append method will end the setup of adjacent value parsing.
 Thus, in the unlikely event that you need to avoid adjacent value parsing behavior,
 simply add the appendValue to another DateTimeFormatterBuilder
 and add that to this builder.
 
 If adjacent parsing is active, then parsing must match exactly the specified
 number of digits in both strict and lenient modes.
 In addition, no positive or negative sign is permitted.

Parameters:
field - the field to append, not null
width - the width of the printed field, from 1 to 19
Returns:
this, for chaining, not null
Throws:
IllegalArgumentException - if the width is invalid


"
DateTimeFormatterBuilder,"appendValue(TemporalField field, int minWidth, int maxWidth, SignStyle signStyle)",DateTimeFormatterBuilder,Appends the value of a date-time field to the formatter providing full control over formatting.,"

appendValue
public DateTimeFormatterBuilder appendValue(TemporalField field,
                                            int minWidth,
                                            int maxWidth,
                                            SignStyle signStyle)
Appends the value of a date-time field to the formatter providing full
 control over formatting.
 
 The value of the field will be output during a format.
 If the value cannot be obtained then an exception will be thrown.
 
 This method provides full control of the numeric formatting, including
 zero-padding and the positive/negative sign.
 
 The parser for a variable width value such as this normally behaves greedily,
 accepting as many digits as possible.
 This behavior can be affected by 'adjacent value parsing'.
 See appendValue(java.time.temporal.TemporalField, int) for full details.
 
 In strict parsing mode, the minimum number of parsed digits is minWidth
 and the maximum is maxWidth.
 In lenient parsing mode, the minimum number of parsed digits is one
 and the maximum is 19 (except as limited by adjacent value parsing).
 
 If this method is invoked with equal minimum and maximum widths and a sign style of
 NOT_NEGATIVE then it delegates to appendValue(TemporalField,int).
 In this scenario, the formatting and parsing behavior described there occur.

Parameters:
field - the field to append, not null
minWidth - the minimum field width of the printed field, from 1 to 19
maxWidth - the maximum field width of the printed field, from 1 to 19
signStyle - the positive/negative output style, not null
Returns:
this, for chaining, not null
Throws:
IllegalArgumentException - if the widths are invalid


"
DateTimeFormatterBuilder,"appendValueReduced(TemporalField field, int width, int maxWidth, ChronoLocalDate baseDate)",DateTimeFormatterBuilder,Appends the reduced value of a date-time field to the formatter.,"

appendValueReduced
public DateTimeFormatterBuilder appendValueReduced(TemporalField field,
                                                   int width,
                                                   int maxWidth,
                                                   ChronoLocalDate baseDate)
Appends the reduced value of a date-time field to the formatter.
 
 This is typically used for formatting and parsing a two digit year.
 
 The base date is used to calculate the full value during parsing.
 For example, if the base date is 1950-01-01 then parsed values for
 a two digit year parse will be in the range 1950-01-01 to 2049-12-31.
 Only the year would be extracted from the date, thus a base date of
 1950-08-25 would also parse to the range 1950-01-01 to 2049-12-31.
 This behavior is necessary to support fields such as week-based-year
 or other calendar systems where the parsed value does not align with
 standard ISO years.
 
 The exact behavior is as follows. Parse the full set of fields and
 determine the effective chronology using the last chronology if
 it appears more than once. Then convert the base date to the
 effective chronology. Then extract the specified field from the
 chronology-specific base date and use it to determine the
 baseValue used below.
 
 For formatting, the width and maxWidth are used to
 determine the number of characters to format.
 If they are equal then the format is fixed width.
 If the value of the field is within the range of the baseValue using
 width characters then the reduced value is formatted otherwise the value is
 truncated to fit maxWidth.
 The rightmost characters are output to match the width, left padding with zero.
 
 For strict parsing, the number of characters allowed by width to maxWidth are parsed.
 For lenient parsing, the number of characters must be at least 1 and less than 10.
 If the number of digits parsed is equal to width and the value is positive,
 the value of the field is computed to be the first number greater than
 or equal to the baseValue with the same least significant characters,
 otherwise the value parsed is the field value.
 This allows a reduced value to be entered for values in range of the baseValue
 and width and absolute values can be entered for values outside the range.
 
 For example, a base value of 1980 and a width of 2 will have
 valid values from 1980 to 2079.
 During parsing, the text ""12"" will result in the value 2012 as that
 is the value within the range where the last two characters are ""12"".
 By contrast, parsing the text ""1915"" will result in the value 1915.

Parameters:
field - the field to append, not null
width - the field width of the printed and parsed field, from 1 to 10
maxWidth - the maximum field width of the printed field, from 1 to 10
baseDate - the base date used to calculate the base value for the range
  of valid values in the parsed chronology, not null
Returns:
this, for chaining, not null
Throws:
IllegalArgumentException - if the width or base value is invalid


"
DateTimeFormatterBuilder,"appendValueReduced(TemporalField field, int width, int maxWidth, int baseValue)",DateTimeFormatterBuilder,Appends the reduced value of a date-time field to the formatter.,"

appendValueReduced
public DateTimeFormatterBuilder appendValueReduced(TemporalField field,
                                                   int width,
                                                   int maxWidth,
                                                   int baseValue)
Appends the reduced value of a date-time field to the formatter.
 
 Since fields such as year vary by chronology, it is recommended to use the
 appendValueReduced(TemporalField, int, int, ChronoLocalDate) date}
 variant of this method in most cases. This variant is suitable for
 simple fields or working with only the ISO chronology.
 
 For formatting, the width and maxWidth are used to
 determine the number of characters to format.
 If they are equal then the format is fixed width.
 If the value of the field is within the range of the baseValue using
 width characters then the reduced value is formatted otherwise the value is
 truncated to fit maxWidth.
 The rightmost characters are output to match the width, left padding with zero.
 
 For strict parsing, the number of characters allowed by width to maxWidth are parsed.
 For lenient parsing, the number of characters must be at least 1 and less than 10.
 If the number of digits parsed is equal to width and the value is positive,
 the value of the field is computed to be the first number greater than
 or equal to the baseValue with the same least significant characters,
 otherwise the value parsed is the field value.
 This allows a reduced value to be entered for values in range of the baseValue
 and width and absolute values can be entered for values outside the range.
 
 For example, a base value of 1980 and a width of 2 will have
 valid values from 1980 to 2079.
 During parsing, the text ""12"" will result in the value 2012 as that
 is the value within the range where the last two characters are ""12"".
 By contrast, parsing the text ""1915"" will result in the value 1915.

Parameters:
field - the field to append, not null
width - the field width of the printed and parsed field, from 1 to 10
maxWidth - the maximum field width of the printed field, from 1 to 10
baseValue - the base value of the range of valid values
Returns:
this, for chaining, not null
Throws:
IllegalArgumentException - if the width or base value is invalid


"
DateTimeFormatterBuilder,appendZoneId(),DateTimeFormatterBuilder,"Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter.","

appendZoneId
public DateTimeFormatterBuilder appendZoneId()
Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter.
 
 This appends an instruction to format/parse the zone ID to the builder.
 The zone ID is obtained in a strict manner suitable for ZonedDateTime.
 By contrast, OffsetDateTime does not have a zone ID suitable
 for use with this method, see appendZoneOrOffsetId().
 
 During formatting, the zone is obtained using a mechanism equivalent
 to querying the temporal with TemporalQueries.zoneId().
 It will be printed using the result of ZoneId.getId().
 If the zone cannot be obtained then an exception is thrown unless the
 section of the formatter is optional.
 
 During parsing, the text must match a known zone or offset.
 There are two types of zone ID, offset-based, such as '+01:30' and
 region-based, such as 'Europe/London'. These are parsed differently.
 If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser
 expects an offset-based zone and will not match region-based zones.
 The offset ID, such as '+02:30', may be at the start of the parse,
 or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is
 equivalent to using appendOffset(String, String) using the
 arguments 'HH:MM:ss' and the no offset string '0'.
 If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot
 match a following offset ID, then ZoneOffset.UTC is selected.
 In all other cases, the list of known region-based zones is used to
 find the longest available match. If no match is found, and the parse
 starts with 'Z', then ZoneOffset.UTC is selected.
 The parser uses the case sensitive setting.
 
 For example, the following will parse:
 
   ""Europe/London""           -- ZoneId.of(""Europe/London"")
   ""Z""                       -- ZoneOffset.UTC
   ""UT""                      -- ZoneId.of(""UT"")
   ""UTC""                     -- ZoneId.of(""UTC"")
   ""GMT""                     -- ZoneId.of(""GMT"")
   ""+01:30""                  -- ZoneOffset.of(""+01:30"")
   ""UT+01:30""                -- ZoneOffset.of(""+01:30"")
   ""UTC+01:30""               -- ZoneOffset.of(""+01:30"")
   ""GMT+01:30""               -- ZoneOffset.of(""+01:30"")
 

Returns:
this, for chaining, not null
See Also:
appendZoneRegionId()


"
DateTimeFormatterBuilder,appendZoneOrOffsetId(),DateTimeFormatterBuilder,"Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter, using the best available zone ID.","

appendZoneOrOffsetId
public DateTimeFormatterBuilder appendZoneOrOffsetId()
Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to
 the formatter, using the best available zone ID.
 
 This appends an instruction to format/parse the best available
 zone or offset ID to the builder.
 The zone ID is obtained in a lenient manner that first attempts to
 find a true zone ID, such as that on ZonedDateTime, and
 then attempts to find an offset, such as that on OffsetDateTime.
 
 During formatting, the zone is obtained using a mechanism equivalent
 to querying the temporal with TemporalQueries.zone().
 It will be printed using the result of ZoneId.getId().
 If the zone cannot be obtained then an exception is thrown unless the
 section of the formatter is optional.
 
 During parsing, the text must match a known zone or offset.
 There are two types of zone ID, offset-based, such as '+01:30' and
 region-based, such as 'Europe/London'. These are parsed differently.
 If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser
 expects an offset-based zone and will not match region-based zones.
 The offset ID, such as '+02:30', may be at the start of the parse,
 or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is
 equivalent to using appendOffset(String, String) using the
 arguments 'HH:MM:ss' and the no offset string '0'.
 If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot
 match a following offset ID, then ZoneOffset.UTC is selected.
 In all other cases, the list of known region-based zones is used to
 find the longest available match. If no match is found, and the parse
 starts with 'Z', then ZoneOffset.UTC is selected.
 The parser uses the case sensitive setting.
 
 For example, the following will parse:
 
   ""Europe/London""           -- ZoneId.of(""Europe/London"")
   ""Z""                       -- ZoneOffset.UTC
   ""UT""                      -- ZoneId.of(""UT"")
   ""UTC""                     -- ZoneId.of(""UTC"")
   ""GMT""                     -- ZoneId.of(""GMT"")
   ""+01:30""                  -- ZoneOffset.of(""+01:30"")
   ""UT+01:30""                -- ZoneOffset.of(""UT+01:30"")
   ""UTC+01:30""               -- ZoneOffset.of(""UTC+01:30"")
   ""GMT+01:30""               -- ZoneOffset.of(""GMT+01:30"")
 

 Note that this method is identical to appendZoneId() except
 in the mechanism used to obtain the zone.

Returns:
this, for chaining, not null
See Also:
appendZoneId()


"
DateTimeFormatterBuilder,appendZoneRegionId(),DateTimeFormatterBuilder,"Appends the time-zone region ID, such as 'Europe/Paris', to the formatter, rejecting the zone ID if it is a ZoneOffset.","

appendZoneRegionId
public DateTimeFormatterBuilder appendZoneRegionId()
Appends the time-zone region ID, such as 'Europe/Paris', to the formatter,
 rejecting the zone ID if it is a ZoneOffset.
 
 This appends an instruction to format/parse the zone ID to the builder
 only if it is a region-based ID.
 
 During formatting, the zone is obtained using a mechanism equivalent
 to querying the temporal with TemporalQueries.zoneId().
 If the zone is a ZoneOffset or it cannot be obtained then
 an exception is thrown unless the section of the formatter is optional.
 If the zone is not an offset, then the zone will be printed using
 the zone ID from ZoneId.getId().
 
 During parsing, the text must match a known zone or offset.
 There are two types of zone ID, offset-based, such as '+01:30' and
 region-based, such as 'Europe/London'. These are parsed differently.
 If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser
 expects an offset-based zone and will not match region-based zones.
 The offset ID, such as '+02:30', may be at the start of the parse,
 or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is
 equivalent to using appendOffset(String, String) using the
 arguments 'HH:MM:ss' and the no offset string '0'.
 If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot
 match a following offset ID, then ZoneOffset.UTC is selected.
 In all other cases, the list of known region-based zones is used to
 find the longest available match. If no match is found, and the parse
 starts with 'Z', then ZoneOffset.UTC is selected.
 The parser uses the case sensitive setting.
 
 For example, the following will parse:
 
   ""Europe/London""           -- ZoneId.of(""Europe/London"")
   ""Z""                       -- ZoneOffset.UTC
   ""UT""                      -- ZoneId.of(""UT"")
   ""UTC""                     -- ZoneId.of(""UTC"")
   ""GMT""                     -- ZoneId.of(""GMT"")
   ""+01:30""                  -- ZoneOffset.of(""+01:30"")
   ""UT+01:30""                -- ZoneOffset.of(""+01:30"")
   ""UTC+01:30""               -- ZoneOffset.of(""+01:30"")
   ""GMT+01:30""               -- ZoneOffset.of(""+01:30"")
 

 Note that this method is identical to appendZoneId() except
 in the mechanism used to obtain the zone.
 Note also that parsing accepts offsets, whereas formatting will never
 produce one.

Returns:
this, for chaining, not null
See Also:
appendZoneId()


"
DateTimeFormatterBuilder,appendZoneText(TextStyle textStyle),DateTimeFormatterBuilder,"Appends the time-zone name, such as 'British Summer Time', to the formatter.","

appendZoneText
public DateTimeFormatterBuilder appendZoneText(TextStyle textStyle)
Appends the time-zone name, such as 'British Summer Time', to the formatter.
 
 This appends an instruction to format/parse the textual name of the zone to
 the builder.
 
 During formatting, the zone is obtained using a mechanism equivalent
 to querying the temporal with TemporalQueries.zoneId().
 If the zone is a ZoneOffset it will be printed using the
 result of ZoneOffset.getId().
 If the zone is not an offset, the textual name will be looked up
 for the locale set in the DateTimeFormatter.
 If the temporal object being printed represents an instant, then the text
 will be the summer or winter time text as appropriate.
 If the lookup for text does not find any suitable result, then the
 ID will be printed instead.
 If the zone cannot be obtained then an exception is thrown unless the
 section of the formatter is optional.
 
 During parsing, either the textual zone name, the zone ID or the offset
 is accepted. Many textual zone names are not unique, such as CST can be
 for both ""Central Standard Time"" and ""China Standard Time"". In this
 situation, the zone id will be determined by the region information from
 formatter's  locale and the standard
 zone id for that area, for example, America/New_York for the America Eastern
 zone. The appendZoneText(TextStyle, Set) may be used
 to specify a set of preferred ZoneId in this situation.

Parameters:
textStyle - the text style to use, not null
Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,"appendZoneText(TextStyle textStyle, Set<ZoneId> preferredZones)",DateTimeFormatterBuilder,"Appends the time-zone name, such as 'British Summer Time', to the formatter.","

appendZoneText
public DateTimeFormatterBuilder appendZoneText(TextStyle textStyle,
                                               Set<ZoneId> preferredZones)
Appends the time-zone name, such as 'British Summer Time', to the formatter.
 
 This appends an instruction to format/parse the textual name of the zone to
 the builder.
 
 During formatting, the zone is obtained using a mechanism equivalent
 to querying the temporal with TemporalQueries.zoneId().
 If the zone is a ZoneOffset it will be printed using the
 result of ZoneOffset.getId().
 If the zone is not an offset, the textual name will be looked up
 for the locale set in the DateTimeFormatter.
 If the temporal object being printed represents an instant, then the text
 will be the summer or winter time text as appropriate.
 If the lookup for text does not find any suitable result, then the
 ID will be printed instead.
 If the zone cannot be obtained then an exception is thrown unless the
 section of the formatter is optional.
 
 During parsing, either the textual zone name, the zone ID or the offset
 is accepted. Many textual zone names are not unique, such as CST can be
 for both ""Central Standard Time"" and ""China Standard Time"". In this
 situation, the zone id will be determined by the region information from
 formatter's  locale and the standard
 zone id for that area, for example, America/New_York for the America Eastern
 zone. This method also allows a set of preferred ZoneId to be
 specified for parsing. The matched preferred zone id will be used if the
 textural zone name being parsed is not unique.
 
 If the zone cannot be parsed then an exception is thrown unless the
 section of the formatter is optional.

Parameters:
textStyle - the text style to use, not null
preferredZones - the set of preferred zone ids, not null
Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,"getLocalizedDateTimePattern(FormatStyle dateStyle, FormatStyle timeStyle, Chronology chrono, Locale locale)",static String,Gets the formatting pattern for date and time styles for a locale and chronology.,"

getLocalizedDateTimePattern
public static String getLocalizedDateTimePattern(FormatStyle dateStyle,
                                                 FormatStyle timeStyle,
                                                 Chronology chrono,
                                                 Locale locale)
Gets the formatting pattern for date and time styles for a locale and chronology.
 The locale and chronology are used to lookup the locale specific format
 for the requested dateStyle and/or timeStyle.

Parameters:
dateStyle - the FormatStyle for the date, null for time-only pattern
timeStyle - the FormatStyle for the time, null for date-only pattern
chrono - the Chronology, non-null
locale - the locale, non-null
Returns:
the locale and Chronology specific formatting pattern
Throws:
IllegalArgumentException - if both dateStyle and timeStyle are null


"
DateTimeFormatterBuilder,optionalEnd(),DateTimeFormatterBuilder,Ends an optional section.,"

optionalEnd
public DateTimeFormatterBuilder optionalEnd()
Ends an optional section.
 
 The output of formatting can include optional sections, which may be nested.
 An optional section is started by calling optionalStart() and ended
 using this method (or at the end of the builder).
 
 Calling this method without having previously called optionalStart
 will throw an exception.
 Calling this method immediately after calling optionalStart has no effect
 on the formatter other than ending the (empty) optional section.
 
 All elements in the optional section are treated as optional.
 During formatting, the section is only output if data is available in the
 TemporalAccessor for all the elements in the section.
 During parsing, the whole section may be missing from the parsed string.
 
 For example, consider a builder setup as
 builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).optionalEnd().
 During formatting, the minute will only be output if its value can be obtained from the date-time.
 During parsing, the input will be successfully parsed whether the minute is present or not.

Returns:
this, for chaining, not null
Throws:
IllegalStateException - if there was no previous call to optionalStart


"
DateTimeFormatterBuilder,optionalStart(),DateTimeFormatterBuilder,Mark the start of an optional section.,"

optionalStart
public DateTimeFormatterBuilder optionalStart()
Mark the start of an optional section.
 
 The output of formatting can include optional sections, which may be nested.
 An optional section is started by calling this method and ended by calling
 optionalEnd() or by ending the build process.
 
 All elements in the optional section are treated as optional.
 During formatting, the section is only output if data is available in the
 TemporalAccessor for all the elements in the section.
 During parsing, the whole section may be missing from the parsed string.
 
 For example, consider a builder setup as
 builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).
 The optional section ends automatically at the end of the builder.
 During formatting, the minute will only be output if its value can be obtained from the date-time.
 During parsing, the input will be successfully parsed whether the minute is present or not.

Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,padNext(int padWidth),DateTimeFormatterBuilder,Causes the next added printer/parser to pad to a fixed width using a space.,"

padNext
public DateTimeFormatterBuilder padNext(int padWidth)
Causes the next added printer/parser to pad to a fixed width using a space.
 
 This padding will pad to a fixed width using spaces.
 
 During formatting, the decorated element will be output and then padded
 to the specified width. An exception will be thrown during formatting if
 the pad width is exceeded.
 
 During parsing, the padding and decorated element are parsed.
 If parsing is lenient, then the pad width is treated as a maximum.
 The padding is parsed greedily. Thus, if the decorated element starts with
 the pad character, it will not be parsed.

Parameters:
padWidth - the pad width, 1 or greater
Returns:
this, for chaining, not null
Throws:
IllegalArgumentException - if pad width is too small


"
DateTimeFormatterBuilder,"padNext(int padWidth, char padChar)",DateTimeFormatterBuilder,Causes the next added printer/parser to pad to a fixed width.,"

padNext
public DateTimeFormatterBuilder padNext(int padWidth,
                                        char padChar)
Causes the next added printer/parser to pad to a fixed width.
 
 This padding is intended for padding other than zero-padding.
 Zero-padding should be achieved using the appendValue methods.
 
 During formatting, the decorated element will be output and then padded
 to the specified width. An exception will be thrown during formatting if
 the pad width is exceeded.
 
 During parsing, the padding and decorated element are parsed.
 If parsing is lenient, then the pad width is treated as a maximum.
 If parsing is case insensitive, then the pad character is matched ignoring case.
 The padding is parsed greedily. Thus, if the decorated element starts with
 the pad character, it will not be parsed.

Parameters:
padWidth - the pad width, 1 or greater
padChar - the pad character
Returns:
this, for chaining, not null
Throws:
IllegalArgumentException - if pad width is too small


"
DateTimeFormatterBuilder,parseCaseInsensitive(),DateTimeFormatterBuilder,Changes the parse style to be case insensitive for the remainder of the formatter.,"

parseCaseInsensitive
public DateTimeFormatterBuilder parseCaseInsensitive()
Changes the parse style to be case insensitive for the remainder of the formatter.
 
 Parsing can be case sensitive or insensitive - by default it is case sensitive.
 This method allows the case sensitivity setting of parsing to be changed.
 
 Calling this method changes the state of the builder such that all
 subsequent builder method calls will parse text in case insensitive mode.
 See parseCaseSensitive() for the opposite setting.
 The parse case sensitive/insensitive methods may be called at any point
 in the builder, thus the parser can swap between case parsing modes
 multiple times during the parse.

Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,parseCaseSensitive(),DateTimeFormatterBuilder,Changes the parse style to be case sensitive for the remainder of the formatter.,"

parseCaseSensitive
public DateTimeFormatterBuilder parseCaseSensitive()
Changes the parse style to be case sensitive for the remainder of the formatter.
 
 Parsing can be case sensitive or insensitive - by default it is case sensitive.
 This method allows the case sensitivity setting of parsing to be changed.
 
 Calling this method changes the state of the builder such that all
 subsequent builder method calls will parse text in case sensitive mode.
 See parseCaseInsensitive() for the opposite setting.
 The parse case sensitive/insensitive methods may be called at any point
 in the builder, thus the parser can swap between case parsing modes
 multiple times during the parse.
 
 Since the default is case sensitive, this method should only be used after
 a previous call to #parseCaseInsensitive.

Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,"parseDefaulting(TemporalField field, long value)",DateTimeFormatterBuilder,Appends a default value for a field to the formatter for use in parsing.,"

parseDefaulting
public DateTimeFormatterBuilder parseDefaulting(TemporalField field,
                                                long value)
Appends a default value for a field to the formatter for use in parsing.
 
 This appends an instruction to the builder to inject a default value
 into the parsed result. This is especially useful in conjunction with
 optional parts of the formatter.
 
 For example, consider a formatter that parses the year, followed by
 an optional month, with a further optional day-of-month. Using such a
 formatter would require the calling code to check whether a full date,
 year-month or just a year had been parsed. This method can be used to
 default the month and day-of-month to a sensible value, such as the
 first of the month, allowing the calling code to always get a date.
 
 During formatting, this method has no effect.
 
 During parsing, the current state of the parse is inspected.
 If the specified field has no associated value, because it has not been
 parsed successfully at that point, then the specified value is injected
 into the parse result. Injection is immediate, thus the field-value pair
 will be visible to any subsequent elements in the formatter.
 As such, this method is normally called at the end of the builder.

Parameters:
field - the field to default the value of, not null
value - the value to default the field to
Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,parseLenient(),DateTimeFormatterBuilder,Changes the parse style to be lenient for the remainder of the formatter.,"

parseLenient
public DateTimeFormatterBuilder parseLenient()
Changes the parse style to be lenient for the remainder of the formatter.
 Note that case sensitivity is set separately to this method.
 
 Parsing can be strict or lenient - by default its strict.
 This controls the degree of flexibility in matching the text and sign styles.
 Applications calling this method should typically also call parseCaseInsensitive().
 
 When used, this method changes the parsing to be lenient from this point onwards.
 The change will remain in force until the end of the formatter that is eventually
 constructed or until parseStrict is called.

Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,parseStrict(),DateTimeFormatterBuilder,Changes the parse style to be strict for the remainder of the formatter.,"

parseStrict
public DateTimeFormatterBuilder parseStrict()
Changes the parse style to be strict for the remainder of the formatter.
 
 Parsing can be strict or lenient - by default its strict.
 This controls the degree of flexibility in matching the text and sign styles.
 
 When used, this method changes the parsing to be strict from this point onwards.
 As strict is the default, this is normally only needed after calling parseLenient().
 The change will remain in force until the end of the formatter that is eventually
 constructed or until parseLenient is called.

Returns:
this, for chaining, not null


"
DateTimeFormatterBuilder,toFormatter(),DateTimeFormatter,Completes this builder by creating the DateTimeFormatter using the default locale.,"

toFormatter
public DateTimeFormatter toFormatter()
Completes this builder by creating the DateTimeFormatter
 using the default locale.
 
 This will create a formatter with the default FORMAT locale.
 Numbers will be printed and parsed using the standard DecimalStyle.
 The resolver style will be SMART.
 
 Calling this method will end any open optional sections by repeatedly
 calling optionalEnd() before creating the formatter.
 
 This builder can still be used after creating the formatter if desired,
 although the state may have been changed by calls to optionalEnd.

Returns:
the created formatter, not null


"
DateTimeFormatterBuilder,toFormatter(Locale locale),DateTimeFormatter,Completes this builder by creating the DateTimeFormatter using the specified locale.,"

toFormatter
public DateTimeFormatter toFormatter(Locale locale)
Completes this builder by creating the DateTimeFormatter
 using the specified locale.
 
 This will create a formatter with the specified locale.
 Numbers will be printed and parsed using the standard DecimalStyle.
 The resolver style will be SMART.
 
 Calling this method will end any open optional sections by repeatedly
 calling optionalEnd() before creating the formatter.
 
 This builder can still be used after creating the formatter if desired,
 although the state may have been changed by calls to optionalEnd.

Parameters:
locale - the locale to use for formatting, not null
Returns:
the created formatter, not null


"
DecimalStyle,equals(Object obj),boolean,Checks if this DecimalStyle is equal to another DecimalStyle.,"

equals
public boolean equals(Object obj)
Checks if this DecimalStyle is equal to another DecimalStyle.

Overrides:
equals in class Object
Parameters:
obj - the object to check, null returns false
Returns:
true if this is equal to the other date
See Also:
Object.hashCode(), 
HashMap


"
DecimalStyle,getAvailableLocales(),static Set<Locale>,Lists all the locales that are supported.,"

getAvailableLocales
public static Set<Locale> getAvailableLocales()
Lists all the locales that are supported.
 
 The locale 'en_US' will always be present.

Returns:
a Set of Locales for which localization is supported


"
DecimalStyle,getDecimalSeparator(),char,Gets the character that represents the decimal point.,"

getDecimalSeparator
public char getDecimalSeparator()
Gets the character that represents the decimal point.
 
 The character used to represent a decimal point may vary by culture.
 This method specifies the character to use.

Returns:
the character for the decimal point


"
DecimalStyle,getNegativeSign(),char,Gets the character that represents the negative sign.,"

getNegativeSign
public char getNegativeSign()
Gets the character that represents the negative sign.
 
 The character used to represent a negative number may vary by culture.
 This method specifies the character to use.

Returns:
the character for the negative sign


"
DecimalStyle,getPositiveSign(),char,Gets the character that represents the positive sign.,"

getPositiveSign
public char getPositiveSign()
Gets the character that represents the positive sign.
 
 The character used to represent a positive number may vary by culture.
 This method specifies the character to use.

Returns:
the character for the positive sign


"
DecimalStyle,getZeroDigit(),char,Gets the character that represents zero.,"

getZeroDigit
public char getZeroDigit()
Gets the character that represents zero.
 
 The character used to represent digits may vary by culture.
 This method specifies the zero character to use, which implies the characters for one to nine.

Returns:
the character for zero


"
DecimalStyle,hashCode(),int,A hash code for this DecimalStyle.,"

hashCode
public int hashCode()
A hash code for this DecimalStyle.

Overrides:
hashCode in class Object
Returns:
a suitable hash code
See Also:
Object.equals(java.lang.Object), 
System.identityHashCode(java.lang.Object)


"
DecimalStyle,of(Locale locale),static DecimalStyle,Obtains the DecimalStyle for the specified locale.,"

of
public static DecimalStyle of(Locale locale)
Obtains the DecimalStyle for the specified locale.
 
 This method provides access to locale sensitive decimal style symbols.

Parameters:
locale - the locale, not null
Returns:
the decimal style, not null


"
DecimalStyle,ofDefaultLocale(),static DecimalStyle,Obtains the DecimalStyle for the default FORMAT locale.,"

ofDefaultLocale
public static DecimalStyle ofDefaultLocale()
Obtains the DecimalStyle for the default
 FORMAT locale.
 
 This method provides access to locale sensitive decimal style symbols.
 
 This is equivalent to calling
 of(Locale.getDefault(Locale.Category.FORMAT)).

Returns:
the decimal style, not null
See Also:
Locale.Category.FORMAT


"
DecimalStyle,toString(),String,Returns a string describing this DecimalStyle.,"

toString
public String toString()
Returns a string describing this DecimalStyle.

Overrides:
toString in class Object
Returns:
a string description, not null


"
DecimalStyle,withDecimalSeparator(char decimalSeparator),DecimalStyle,Returns a copy of the info with a new character that represents the decimal point.,"

withDecimalSeparator
public DecimalStyle withDecimalSeparator(char decimalSeparator)
Returns a copy of the info with a new character that represents the decimal point.
 
 The character used to represent a decimal point may vary by culture.
 This method specifies the character to use.

Parameters:
decimalSeparator - the character for the decimal point
Returns:
a copy with a new character that represents the decimal point, not null


"
DecimalStyle,withNegativeSign(char negativeSign),DecimalStyle,Returns a copy of the info with a new character that represents the negative sign.,"

withNegativeSign
public DecimalStyle withNegativeSign(char negativeSign)
Returns a copy of the info with a new character that represents the negative sign.
 
 The character used to represent a negative number may vary by culture.
 This method specifies the character to use.

Parameters:
negativeSign - the character for the negative sign
Returns:
a copy with a new character that represents the negative sign, not null


"
DecimalStyle,withPositiveSign(char positiveSign),DecimalStyle,Returns a copy of the info with a new character that represents the positive sign.,"

withPositiveSign
public DecimalStyle withPositiveSign(char positiveSign)
Returns a copy of the info with a new character that represents the positive sign.
 
 The character used to represent a positive number may vary by culture.
 This method specifies the character to use.

Parameters:
positiveSign - the character for the positive sign
Returns:
a copy with a new character that represents the positive sign, not null


"
DecimalStyle,withZeroDigit(char zeroDigit),DecimalStyle,Returns a copy of the info with a new character that represents zero.,"

withZeroDigit
public DecimalStyle withZeroDigit(char zeroDigit)
Returns a copy of the info with a new character that represents zero.
 
 The character used to represent digits may vary by culture.
 This method specifies the zero character to use, which implies the characters for one to nine.

Parameters:
zeroDigit - the character for zero
Returns:
a copy with a new character that represents zero, not null


"
