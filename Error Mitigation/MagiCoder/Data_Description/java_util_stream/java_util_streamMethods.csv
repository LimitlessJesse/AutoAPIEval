ClassName,Method,Return Type,Description,Full Description
Collectors,averagingDouble(ToDoubleFunction<? super T> mapper),"static <T> Collector<T,?,Double>",Returns a Collector that produces the arithmetic mean of a double-valued function applied to the input elements.,"

averagingDouble
public static <T> Collector<T,?,Double> averagingDouble(ToDoubleFunction<? super T> mapper)
Returns a Collector that produces the arithmetic mean of a double-valued
 function applied to the input elements.  If no elements are present,
 the result is 0.

 The average returned can vary depending upon the order in which
 values are recorded, due to accumulated rounding error in
 addition of values of differing magnitudes. Values sorted by increasing
 absolute magnitude tend to yield more accurate results.  If any recorded
 value is a NaN or the sum is at any point a NaN then the
 average will be NaN.

Implementation Note:
The double format can represent all
 consecutive integers in the range -253 to
 253. If the pipeline has more than 253
 values, the divisor in the average computation will saturate at
 253, leading to additional numerical errors.
Type Parameters:
T - the type of the input elements
Parameters:
mapper - a function extracting the property to be summed
Returns:
a Collector that produces the sum of a derived property


"
Collectors,averagingInt(ToIntFunction<? super T> mapper),"static <T> Collector<T,?,Double>",Returns a Collector that produces the arithmetic mean of an integer-valued function applied to the input elements.,"

averagingInt
public static <T> Collector<T,?,Double> averagingInt(ToIntFunction<? super T> mapper)
Returns a Collector that produces the arithmetic mean of an integer-valued
 function applied to the input elements.  If no elements are present,
 the result is 0.

Type Parameters:
T - the type of the input elements
Parameters:
mapper - a function extracting the property to be summed
Returns:
a Collector that produces the sum of a derived property


"
Collectors,averagingLong(ToLongFunction<? super T> mapper),"static <T> Collector<T,?,Double>",Returns a Collector that produces the arithmetic mean of a long-valued function applied to the input elements.,"

averagingLong
public static <T> Collector<T,?,Double> averagingLong(ToLongFunction<? super T> mapper)
Returns a Collector that produces the arithmetic mean of a long-valued
 function applied to the input elements.  If no elements are present,
 the result is 0.

Type Parameters:
T - the type of the input elements
Parameters:
mapper - a function extracting the property to be summed
Returns:
a Collector that produces the sum of a derived property


"
Collectors,"collectingAndThen(Collector<T,A,R> downstream, Function<R,RR> finisher)","static <T,A,R,RR> Collector<T,A,RR>",Adapts a Collector to perform an additional finishing transformation.,"

collectingAndThen
public static <T,A,R,RR> Collector<T,A,RR> collectingAndThen(Collector<T,A,R> downstream,
                                                             Function<R,RR> finisher)
Adapts a Collector to perform an additional finishing
 transformation.  For example, one could adapt the toList()
 collector to always produce an immutable list with:
 
     List<String> people
         = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList));
 

Type Parameters:
T - the type of the input elements
A - intermediate accumulation type of the downstream collector
R - result type of the downstream collector
RR - result type of the resulting collector
Parameters:
downstream - a collector
finisher - a function to be applied to the final result of the downstream collector
Returns:
a collector which performs the action of the downstream collector,
 followed by an additional finishing step


"
Collectors,counting(),"static <T> Collector<T,?,Long>",Returns a Collector accepting elements of type T that counts the number of input elements.,"

counting
public static <T> Collector<T,?,Long> counting()
Returns a Collector accepting elements of type T that
 counts the number of input elements.  If no elements are present, the
 result is 0.

Implementation Requirements:
This produces a result equivalent to:
 
     reducing(0L, e -> 1L, Long::sum)
 
Type Parameters:
T - the type of the input elements
Returns:
a Collector that counts the input elements


"
Collectors,"groupingBy(Function<? super T,? extends K> classifier)","static <T,K> Collector<T,?,Map<K,List<T>>>","Returns a Collector implementing a ""group by"" operation on input elements of type T, grouping elements according to a classification function, and returning the results in a Map.","

groupingBy
public static <T,K> Collector<T,?,Map<K,List<T>>> groupingBy(Function<? super T,? extends K> classifier)
Returns a Collector implementing a ""group by"" operation on
 input elements of type T, grouping elements according to a
 classification function, and returning the results in a Map.

 The classification function maps elements to some key type K.
 The collector produces a Map<K, List<T>> whose keys are the
 values resulting from applying the classification function to the input
 elements, and whose corresponding values are Lists containing the
 input elements which map to the associated key under the classification
 function.

 There are no guarantees on the type, mutability, serializability, or
 thread-safety of the Map or List objects returned.

Implementation Requirements:
This produces a result similar to:
 
     groupingBy(classifier, toList());
 
Implementation Note:
The returned Collector is not concurrent.  For parallel stream
 pipelines, the combiner function operates by merging the keys
 from one map into another, which can be an expensive operation.  If
 preservation of the order in which elements appear in the resulting Map
 collector is not required, using groupingByConcurrent(Function)
 may offer better parallel performance.
Type Parameters:
T - the type of the input elements
K - the type of the keys
Parameters:
classifier - the classifier function mapping input elements to keys
Returns:
a Collector implementing the group-by operation
See Also:
groupingBy(Function, Collector), 
groupingBy(Function, Supplier, Collector), 
groupingByConcurrent(Function)


"
Collectors,"groupingBy(Function<? super T,? extends K> classifier, Collector<? super T,A,D> downstream)","static <T,K,A,D> Collector<T,?,Map<K,D>>","Returns a Collector implementing a cascaded ""group by"" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector.","

groupingBy
public static <T,K,A,D> Collector<T,?,Map<K,D>> groupingBy(Function<? super T,? extends K> classifier,
                                                           Collector<? super T,A,D> downstream)
Returns a Collector implementing a cascaded ""group by"" operation
 on input elements of type T, grouping elements according to a
 classification function, and then performing a reduction operation on
 the values associated with a given key using the specified downstream
 Collector.

 The classification function maps elements to some key type K.
 The downstream collector operates on elements of type T and
 produces a result of type D. The resulting collector produces a
 Map<K, D>.

 There are no guarantees on the type, mutability,
 serializability, or thread-safety of the Map returned.

 For example, to compute the set of last names of people in each city:
 
     Map<City, Set<String>> namesByCity
         = people.stream().collect(groupingBy(Person::getCity,
                                              mapping(Person::getLastName, toSet())));
 

Implementation Note:
The returned Collector is not concurrent.  For parallel stream
 pipelines, the combiner function operates by merging the keys
 from one map into another, which can be an expensive operation.  If
 preservation of the order in which elements are presented to the downstream
 collector is not required, using groupingByConcurrent(Function, Collector)
 may offer better parallel performance.
Type Parameters:
T - the type of the input elements
K - the type of the keys
A - the intermediate accumulation type of the downstream collector
D - the result type of the downstream reduction
Parameters:
classifier - a classifier function mapping input elements to keys
downstream - a Collector implementing the downstream reduction
Returns:
a Collector implementing the cascaded group-by operation
See Also:
groupingBy(Function), 
groupingBy(Function, Supplier, Collector), 
groupingByConcurrent(Function, Collector)


"
Collectors,"groupingBy(Function<? super T,? extends K> classifier, Supplier<M> mapFactory, Collector<? super T,A,D> downstream)","static <T,K,D,A,M extends Map<K,D>> Collector<T,?,M>","Returns a Collector implementing a cascaded ""group by"" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector.","

groupingBy
public static <T,K,D,A,M extends Map<K,D>> Collector<T,?,M> groupingBy(Function<? super T,? extends K> classifier,
                                                                       Supplier<M> mapFactory,
                                                                       Collector<? super T,A,D> downstream)
Returns a Collector implementing a cascaded ""group by"" operation
 on input elements of type T, grouping elements according to a
 classification function, and then performing a reduction operation on
 the values associated with a given key using the specified downstream
 Collector.  The Map produced by the Collector is created
 with the supplied factory function.

 The classification function maps elements to some key type K.
 The downstream collector operates on elements of type T and
 produces a result of type D. The resulting collector produces a
 Map<K, D>.

 For example, to compute the set of last names of people in each city,
 where the city names are sorted:
 
     Map<City, Set<String>> namesByCity
         = people.stream().collect(groupingBy(Person::getCity, TreeMap::new,
                                              mapping(Person::getLastName, toSet())));
 

Implementation Note:
The returned Collector is not concurrent.  For parallel stream
 pipelines, the combiner function operates by merging the keys
 from one map into another, which can be an expensive operation.  If
 preservation of the order in which elements are presented to the downstream
 collector is not required, using groupingByConcurrent(Function, Supplier, Collector)
 may offer better parallel performance.
Type Parameters:
T - the type of the input elements
K - the type of the keys
A - the intermediate accumulation type of the downstream collector
D - the result type of the downstream reduction
M - the type of the resulting Map
Parameters:
classifier - a classifier function mapping input elements to keys
downstream - a Collector implementing the downstream reduction
mapFactory - a function which, when called, produces a new empty
                   Map of the desired type
Returns:
a Collector implementing the cascaded group-by operation
See Also:
groupingBy(Function, Collector), 
groupingBy(Function), 
groupingByConcurrent(Function, Supplier, Collector)


"
Collectors,"groupingByConcurrent(Function<? super T,? extends K> classifier)","static <T,K> Collector<T,?,ConcurrentMap<K,List<T>>>","Returns a concurrent Collector implementing a ""group by"" operation on input elements of type T, grouping elements according to a classification function.","

groupingByConcurrent
public static <T,K> Collector<T,?,ConcurrentMap<K,List<T>>> groupingByConcurrent(Function<? super T,? extends K> classifier)
Returns a concurrent Collector implementing a ""group by""
 operation on input elements of type T, grouping elements
 according to a classification function.

 This is a concurrent and
 unordered Collector.

 The classification function maps elements to some key type K.
 The collector produces a ConcurrentMap<K, List<T>> whose keys are the
 values resulting from applying the classification function to the input
 elements, and whose corresponding values are Lists containing the
 input elements which map to the associated key under the classification
 function.

 There are no guarantees on the type, mutability, or serializability
 of the Map or List objects returned, or of the
 thread-safety of the List objects returned.

Implementation Requirements:
This produces a result similar to:
 
     groupingByConcurrent(classifier, toList());
 
Type Parameters:
T - the type of the input elements
K - the type of the keys
Parameters:
classifier - a classifier function mapping input elements to keys
Returns:
a concurrent, unordered Collector implementing the group-by operation
See Also:
groupingBy(Function), 
groupingByConcurrent(Function, Collector), 
groupingByConcurrent(Function, Supplier, Collector)


"
Collectors,"groupingByConcurrent(Function<? super T,? extends K> classifier, Collector<? super T,A,D> downstream)","static <T,K,A,D> Collector<T,?,ConcurrentMap<K,D>>","Returns a concurrent Collector implementing a cascaded ""group by"" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector.","

groupingByConcurrent
public static <T,K,A,D> Collector<T,?,ConcurrentMap<K,D>> groupingByConcurrent(Function<? super T,? extends K> classifier,
                                                                               Collector<? super T,A,D> downstream)
Returns a concurrent Collector implementing a cascaded ""group by""
 operation on input elements of type T, grouping elements
 according to a classification function, and then performing a reduction
 operation on the values associated with a given key using the specified
 downstream Collector.

 This is a concurrent and
 unordered Collector.

 The classification function maps elements to some key type K.
 The downstream collector operates on elements of type T and
 produces a result of type D. The resulting collector produces a
 Map<K, D>.

 For example, to compute the set of last names of people in each city,
 where the city names are sorted:
 
     ConcurrentMap<City, Set<String>> namesByCity
         = people.stream().collect(groupingByConcurrent(Person::getCity,
                                                        mapping(Person::getLastName, toSet())));
 

Type Parameters:
T - the type of the input elements
K - the type of the keys
A - the intermediate accumulation type of the downstream collector
D - the result type of the downstream reduction
Parameters:
classifier - a classifier function mapping input elements to keys
downstream - a Collector implementing the downstream reduction
Returns:
a concurrent, unordered Collector implementing the cascaded group-by operation
See Also:
groupingBy(Function, Collector), 
groupingByConcurrent(Function), 
groupingByConcurrent(Function, Supplier, Collector)


"
Collectors,"groupingByConcurrent(Function<? super T,? extends K> classifier, Supplier<M> mapFactory, Collector<? super T,A,D> downstream)","static <T,K,A,D,M extends ConcurrentMap<K,D>> Collector<T,?,M>","Returns a concurrent Collector implementing a cascaded ""group by"" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector.","

groupingByConcurrent
public static <T,K,A,D,M extends ConcurrentMap<K,D>> Collector<T,?,M> groupingByConcurrent(Function<? super T,? extends K> classifier,
                                                                                           Supplier<M> mapFactory,
                                                                                           Collector<? super T,A,D> downstream)
Returns a concurrent Collector implementing a cascaded ""group by""
 operation on input elements of type T, grouping elements
 according to a classification function, and then performing a reduction
 operation on the values associated with a given key using the specified
 downstream Collector.  The ConcurrentMap produced by the
 Collector is created with the supplied factory function.

 This is a concurrent and
 unordered Collector.

 The classification function maps elements to some key type K.
 The downstream collector operates on elements of type T and
 produces a result of type D. The resulting collector produces a
 Map<K, D>.

 For example, to compute the set of last names of people in each city,
 where the city names are sorted:
 
     ConcurrentMap<City, Set<String>> namesByCity
         = people.stream().collect(groupingBy(Person::getCity, ConcurrentSkipListMap::new,
                                              mapping(Person::getLastName, toSet())));
 

Type Parameters:
T - the type of the input elements
K - the type of the keys
A - the intermediate accumulation type of the downstream collector
D - the result type of the downstream reduction
M - the type of the resulting ConcurrentMap
Parameters:
classifier - a classifier function mapping input elements to keys
downstream - a Collector implementing the downstream reduction
mapFactory - a function which, when called, produces a new empty
                   ConcurrentMap of the desired type
Returns:
a concurrent, unordered Collector implementing the cascaded group-by operation
See Also:
groupingByConcurrent(Function), 
groupingByConcurrent(Function, Collector), 
groupingBy(Function, Supplier, Collector)


"
Collectors,joining(),"static Collector<CharSequence,?,String>","Returns a Collector that concatenates the input elements into a String, in encounter order.","

joining
public static Collector<CharSequence,?,String> joining()
Returns a Collector that concatenates the input elements into a
 String, in encounter order.

Returns:
a Collector that concatenates the input elements into a
 String, in encounter order


"
Collectors,joining(CharSequence delimiter),"static Collector<CharSequence,?,String>","Returns a Collector that concatenates the input elements, separated by the specified delimiter, in encounter order.","

joining
public static Collector<CharSequence,?,String> joining(CharSequence delimiter)
Returns a Collector that concatenates the input elements,
 separated by the specified delimiter, in encounter order.

Parameters:
delimiter - the delimiter to be used between each element
Returns:
A Collector which concatenates CharSequence elements,
 separated by the specified delimiter, in encounter order


"
Collectors,"joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)","static Collector<CharSequence,?,String>","Returns a Collector that concatenates the input elements, separated by the specified delimiter, with the specified prefix and suffix, in encounter order.","

joining
public static Collector<CharSequence,?,String> joining(CharSequence delimiter,
                                                       CharSequence prefix,
                                                       CharSequence suffix)
Returns a Collector that concatenates the input elements,
 separated by the specified delimiter, with the specified prefix and
 suffix, in encounter order.

Parameters:
delimiter - the delimiter to be used between each element
prefix - the sequence of characters to be used at the beginning
                of the joined result
suffix - the sequence of characters to be used at the end
                of the joined result
Returns:
A Collector which concatenates CharSequence elements,
 separated by the specified delimiter, in encounter order


"
Collectors,"mapping(Function<? super T,? extends U> mapper, Collector<? super U,A,R> downstream)","static <T,U,A,R> Collector<T,?,R>",Adapts a Collector accepting elements of type U to one accepting elements of type T by applying a mapping function to each input element before accumulation.,"

mapping
public static <T,U,A,R> Collector<T,?,R> mapping(Function<? super T,? extends U> mapper,
                                                 Collector<? super U,A,R> downstream)
Adapts a Collector accepting elements of type U to one
 accepting elements of type T by applying a mapping function to
 each input element before accumulation.

API Note:
The mapping() collectors are most useful when used in a
 multi-level reduction, such as downstream of a groupingBy or
 partitioningBy.  For example, given a stream of
 Person, to accumulate the set of last names in each city:
 
     Map<City, Set<String>> lastNamesByCity
         = people.stream().collect(groupingBy(Person::getCity,
                                              mapping(Person::getLastName, toSet())));
 
Type Parameters:
T - the type of the input elements
U - type of elements accepted by downstream collector
A - intermediate accumulation type of the downstream collector
R - result type of collector
Parameters:
mapper - a function to be applied to the input elements
downstream - a collector which will accept mapped values
Returns:
a collector which applies the mapping function to the input
 elements and provides the mapped results to the downstream collector


"
Collectors,maxBy(Comparator<? super T> comparator),"static <T> Collector<T,?,Optional<T>>","Returns a Collector that produces the maximal element according to a given Comparator, described as an Optional<T>.","

maxBy
public static <T> Collector<T,?,Optional<T>> maxBy(Comparator<? super T> comparator)
Returns a Collector that produces the maximal element according
 to a given Comparator, described as an Optional<T>.

Implementation Requirements:
This produces a result equivalent to:
 
     reducing(BinaryOperator.maxBy(comparator))
 
Type Parameters:
T - the type of the input elements
Parameters:
comparator - a Comparator for comparing elements
Returns:
a Collector that produces the maximal value


"
Collectors,minBy(Comparator<? super T> comparator),"static <T> Collector<T,?,Optional<T>>","Returns a Collector that produces the minimal element according to a given Comparator, described as an Optional<T>.","

minBy
public static <T> Collector<T,?,Optional<T>> minBy(Comparator<? super T> comparator)
Returns a Collector that produces the minimal element according
 to a given Comparator, described as an Optional<T>.

Implementation Requirements:
This produces a result equivalent to:
 
     reducing(BinaryOperator.minBy(comparator))
 
Type Parameters:
T - the type of the input elements
Parameters:
comparator - a Comparator for comparing elements
Returns:
a Collector that produces the minimal value


"
Collectors,partitioningBy(Predicate<? super T> predicate),"static <T> Collector<T,?,Map<Boolean,List<T>>>","Returns a Collector which partitions the input elements according to a Predicate, and organizes them into a Map<Boolean, List<T>>.","

partitioningBy
public static <T> Collector<T,?,Map<Boolean,List<T>>> partitioningBy(Predicate<? super T> predicate)
Returns a Collector which partitions the input elements according
 to a Predicate, and organizes them into a
 Map<Boolean, List<T>>.

 There are no guarantees on the type, mutability,
 serializability, or thread-safety of the Map returned.

Type Parameters:
T - the type of the input elements
Parameters:
predicate - a predicate used for classifying input elements
Returns:
a Collector implementing the partitioning operation
See Also:
partitioningBy(Predicate, Collector)


"
Collectors,"partitioningBy(Predicate<? super T> predicate, Collector<? super T,A,D> downstream)","static <T,D,A> Collector<T,?,Map<Boolean,D>>","Returns a Collector which partitions the input elements according to a Predicate, reduces the values in each partition according to another Collector, and organizes them into a Map<Boolean, D> whose values are the result of the downstream reduction.","

partitioningBy
public static <T,D,A> Collector<T,?,Map<Boolean,D>> partitioningBy(Predicate<? super T> predicate,
                                                                   Collector<? super T,A,D> downstream)
Returns a Collector which partitions the input elements according
 to a Predicate, reduces the values in each partition according to
 another Collector, and organizes them into a
 Map<Boolean, D> whose values are the result of the downstream
 reduction.

 There are no guarantees on the type, mutability,
 serializability, or thread-safety of the Map returned.

Type Parameters:
T - the type of the input elements
A - the intermediate accumulation type of the downstream collector
D - the result type of the downstream reduction
Parameters:
predicate - a predicate used for classifying input elements
downstream - a Collector implementing the downstream
                   reduction
Returns:
a Collector implementing the cascaded partitioning
         operation
See Also:
partitioningBy(Predicate)


"
Collectors,reducing(BinaryOperator<T> op),"static <T> Collector<T,?,Optional<T>>",Returns a Collector which performs a reduction of its input elements under a specified BinaryOperator.,"

reducing
public static <T> Collector<T,?,Optional<T>> reducing(BinaryOperator<T> op)
Returns a Collector which performs a reduction of its
 input elements under a specified BinaryOperator.  The result
 is described as an Optional<T>.

API Note:
The reducing() collectors are most useful when used in a
 multi-level reduction, downstream of groupingBy or
 partitioningBy.  To perform a simple reduction on a stream,
 use Stream.reduce(BinaryOperator) instead.

 For example, given a stream of Person, to calculate tallest
 person in each city:
 
     Comparator<Person> byHeight = Comparator.comparing(Person::getHeight);
     Map<City, Person> tallestByCity
         = people.stream().collect(groupingBy(Person::getCity, reducing(BinaryOperator.maxBy(byHeight))));
 
Type Parameters:
T - element type for the input and output of the reduction
Parameters:
op - a BinaryOperator<T> used to reduce the input elements
Returns:
a Collector which implements the reduction operation
See Also:
reducing(Object, BinaryOperator), 
reducing(Object, Function, BinaryOperator)


"
Collectors,"reducing(T identity, BinaryOperator<T> op)","static <T> Collector<T,?,T>",Returns a Collector which performs a reduction of its input elements under a specified BinaryOperator using the provided identity.,"

reducing
public static <T> Collector<T,?,T> reducing(T identity,
                                            BinaryOperator<T> op)
Returns a Collector which performs a reduction of its
 input elements under a specified BinaryOperator using the
 provided identity.

API Note:
The reducing() collectors are most useful when used in a
 multi-level reduction, downstream of groupingBy or
 partitioningBy.  To perform a simple reduction on a stream,
 use Stream.reduce(Object, BinaryOperator)} instead.
Type Parameters:
T - element type for the input and output of the reduction
Parameters:
identity - the identity value for the reduction (also, the value
                 that is returned when there are no input elements)
op - a BinaryOperator<T> used to reduce the input elements
Returns:
a Collector which implements the reduction operation
See Also:
reducing(BinaryOperator), 
reducing(Object, Function, BinaryOperator)


"
Collectors,"reducing(U identity, Function<? super T,? extends U> mapper, BinaryOperator<U> op)","static <T,U> Collector<T,?,U>",Returns a Collector which performs a reduction of its input elements under a specified mapping function and BinaryOperator.,"

reducing
public static <T,U> Collector<T,?,U> reducing(U identity,
                                              Function<? super T,? extends U> mapper,
                                              BinaryOperator<U> op)
Returns a Collector which performs a reduction of its
 input elements under a specified mapping function and
 BinaryOperator. This is a generalization of
 reducing(Object, BinaryOperator) which allows a transformation
 of the elements before reduction.

API Note:
The reducing() collectors are most useful when used in a
 multi-level reduction, downstream of groupingBy or
 partitioningBy.  To perform a simple map-reduce on a stream,
 use Stream.map(Function) and Stream.reduce(Object, BinaryOperator)
 instead.

 For example, given a stream of Person, to calculate the longest
 last name of residents in each city:
 
     Comparator<String> byLength = Comparator.comparing(String::length);
     Map<City, String> longestLastNameByCity
         = people.stream().collect(groupingBy(Person::getCity,
                                              reducing(Person::getLastName, BinaryOperator.maxBy(byLength))));
 
Type Parameters:
T - the type of the input elements
U - the type of the mapped values
Parameters:
identity - the identity value for the reduction (also, the value
                 that is returned when there are no input elements)
mapper - a mapping function to apply to each input value
op - a BinaryOperator<U> used to reduce the mapped values
Returns:
a Collector implementing the map-reduce operation
See Also:
reducing(Object, BinaryOperator), 
reducing(BinaryOperator)


"
Collectors,summarizingDouble(ToDoubleFunction<? super T> mapper),"static <T> Collector<T,?,DoubleSummaryStatistics>","Returns a Collector which applies an double-producing mapping function to each input element, and returns summary statistics for the resulting values.","

summarizingDouble
public static <T> Collector<T,?,DoubleSummaryStatistics> summarizingDouble(ToDoubleFunction<? super T> mapper)
Returns a Collector which applies an double-producing
 mapping function to each input element, and returns summary statistics
 for the resulting values.

Type Parameters:
T - the type of the input elements
Parameters:
mapper - a mapping function to apply to each element
Returns:
a Collector implementing the summary-statistics reduction
See Also:
summarizingLong(ToLongFunction), 
summarizingInt(ToIntFunction)


"
Collectors,summarizingInt(ToIntFunction<? super T> mapper),"static <T> Collector<T,?,IntSummaryStatistics>","Returns a Collector which applies an int-producing mapping function to each input element, and returns summary statistics for the resulting values.","

summarizingInt
public static <T> Collector<T,?,IntSummaryStatistics> summarizingInt(ToIntFunction<? super T> mapper)
Returns a Collector which applies an int-producing
 mapping function to each input element, and returns summary statistics
 for the resulting values.

Type Parameters:
T - the type of the input elements
Parameters:
mapper - a mapping function to apply to each element
Returns:
a Collector implementing the summary-statistics reduction
See Also:
summarizingDouble(ToDoubleFunction), 
summarizingLong(ToLongFunction)


"
Collectors,summarizingLong(ToLongFunction<? super T> mapper),"static <T> Collector<T,?,LongSummaryStatistics>","Returns a Collector which applies an long-producing mapping function to each input element, and returns summary statistics for the resulting values.","

summarizingLong
public static <T> Collector<T,?,LongSummaryStatistics> summarizingLong(ToLongFunction<? super T> mapper)
Returns a Collector which applies an long-producing
 mapping function to each input element, and returns summary statistics
 for the resulting values.

Type Parameters:
T - the type of the input elements
Parameters:
mapper - the mapping function to apply to each element
Returns:
a Collector implementing the summary-statistics reduction
See Also:
summarizingDouble(ToDoubleFunction), 
summarizingInt(ToIntFunction)


"
Collectors,summingDouble(ToDoubleFunction<? super T> mapper),"static <T> Collector<T,?,Double>",Returns a Collector that produces the sum of a double-valued function applied to the input elements.,"

summingDouble
public static <T> Collector<T,?,Double> summingDouble(ToDoubleFunction<? super T> mapper)
Returns a Collector that produces the sum of a double-valued
 function applied to the input elements.  If no elements are present,
 the result is 0.

 The sum returned can vary depending upon the order in which
 values are recorded, due to accumulated rounding error in
 addition of values of differing magnitudes. Values sorted by increasing
 absolute magnitude tend to yield more accurate results.  If any recorded
 value is a NaN or the sum is at any point a NaN then the
 sum will be NaN.

Type Parameters:
T - the type of the input elements
Parameters:
mapper - a function extracting the property to be summed
Returns:
a Collector that produces the sum of a derived property


"
Collectors,summingInt(ToIntFunction<? super T> mapper),"static <T> Collector<T,?,Integer>",Returns a Collector that produces the sum of a integer-valued function applied to the input elements.,"

summingInt
public static <T> Collector<T,?,Integer> summingInt(ToIntFunction<? super T> mapper)
Returns a Collector that produces the sum of a integer-valued
 function applied to the input elements.  If no elements are present,
 the result is 0.

Type Parameters:
T - the type of the input elements
Parameters:
mapper - a function extracting the property to be summed
Returns:
a Collector that produces the sum of a derived property


"
Collectors,summingLong(ToLongFunction<? super T> mapper),"static <T> Collector<T,?,Long>",Returns a Collector that produces the sum of a long-valued function applied to the input elements.,"

summingLong
public static <T> Collector<T,?,Long> summingLong(ToLongFunction<? super T> mapper)
Returns a Collector that produces the sum of a long-valued
 function applied to the input elements.  If no elements are present,
 the result is 0.

Type Parameters:
T - the type of the input elements
Parameters:
mapper - a function extracting the property to be summed
Returns:
a Collector that produces the sum of a derived property


"
Collectors,toCollection(Supplier<C> collectionFactory),"static <T,C extends Collection<T>> Collector<T,?,C>","Returns a Collector that accumulates the input elements into a new Collection, in encounter order.","

toCollection
public static <T,C extends Collection<T>> Collector<T,?,C> toCollection(Supplier<C> collectionFactory)
Returns a Collector that accumulates the input elements into a
 new Collection, in encounter order.  The Collection is
 created by the provided factory.

Type Parameters:
T - the type of the input elements
C - the type of the resulting Collection
Parameters:
collectionFactory - a Supplier which returns a new, empty
 Collection of the appropriate type
Returns:
a Collector which collects all the input elements into a
 Collection, in encounter order


"
Collectors,"toConcurrentMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper)","static <T,K,U> Collector<T,?,ConcurrentMap<K,U>>",Returns a concurrent Collector that accumulates elements into a ConcurrentMap whose keys and values are the result of applying the provided mapping functions to the input elements.,"

toConcurrentMap
public static <T,K,U> Collector<T,?,ConcurrentMap<K,U>> toConcurrentMap(Function<? super T,? extends K> keyMapper,
                                                                        Function<? super T,? extends U> valueMapper)
Returns a concurrent Collector that accumulates elements into a
 ConcurrentMap whose keys and values are the result of applying
 the provided mapping functions to the input elements.

 If the mapped keys contains duplicates (according to
 Object.equals(Object)), an IllegalStateException is
 thrown when the collection operation is performed.  If the mapped keys
 may have duplicates, use
 toConcurrentMap(Function, Function, BinaryOperator) instead.

API Note:
It is common for either the key or the value to be the input elements.
 In this case, the utility method
 Function.identity() may be helpful.
 For example, the following produces a Map mapping
 students to their grade point average:
 
     Map<Student, Double> studentToGPA
         students.stream().collect(toMap(Functions.identity(),
                                         student -> computeGPA(student)));
 
 And the following produces a Map mapping a unique identifier to
 students:
 
     Map<String, Student> studentIdToStudent
         students.stream().collect(toConcurrentMap(Student::getId,
                                                   Functions.identity());
 
This is a concurrent and
 unordered Collector.
Type Parameters:
T - the type of the input elements
K - the output type of the key mapping function
U - the output type of the value mapping function
Parameters:
keyMapper - the mapping function to produce keys
valueMapper - the mapping function to produce values
Returns:
a concurrent, unordered Collector which collects elements into a
 ConcurrentMap whose keys are the result of applying a key mapping
 function to the input elements, and whose values are the result of
 applying a value mapping function to the input elements
See Also:
toMap(Function, Function), 
toConcurrentMap(Function, Function, BinaryOperator), 
toConcurrentMap(Function, Function, BinaryOperator, Supplier)


"
Collectors,"toConcurrentMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction)","static <T,K,U> Collector<T,?,ConcurrentMap<K,U>>",Returns a concurrent Collector that accumulates elements into a ConcurrentMap whose keys and values are the result of applying the provided mapping functions to the input elements.,"

toConcurrentMap
public static <T,K,U> Collector<T,?,ConcurrentMap<K,U>> toConcurrentMap(Function<? super T,? extends K> keyMapper,
                                                                        Function<? super T,? extends U> valueMapper,
                                                                        BinaryOperator<U> mergeFunction)
Returns a concurrent Collector that accumulates elements into a
 ConcurrentMap whose keys and values are the result of applying
 the provided mapping functions to the input elements.

 If the mapped keys contains duplicates (according to Object.equals(Object)),
 the value mapping function is applied to each equal element, and the
 results are merged using the provided merging function.

API Note:
There are multiple ways to deal with collisions between multiple elements
 mapping to the same key.  The other forms of toConcurrentMap simply use
 a merge function that throws unconditionally, but you can easily write
 more flexible merge policies.  For example, if you have a stream
 of Person, and you want to produce a ""phone book"" mapping name to
 address, but it is possible that two persons have the same name, you can
 do as follows to gracefully deals with these collisions, and produce a
 Map mapping names to a concatenated list of addresses:
 
     Map<String, String> phoneBook
         people.stream().collect(toConcurrentMap(Person::getName,
                                                 Person::getAddress,
                                                 (s, a) -> s + "", "" + a));
 
This is a concurrent and
 unordered Collector.
Type Parameters:
T - the type of the input elements
K - the output type of the key mapping function
U - the output type of the value mapping function
Parameters:
keyMapper - a mapping function to produce keys
valueMapper - a mapping function to produce values
mergeFunction - a merge function, used to resolve collisions between
                      values associated with the same key, as supplied
                      to Map.merge(Object, Object, BiFunction)
Returns:
a concurrent, unordered Collector which collects elements into a
 ConcurrentMap whose keys are the result of applying a key mapping
 function to the input elements, and whose values are the result of
 applying a value mapping function to all input elements equal to the key
 and combining them using the merge function
See Also:
toConcurrentMap(Function, Function), 
toConcurrentMap(Function, Function, BinaryOperator, Supplier), 
toMap(Function, Function, BinaryOperator)


"
Collectors,"toConcurrentMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapSupplier)","static <T,K,U,M extends ConcurrentMap<K,U>> Collector<T,?,M>",Returns a concurrent Collector that accumulates elements into a ConcurrentMap whose keys and values are the result of applying the provided mapping functions to the input elements.,"

toConcurrentMap
public static <T,K,U,M extends ConcurrentMap<K,U>> Collector<T,?,M> toConcurrentMap(Function<? super T,? extends K> keyMapper,
                                                                                    Function<? super T,? extends U> valueMapper,
                                                                                    BinaryOperator<U> mergeFunction,
                                                                                    Supplier<M> mapSupplier)
Returns a concurrent Collector that accumulates elements into a
 ConcurrentMap whose keys and values are the result of applying
 the provided mapping functions to the input elements.

 If the mapped keys contains duplicates (according to Object.equals(Object)),
 the value mapping function is applied to each equal element, and the
 results are merged using the provided merging function.  The
 ConcurrentMap is created by a provided supplier function.

 This is a concurrent and
 unordered Collector.

Type Parameters:
T - the type of the input elements
K - the output type of the key mapping function
U - the output type of the value mapping function
M - the type of the resulting ConcurrentMap
Parameters:
keyMapper - a mapping function to produce keys
valueMapper - a mapping function to produce values
mergeFunction - a merge function, used to resolve collisions between
                      values associated with the same key, as supplied
                      to Map.merge(Object, Object, BiFunction)
mapSupplier - a function which returns a new, empty Map into
                    which the results will be inserted
Returns:
a concurrent, unordered Collector which collects elements into a
 ConcurrentMap whose keys are the result of applying a key mapping
 function to the input elements, and whose values are the result of
 applying a value mapping function to all input elements equal to the key
 and combining them using the merge function
See Also:
toConcurrentMap(Function, Function), 
toConcurrentMap(Function, Function, BinaryOperator), 
toMap(Function, Function, BinaryOperator, Supplier)


"
Collectors,toList(),"static <T> Collector<T,?,List<T>>",Returns a Collector that accumulates the input elements into a new List.,"

toList
public static <T> Collector<T,?,List<T>> toList()
Returns a Collector that accumulates the input elements into a
 new List. There are no guarantees on the type, mutability,
 serializability, or thread-safety of the List returned; if more
 control over the returned List is required, use toCollection(Supplier).

Type Parameters:
T - the type of the input elements
Returns:
a Collector which collects all the input elements into a
 List, in encounter order


"
Collectors,"toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper)","static <T,K,U> Collector<T,?,Map<K,U>>",Returns a Collector that accumulates elements into a Map whose keys and values are the result of applying the provided mapping functions to the input elements.,"

toMap
public static <T,K,U> Collector<T,?,Map<K,U>> toMap(Function<? super T,? extends K> keyMapper,
                                                    Function<? super T,? extends U> valueMapper)
Returns a Collector that accumulates elements into a
 Map whose keys and values are the result of applying the provided
 mapping functions to the input elements.

 If the mapped keys contains duplicates (according to
 Object.equals(Object)), an IllegalStateException is
 thrown when the collection operation is performed.  If the mapped keys
 may have duplicates, use toMap(Function, Function, BinaryOperator)
 instead.

API Note:
It is common for either the key or the value to be the input elements.
 In this case, the utility method
 Function.identity() may be helpful.
 For example, the following produces a Map mapping
 students to their grade point average:
 
     Map<Student, Double> studentToGPA
         students.stream().collect(toMap(Functions.identity(),
                                         student -> computeGPA(student)));
 
 And the following produces a Map mapping a unique identifier to
 students:
 
     Map<String, Student> studentIdToStudent
         students.stream().collect(toMap(Student::getId,
                                         Functions.identity());
 
Implementation Note:
The returned Collector is not concurrent.  For parallel stream
 pipelines, the combiner function operates by merging the keys
 from one map into another, which can be an expensive operation.  If it is
 not required that results are inserted into the Map in encounter
 order, using toConcurrentMap(Function, Function)
 may offer better parallel performance.
Type Parameters:
T - the type of the input elements
K - the output type of the key mapping function
U - the output type of the value mapping function
Parameters:
keyMapper - a mapping function to produce keys
valueMapper - a mapping function to produce values
Returns:
a Collector which collects elements into a Map
 whose keys and values are the result of applying mapping functions to
 the input elements
See Also:
toMap(Function, Function, BinaryOperator), 
toMap(Function, Function, BinaryOperator, Supplier), 
toConcurrentMap(Function, Function)


"
Collectors,"toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction)","static <T,K,U> Collector<T,?,Map<K,U>>",Returns a Collector that accumulates elements into a Map whose keys and values are the result of applying the provided mapping functions to the input elements.,"

toMap
public static <T,K,U> Collector<T,?,Map<K,U>> toMap(Function<? super T,? extends K> keyMapper,
                                                    Function<? super T,? extends U> valueMapper,
                                                    BinaryOperator<U> mergeFunction)
Returns a Collector that accumulates elements into a
 Map whose keys and values are the result of applying the provided
 mapping functions to the input elements.

 If the mapped
 keys contains duplicates (according to Object.equals(Object)),
 the value mapping function is applied to each equal element, and the
 results are merged using the provided merging function.

API Note:
There are multiple ways to deal with collisions between multiple elements
 mapping to the same key.  The other forms of toMap simply use
 a merge function that throws unconditionally, but you can easily write
 more flexible merge policies.  For example, if you have a stream
 of Person, and you want to produce a ""phone book"" mapping name to
 address, but it is possible that two persons have the same name, you can
 do as follows to gracefully deals with these collisions, and produce a
 Map mapping names to a concatenated list of addresses:
 
     Map<String, String> phoneBook
         people.stream().collect(toMap(Person::getName,
                                       Person::getAddress,
                                       (s, a) -> s + "", "" + a));
 
Implementation Note:
The returned Collector is not concurrent.  For parallel stream
 pipelines, the combiner function operates by merging the keys
 from one map into another, which can be an expensive operation.  If it is
 not required that results are merged into the Map in encounter
 order, using toConcurrentMap(Function, Function, BinaryOperator)
 may offer better parallel performance.
Type Parameters:
T - the type of the input elements
K - the output type of the key mapping function
U - the output type of the value mapping function
Parameters:
keyMapper - a mapping function to produce keys
valueMapper - a mapping function to produce values
mergeFunction - a merge function, used to resolve collisions between
                      values associated with the same key, as supplied
                      to Map.merge(Object, Object, BiFunction)
Returns:
a Collector which collects elements into a Map
 whose keys are the result of applying a key mapping function to the input
 elements, and whose values are the result of applying a value mapping
 function to all input elements equal to the key and combining them
 using the merge function
See Also:
toMap(Function, Function), 
toMap(Function, Function, BinaryOperator, Supplier), 
toConcurrentMap(Function, Function, BinaryOperator)


"
Collectors,"toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapSupplier)","static <T,K,U,M extends Map<K,U>> Collector<T,?,M>",Returns a Collector that accumulates elements into a Map whose keys and values are the result of applying the provided mapping functions to the input elements.,"

toMap
public static <T,K,U,M extends Map<K,U>> Collector<T,?,M> toMap(Function<? super T,? extends K> keyMapper,
                                                                Function<? super T,? extends U> valueMapper,
                                                                BinaryOperator<U> mergeFunction,
                                                                Supplier<M> mapSupplier)
Returns a Collector that accumulates elements into a
 Map whose keys and values are the result of applying the provided
 mapping functions to the input elements.

 If the mapped
 keys contains duplicates (according to Object.equals(Object)),
 the value mapping function is applied to each equal element, and the
 results are merged using the provided merging function.  The Map
 is created by a provided supplier function.

Implementation Note:
The returned Collector is not concurrent.  For parallel stream
 pipelines, the combiner function operates by merging the keys
 from one map into another, which can be an expensive operation.  If it is
 not required that results are merged into the Map in encounter
 order, using toConcurrentMap(Function, Function, BinaryOperator, Supplier)
 may offer better parallel performance.
Type Parameters:
T - the type of the input elements
K - the output type of the key mapping function
U - the output type of the value mapping function
M - the type of the resulting Map
Parameters:
keyMapper - a mapping function to produce keys
valueMapper - a mapping function to produce values
mergeFunction - a merge function, used to resolve collisions between
                      values associated with the same key, as supplied
                      to Map.merge(Object, Object, BiFunction)
mapSupplier - a function which returns a new, empty Map into
                    which the results will be inserted
Returns:
a Collector which collects elements into a Map
 whose keys are the result of applying a key mapping function to the input
 elements, and whose values are the result of applying a value mapping
 function to all input elements equal to the key and combining them
 using the merge function
See Also:
toMap(Function, Function), 
toMap(Function, Function, BinaryOperator), 
toConcurrentMap(Function, Function, BinaryOperator, Supplier)


"
Collectors,toSet(),"static <T> Collector<T,?,Set<T>>",Returns a Collector that accumulates the input elements into a new Set.,"

toSet
public static <T> Collector<T,?,Set<T>> toSet()
Returns a Collector that accumulates the input elements into a
 new Set. There are no guarantees on the type, mutability,
 serializability, or thread-safety of the Set returned; if more
 control over the returned Set is required, use
 toCollection(Supplier).

 This is an unordered
 Collector.

Type Parameters:
T - the type of the input elements
Returns:
a Collector which collects all the input elements into a
 Set


"
StreamSupport,"doubleStream(Spliterator.OfDouble spliterator, boolean parallel)",static DoubleStream,Creates a new sequential or parallel DoubleStream from a Spliterator.OfDouble.,"

doubleStream
public static DoubleStream doubleStream(Spliterator.OfDouble spliterator,
                                        boolean parallel)
Creates a new sequential or parallel DoubleStream from a
 Spliterator.OfDouble.

 The spliterator is only traversed, split, or queried for estimated size
 after the terminal operation of the stream pipeline commences.

 It is strongly recommended the spliterator report a characteristic of
 IMMUTABLE or CONCURRENT, or be
 late-binding.  Otherwise,
 doubleStream(java.util.function.Supplier, int, boolean) should
 be used to reduce the scope of potential interference with the source.  See
 Non-Interference for
 more details.

Parameters:
spliterator - A Spliterator.OfDouble describing the stream elements
parallel - if true then the returned stream is a parallel
        stream; if false the returned stream is a sequential
        stream.
Returns:
a new sequential or parallel DoubleStream


"
StreamSupport,"doubleStream(Supplier<? extends Spliterator.OfDouble> supplier, int characteristics, boolean parallel)",static DoubleStream,Creates a new sequential or parallel DoubleStream from a Supplier of Spliterator.OfDouble.,"

doubleStream
public static DoubleStream doubleStream(Supplier<? extends Spliterator.OfDouble> supplier,
                                        int characteristics,
                                        boolean parallel)
Creates a new sequential or parallel DoubleStream from a
 Supplier of Spliterator.OfDouble.

 The Supplier.get() method will be invoked on the supplier no
 more than once, and only after the terminal operation of the stream pipeline
 commences.

 For spliterators that report a characteristic of IMMUTABLE
 or CONCURRENT, or that are
 late-binding, it is likely
 more efficient to use doubleStream(java.util.Spliterator.OfDouble, boolean)
 instead.
 The use of a Supplier in this form provides a level of
 indirection that reduces the scope of potential interference with the
 source.  Since the supplier is only invoked after the terminal operation
 commences, any modifications to the source up to the start of the
 terminal operation are reflected in the stream result.  See
 Non-Interference for
 more details.

Parameters:
supplier - A Supplier of a Spliterator.OfDouble
characteristics - Spliterator characteristics of the supplied
        Spliterator.OfDouble.  The characteristics must be equal to
        supplier.get().characteristics(), otherwise undefined
        behavior may occur when terminal operation commences.
parallel - if true then the returned stream is a parallel
        stream; if false the returned stream is a sequential
        stream.
Returns:
a new sequential or parallel DoubleStream
See Also:
doubleStream(java.util.Spliterator.OfDouble, boolean)


"
StreamSupport,"intStream(Spliterator.OfInt spliterator, boolean parallel)",static IntStream,Creates a new sequential or parallel IntStream from a Spliterator.OfInt.,"

intStream
public static IntStream intStream(Spliterator.OfInt spliterator,
                                  boolean parallel)
Creates a new sequential or parallel IntStream from a
 Spliterator.OfInt.

 The spliterator is only traversed, split, or queried for estimated size
 after the terminal operation of the stream pipeline commences.

 It is strongly recommended the spliterator report a characteristic of
 IMMUTABLE or CONCURRENT, or be
 late-binding.  Otherwise,
 intStream(java.util.function.Supplier, int, boolean) should be
 used to reduce the scope of potential interference with the source.  See
 Non-Interference for
 more details.

Parameters:
spliterator - a Spliterator.OfInt describing the stream elements
parallel - if true then the returned stream is a parallel
        stream; if false the returned stream is a sequential
        stream.
Returns:
a new sequential or parallel IntStream


"
StreamSupport,"intStream(Supplier<? extends Spliterator.OfInt> supplier, int characteristics, boolean parallel)",static IntStream,Creates a new sequential or parallel IntStream from a Supplier of Spliterator.OfInt.,"

intStream
public static IntStream intStream(Supplier<? extends Spliterator.OfInt> supplier,
                                  int characteristics,
                                  boolean parallel)
Creates a new sequential or parallel IntStream from a
 Supplier of Spliterator.OfInt.

 The Supplier.get() method will be invoked on the supplier no
 more than once, and only after the terminal operation of the stream pipeline
 commences.

 For spliterators that report a characteristic of IMMUTABLE
 or CONCURRENT, or that are
 late-binding, it is likely
 more efficient to use intStream(java.util.Spliterator.OfInt, boolean)
 instead.
 The use of a Supplier in this form provides a level of
 indirection that reduces the scope of potential interference with the
 source.  Since the supplier is only invoked after the terminal operation
 commences, any modifications to the source up to the start of the
 terminal operation are reflected in the stream result.  See
 Non-Interference for
 more details.

Parameters:
supplier - a Supplier of a Spliterator.OfInt
characteristics - Spliterator characteristics of the supplied
        Spliterator.OfInt.  The characteristics must be equal to
        supplier.get().characteristics(), otherwise undefined
        behavior may occur when terminal operation commences.
parallel - if true then the returned stream is a parallel
        stream; if false the returned stream is a sequential
        stream.
Returns:
a new sequential or parallel IntStream
See Also:
intStream(java.util.Spliterator.OfInt, boolean)


"
StreamSupport,"longStream(Spliterator.OfLong spliterator, boolean parallel)",static LongStream,Creates a new sequential or parallel LongStream from a Spliterator.OfLong.,"

longStream
public static LongStream longStream(Spliterator.OfLong spliterator,
                                    boolean parallel)
Creates a new sequential or parallel LongStream from a
 Spliterator.OfLong.

 The spliterator is only traversed, split, or queried for estimated
 size after the terminal operation of the stream pipeline commences.

 It is strongly recommended the spliterator report a characteristic of
 IMMUTABLE or CONCURRENT, or be
 late-binding.  Otherwise,
 longStream(java.util.function.Supplier, int, boolean) should be
 used to reduce the scope of potential interference with the source.  See
 Non-Interference for
 more details.

Parameters:
spliterator - a Spliterator.OfLong describing the stream elements
parallel - if true then the returned stream is a parallel
        stream; if false the returned stream is a sequential
        stream.
Returns:
a new sequential or parallel LongStream


"
StreamSupport,"longStream(Supplier<? extends Spliterator.OfLong> supplier, int characteristics, boolean parallel)",static LongStream,Creates a new sequential or parallel LongStream from a Supplier of Spliterator.OfLong.,"

longStream
public static LongStream longStream(Supplier<? extends Spliterator.OfLong> supplier,
                                    int characteristics,
                                    boolean parallel)
Creates a new sequential or parallel LongStream from a
 Supplier of Spliterator.OfLong.

 The Supplier.get() method will be invoked on the supplier no
 more than once, and only after the terminal operation of the stream pipeline
 commences.

 For spliterators that report a characteristic of IMMUTABLE
 or CONCURRENT, or that are
 late-binding, it is likely
 more efficient to use longStream(java.util.Spliterator.OfLong, boolean)
 instead.
 The use of a Supplier in this form provides a level of
 indirection that reduces the scope of potential interference with the
 source.  Since the supplier is only invoked after the terminal operation
 commences, any modifications to the source up to the start of the
 terminal operation are reflected in the stream result.  See
 Non-Interference for
 more details.

Parameters:
supplier - a Supplier of a Spliterator.OfLong
characteristics - Spliterator characteristics of the supplied
        Spliterator.OfLong.  The characteristics must be equal to
        supplier.get().characteristics(), otherwise undefined
        behavior may occur when terminal operation commences.
parallel - if true then the returned stream is a parallel
        stream; if false the returned stream is a sequential
        stream.
Returns:
a new sequential or parallel LongStream
See Also:
longStream(java.util.Spliterator.OfLong, boolean)


"
StreamSupport,"stream(Spliterator<T> spliterator, boolean parallel)",static <T> Stream<T>,Creates a new sequential or parallel Stream from a Spliterator.,"

stream
public static <T> Stream<T> stream(Spliterator<T> spliterator,
                                   boolean parallel)
Creates a new sequential or parallel Stream from a
 Spliterator.

 The spliterator is only traversed, split, or queried for estimated
 size after the terminal operation of the stream pipeline commences.

 It is strongly recommended the spliterator report a characteristic of
 IMMUTABLE or CONCURRENT, or be
 late-binding.  Otherwise,
 stream(java.util.function.Supplier, int, boolean) should be used
 to reduce the scope of potential interference with the source.  See
 Non-Interference for
 more details.

Type Parameters:
T - the type of stream elements
Parameters:
spliterator - a Spliterator describing the stream elements
parallel - if true then the returned stream is a parallel
        stream; if false the returned stream is a sequential
        stream.
Returns:
a new sequential or parallel Stream


"
StreamSupport,"stream(Supplier<? extends Spliterator<T>> supplier, int characteristics, boolean parallel)",static <T> Stream<T>,Creates a new sequential or parallel Stream from a Supplier of Spliterator.,"

stream
public static <T> Stream<T> stream(Supplier<? extends Spliterator<T>> supplier,
                                   int characteristics,
                                   boolean parallel)
Creates a new sequential or parallel Stream from a
 Supplier of Spliterator.

 The Supplier.get() method will be invoked on the supplier no
 more than once, and only after the terminal operation of the stream pipeline
 commences.

 For spliterators that report a characteristic of IMMUTABLE
 or CONCURRENT, or that are
 late-binding, it is likely
 more efficient to use stream(java.util.Spliterator, boolean)
 instead.
 The use of a Supplier in this form provides a level of
 indirection that reduces the scope of potential interference with the
 source.  Since the supplier is only invoked after the terminal operation
 commences, any modifications to the source up to the start of the
 terminal operation are reflected in the stream result.  See
 Non-Interference for
 more details.

Type Parameters:
T - the type of stream elements
Parameters:
supplier - a Supplier of a Spliterator
characteristics - Spliterator characteristics of the supplied
        Spliterator.  The characteristics must be equal to
        supplier.get().characteristics(), otherwise undefined
        behavior may occur when terminal operation commences.
parallel - if true then the returned stream is a parallel
        stream; if false the returned stream is a sequential
        stream.
Returns:
a new sequential or parallel Stream
See Also:
stream(java.util.Spliterator, boolean)


"
