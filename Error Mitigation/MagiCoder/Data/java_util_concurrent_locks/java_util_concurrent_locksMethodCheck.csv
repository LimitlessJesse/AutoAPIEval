Sample Number,ClassName,Snippet Number,Method,Exist,Description
0,AbstractOwnableSynchronizer,1,boolean isHeldByCurrentThread(),False,NULL
0,AbstractOwnableSynchronizer,2,void setExclusiveOwnerThread(Thread thread),True,Sets the thread that currently owns exclusive access.
0,AbstractOwnableSynchronizer,3,Thread getExclusiveOwnerThread(),True,"Returns the thread last set by setExclusiveOwnerThread, or null if never set."
0,AbstractOwnableSynchronizer,4,boolean tryAcquire(int arg),False,NULL
0,AbstractOwnableSynchronizer,5,boolean release(int arg),False,NULL
1,AbstractQueuedLongSynchronizer,1,protected long tryAcquireShared(long arg),False,NULL
1,AbstractQueuedLongSynchronizer,2,protected boolean tryReleaseShared(long arg),False,NULL
1,AbstractQueuedLongSynchronizer,3,protected boolean isHeldExclusively(),False,NULL
1,AbstractQueuedLongSynchronizer,4,protected long getState(),False,NULL
1,AbstractQueuedLongSynchronizer,5,protected void setState(long newState),False,NULL
2,AbstractQueuedSynchronizer,1,int getState(),True,Returns the current value of synchronization state.
2,AbstractQueuedSynchronizer,2,"boolean compareAndSetState(int expect, int update)",True,Atomically sets synchronization state to the given updated value if the current state value equals the expected value.
2,AbstractQueuedSynchronizer,3,void acquire(int arg),True,"Acquires in exclusive mode, ignoring interrupts."
2,AbstractQueuedSynchronizer,4,boolean tryAcquire(int arg),True,Attempts to acquire in exclusive mode.
2,AbstractQueuedSynchronizer,5,void release(int arg),False,NULL
3,LockSupport,1,void park(Object blocker),True,Disables the current thread for thread scheduling purposes unless the permit is available.
3,LockSupport,2,void unpark(Thread thread),True,"Makes available the permit for the given thread, if it was not already available."
3,LockSupport,3,"void parkNanos(Object blocker, long nanos)",True,"Disables the current thread for thread scheduling purposes, for up to the specified waiting time, unless the permit is available."
3,LockSupport,4,"void parkUntil(Object blocker, long deadline)",True,"Disables the current thread for thread scheduling purposes, until the specified deadline, unless the permit is available."
3,LockSupport,5,"void parkNanos(Object blocker, long nanos)",True,"Disables the current thread for thread scheduling purposes, for up to the specified waiting time, unless the permit is available."
4,ReentrantLock,1,void lock(),True,Acquires the lock.
4,ReentrantLock,2,void lockInterruptibly(),True,Acquires the lock unless the current thread is interrupted.
4,ReentrantLock,3,boolean tryLock(),True,Acquires the lock only if it is not held by another thread at the time of invocation.
4,ReentrantLock,4,"boolean tryLock(long time, TimeUnit unit)",True,Acquires the lock if it is not held by another thread within the given waiting time and the current thread has not been interrupted.
4,ReentrantLock,5,void unlock(),True,Attempts to release this lock.
5,ReentrantReadWriteLock,1,ReentrantReadWriteLock(),False,NULL
5,ReentrantReadWriteLock,2,Lock readLock(),False,NULL
5,ReentrantReadWriteLock,3,Lock writeLock(),False,NULL
5,ReentrantReadWriteLock,4,boolean isFair(),True,Returns true if this lock has fairness set true.
5,ReentrantReadWriteLock,5,boolean isWriteLocked(),True,Queries if the write lock is held by any thread.
5,ReentrantReadWriteLock,6,boolean isWriteLockedByCurrentThread(),True,Queries if the write lock is held by the current thread.
5,ReentrantReadWriteLock,7,boolean isReadLocked(),False,NULL
5,ReentrantReadWriteLock,8,boolean isReadLockedByCurrentThread(),False,NULL
5,ReentrantReadWriteLock,9,int getReadLockCount(),True,Queries the number of read locks held for this lock.
5,ReentrantReadWriteLock,10,int getWriteLockCount(),False,NULL
5,ReentrantReadWriteLock,11,Condition newCondition(),False,NULL
5,ReentrantReadWriteLock,12,void lock(),False,NULL
5,ReentrantReadWriteLock,13,void lockInterruptibly(),False,NULL
5,ReentrantReadWriteLock,14,boolean tryLock(),False,NULL
5,ReentrantReadWriteLock,15,"boolean tryLock(long time, TimeUnit unit)",False,NULL
5,ReentrantReadWriteLock,16,void unlock(),False,NULL
5,ReentrantReadWriteLock,17,void readLock(),False,NULL
5,ReentrantReadWriteLock,18,void readLockInterruptibly(),False,NULL
5,ReentrantReadWriteLock,19,boolean tryReadLock(),False,NULL
5,ReentrantReadWriteLock,20,"boolean tryReadLock(long time, TimeUnit unit)",False,NULL
5,ReentrantReadWriteLock,21,void unlockRead(),False,NULL
5,ReentrantReadWriteLock,22,void writeLock(),False,NULL
5,ReentrantReadWriteLock,23,void writeLockInterruptibly(),False,NULL
5,ReentrantReadWriteLock,24,boolean tryWriteLock(),False,NULL
5,ReentrantReadWriteLock,25,"boolean tryWriteLock(long time, TimeUnit unit)",False,NULL
5,ReentrantReadWriteLock,26,void unlockWrite(),False,NULL
6,ReentrantReadWriteLock.ReadLock,1,void lock(),True,Acquires the read lock.
6,ReentrantReadWriteLock.ReadLock,2,boolean tryLock(),True,Acquires the read lock only if the write lock is not held by another thread at the time of invocation.
6,ReentrantReadWriteLock.ReadLock,3,"boolean tryLock(long time, TimeUnit unit)",True,Acquires the read lock if the write lock is not held by another thread within the given waiting time and the current thread has not been interrupted.
6,ReentrantReadWriteLock.ReadLock,4,void unlock(),True,Attempts to release this lock.
6,ReentrantReadWriteLock.ReadLock,5,Condition newCondition(),True,Throws UnsupportedOperationException because ReadLocks do not support conditions.
7,ReentrantReadWriteLock.WriteLock,1,void lock(),True,Acquires the write lock.
7,ReentrantReadWriteLock.WriteLock,2,boolean tryLock(),True,Acquires the write lock only if it is not held by another thread at the time of invocation.
7,ReentrantReadWriteLock.WriteLock,3,"boolean tryLock(long time, TimeUnit unit)",True,Acquires the write lock if it is not held by another thread within the given waiting time and the current thread has not been interrupted.
7,ReentrantReadWriteLock.WriteLock,4,void unlock(),True,Attempts to release this lock.
7,ReentrantReadWriteLock.WriteLock,5,Condition newCondition(),True,Returns a Condition instance for use with this Lock instance.
8,StampedLock,1,long writeLock(),True,"Exclusively acquires the lock, blocking if necessary until available."
8,StampedLock,2,boolean tryWriteLock(),False,NULL
8,StampedLock,3,long tryOptimisticRead(),True,"Returns a stamp that can later be validated, or zero if exclusively locked."
8,StampedLock,4,long readLock(),True,"Non-exclusively acquires the lock, blocking if necessary until available."
8,StampedLock,5,void unlock(long stamp),True,"If the lock state matches the given stamp, releases the corresponding mode of the lock."
