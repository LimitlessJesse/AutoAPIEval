Sample Number,ClassName,Snippet Number,Method,Exist,Description,Full Description
0,CallSite,1,MethodHandle getTarget(),True,,"

getTarget
public abstract MethodHandle getTarget()
Returns the target method of the call site, according to the
 behavior defined by this call site's specific class.
 The immediate subclasses of CallSite document the
 class-specific behaviors of this method.

Returns:
the current linkage state of the call site, its target method handle
See Also:
ConstantCallSite, 
VolatileCallSite, 
setTarget(java.lang.invoke.MethodHandle), 
ConstantCallSite.getTarget(), 
MutableCallSite.getTarget(), 
VolatileCallSite.getTarget()


"
0,CallSite,2,void setTarget(MethodHandle target),True,,"

setTarget
public abstract void setTarget(MethodHandle newTarget)
Updates the target method of this call site, according to the
 behavior defined by this call site's specific class.
 The immediate subclasses of CallSite document the
 class-specific behaviors of this method.
 
 The type of the new target must be equal to
 the type of the old target.

Parameters:
newTarget - the new target
Throws:
NullPointerException - if the proposed new target is null
WrongMethodTypeException - if the proposed new target
         has a method type that differs from the previous target
See Also:
getTarget(), 
ConstantCallSite.setTarget(java.lang.invoke.MethodHandle), 
MutableCallSite.setTarget(java.lang.invoke.MethodHandle), 
VolatileCallSite.setTarget(java.lang.invoke.MethodHandle)


"
0,CallSite,3,MethodType type(),True,,"

type
public MethodType type()
Returns the type of this call site's target.
 Although targets may change, any call site's type is permanent, and can never change to an unequal type.
 The setTarget method enforces this invariant by refusing any new target that does
 not have the previous target's type.

Returns:
the type of the current target, which is also the type of any future target


"
0,CallSite,4,MethodHandle dynamicInvoker(),True,,"

dynamicInvoker
public abstract MethodHandle dynamicInvoker()
Produces a method handle equivalent to an invokedynamic instruction
 which has been linked to this call site.
 
 This method is equivalent to the following code:
 
 MethodHandle getTarget, invoker, result;
 getTarget = MethodHandles.publicLookup().bind(this, ""getTarget"", MethodType.methodType(MethodHandle.class));
 invoker = MethodHandles.exactInvoker(this.type());
 result = MethodHandles.foldArguments(invoker, getTarget)
 

Returns:
a method handle which always invokes this call site's current target


"
0,CallSite,5,void syncAll(CallSite[] sites),False,,NULL
1,ConstantCallSite,1,MethodHandle dynamicInvoker(),True,,"

dynamicInvoker
public final MethodHandle dynamicInvoker()
Returns this call site's permanent target.
 Since that target will never change, this is a correct implementation
 of CallSite.dynamicInvoker.

Specified by:
dynamicInvoker in class CallSite
Returns:
the immutable linkage state of this call site, a constant method handle
Throws:
IllegalStateException - if the ConstantCallSite constructor has not completed


"
1,ConstantCallSite,2,Object getTarget(),False,,NULL
1,ConstantCallSite,3,CallSite dynamicInvoker(),False,,NULL
1,ConstantCallSite,4,void setTarget(MethodHandle newTarget),True,,"

setTarget
public final void setTarget(MethodHandle ignore)
Always throws an UnsupportedOperationException.
 This kind of call site cannot change its target.

Specified by:
setTarget in class CallSite
Parameters:
ignore - a new target proposed for the call site, which is ignored
Throws:
UnsupportedOperationException - because this kind of call site cannot change its target
See Also:
CallSite.getTarget(), 
setTarget(java.lang.invoke.MethodHandle), 
MutableCallSite.setTarget(java.lang.invoke.MethodHandle), 
VolatileCallSite.setTarget(java.lang.invoke.MethodHandle)


"
1,ConstantCallSite,5,void setTargetNormal(MethodHandle newTarget),False,,NULL
3,MethodHandle,1,Object invoke(Object... args),True,,"

invoke
public final Object invoke(Object... args)
                    throws Throwable
Invokes the method handle, allowing any caller type descriptor,
 and optionally performing conversions on arguments and return values.
 
 If the call site's symbolic type descriptor exactly matches this method handle's type,
 the call proceeds as if by invokeExact.
 
 Otherwise, the call proceeds as if this method handle were first
 adjusted by calling asType to adjust this method handle
 to the required type, and then the call proceeds as if by
 invokeExact on the adjusted method handle.
 
 There is no guarantee that the asType call is actually made.
 If the JVM can predict the results of making the call, it may perform
 adaptations directly on the caller's arguments,
 and call the target method handle according to its own exact type.
 
 The resolved type descriptor at the call site of invoke must
 be a valid argument to the receivers asType method.
 In particular, the caller must specify the same argument arity
 as the callee's type,
 if the callee is not a variable arity collector.
 
 When this method is observed via the Core Reflection API,
 it will appear as a single native method, taking an object array and returning an object.
 If this native method is invoked directly via
 java.lang.reflect.Method.invoke, via JNI,
 or indirectly via Lookup.unreflect,
 it will throw an UnsupportedOperationException.

Parameters:
args - the signature-polymorphic parameter list, statically represented using varargs
Returns:
the signature-polymorphic result, statically represented using Object
Throws:
WrongMethodTypeException - if the target's type cannot be adjusted to the caller's symbolic type descriptor
ClassCastException - if the target's type can be adjusted to the caller, but a reference cast fails
Throwable - anything thrown by the underlying method propagates unchanged through the method handle call


"
3,MethodHandle,2,MethodType type(),True,,"

type
public MethodType type()
Reports the type of this method handle.
 Every invocation of this method handle via invokeExact must exactly match this type.

Returns:
the method handle type


"
3,MethodHandle,3,MethodHandle asType(MethodType newType),True,,"

asType
public MethodHandle asType(MethodType newType)
Produces an adapter method handle which adapts the type of the
 current method handle to a new type.
 The resulting method handle is guaranteed to report a type
 which is equal to the desired new type.
 
 If the original type and new type are equal, returns this.
 
 The new method handle, when invoked, will perform the following
 steps:
 
Convert the incoming argument list to match the original
     method handle's argument list.
 Invoke the original method handle on the converted argument list.
 Convert any result returned by the original method handle
     to the return type of new method handle.
 

 This method provides the crucial behavioral difference between
 invokeExact and plain, inexact invoke.
 The two methods
 perform the same steps when the caller's type descriptor exactly m atches
 the callee's, but when the types differ, plain invoke
 also calls asType (or some internal equivalent) in order
 to match up the caller's and callee's types.
 
 If the current method is a variable arity method handle
 argument list conversion may involve the conversion and collection
 of several arguments into an array, as
 described elsewhere.
 In every other case, all conversions are applied pairwise,
 which means that each argument or return value is converted to
 exactly one argument or return value (or no return value).
 The applied conversions are defined by consulting the
 the corresponding component types of the old and new
 method handle types.
 
 Let T0 and T1 be corresponding new and old parameter types,
 or old and new return types.  Specifically, for some valid index i, let
 T0=newType.parameterType(i) and T1=this.type().parameterType(i).
 Or else, going the other way for return values, let
 T0=this.type().returnType() and T1=newType.returnType().
 If the types are the same, the new method handle makes no change
 to the corresponding argument or return value (if any).
 Otherwise, one of the following conversions is applied
 if possible:
 
If T0 and T1 are references, then a cast to T1 is applied.
     (The types do not need to be related in any particular way.
     This is because a dynamic value of null can convert to any reference type.)
 If T0 and T1 are primitives, then a Java method invocation
     conversion (JLS 5.3) is applied, if one exists.
     (Specifically, T0 must convert to T1 by a widening primitive conversion.)
 If T0 is a primitive and T1 a reference,
     a Java casting conversion (JLS 5.5) is applied if one exists.
     (Specifically, the value is boxed from T0 to its wrapper class,
     which is then widened as needed to T1.)
 If T0 is a reference and T1 a primitive, an unboxing
     conversion will be applied at runtime, possibly followed
     by a Java method invocation conversion (JLS 5.3)
     on the primitive value.  (These are the primitive widening conversions.)
     T0 must be a wrapper class or a supertype of one.
     (In the case where T0 is Object, these are the conversions
     allowed by java.lang.reflect.Method.invoke.)
     The unboxing conversion must have a possibility of success, which means that
     if T0 is not itself a wrapper class, there must exist at least one
     wrapper class TW which is a subtype of T0 and whose unboxed
     primitive value can be widened to T1.
 If the return type T1 is marked as void, any returned value is discarded
 If the return type T0 is void and T1 a reference, a null value is introduced.
 If the return type T0 is void and T1 a primitive,
     a zero value is introduced.
 
 (Note: Both T0 and T1 may be regarded as static types,
 because neither corresponds specifically to the dynamic type of any
 actual argument or return value.)
 
 The method handle conversion cannot be made if any one of the required
 pairwise conversions cannot be made.
 
 At runtime, the conversions applied to reference arguments
 or return values may require additional runtime checks which can fail.
 An unboxing operation may fail because the original reference is null,
 causing a NullPointerException.
 An unboxing operation or a reference cast may also fail on a reference
 to an object of the wrong type,
 causing a ClassCastException.
 Although an unboxing operation may accept several kinds of wrappers,
 if none are available, a ClassCastException will be thrown.

Parameters:
newType - the expected type of the new method handle
Returns:
a method handle which delegates to this after performing
           any necessary argument conversions, and arranges for any
           necessary return value conversions
Throws:
NullPointerException - if newType is a null reference
WrongMethodTypeException - if the conversion cannot be made
See Also:
MethodHandles.explicitCastArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType)


"
3,MethodHandle,4,MethodHandle bindTo(Object value),True,,"

bindTo
public MethodHandle bindTo(Object x)
Binds a value x to the first argument of a method handle, without invoking it.
 The new method handle adapts, as its target,
 the current method handle by binding it to the given argument.
 The type of the bound handle will be
 the same as the type of the target, except that a single leading
 reference parameter will be omitted.
 
 When called, the bound handle inserts the given value x
 as a new leading argument to the target.  The other arguments are
 also passed unchanged.
 What the target eventually returns is returned unchanged by the bound handle.
 
 The reference x must be convertible to the first parameter
 type of the target.
 
 (Note:  Because method handles are immutable, the target method handle
 retains its original type and behavior.)

Parameters:
x - the value to bind to the first argument of the target
Returns:
a new method handle which prepends the given value to the incoming
         argument list, before calling the original method handle
Throws:
IllegalArgumentException - if the target does not have a
         leading parameter type that is a reference type
ClassCastException - if x cannot be converted
         to the leading parameter type of the target
See Also:
MethodHandles.insertArguments(java.lang.invoke.MethodHandle, int, java.lang.Object...)


"
3,MethodHandle,5,"MethodHandle dropArguments(int pos, Class<?>... types)",False,,NULL
4,MethodHandleProxies,1,"Object asInterfaceInstance(Class<?> intfc, MethodHandle target)",False,,NULL
4,MethodHandleProxies,2,"MethodHandle asCollector(Class<?> arrayType, int arrayLength)",False,,NULL
4,MethodHandleProxies,3,MethodHandle asVarargsCollector(Class<?> arrayType),False,,NULL
4,MethodHandleProxies,4,"MethodHandle filterArguments(int pos, MethodHandle filter, MethodHandle target)",False,,NULL
4,MethodHandleProxies,5,"MethodHandle foldArguments(MethodHandle target, MethodHandle combiner)",False,,NULL
5,MethodHandles,1,MethodHandle asType(MethodType newType),False,,NULL
5,MethodHandles,2,MethodHandle bindTo(Object x),False,,NULL
5,MethodHandles,3,"MethodHandle dropArguments(int pos, Class<?>... types)",False,,NULL
5,MethodHandles,4,"MethodHandle filterArguments(int pos, MethodHandle filter, MethodHandle... filters)",False,,NULL
5,MethodHandles,5,"MethodHandle asCollector(Class<?> arrayType, int arrayLength)",False,,NULL
7,MethodType,1,MethodType genericMethodType(Class<?>... ptypes),False,,NULL
7,MethodType,2,"MethodType changeParameterType(int num, Class<?> nptype)",True,,"

changeParameterType
public MethodType changeParameterType(int num,
                                      Class<?> nptype)
Finds or creates a method type with a single different parameter type.
 Convenience method for methodType.

Parameters:
num - the index (zero-based) of the parameter type to change
nptype - a new parameter type to replace the old one with
Returns:
the same type, except with the selected parameter changed
Throws:
IndexOutOfBoundsException - if num is not a valid index into parameterArray()
IllegalArgumentException - if nptype is void.class
NullPointerException - if nptype is null


"
7,MethodType,3,MethodType changeReturnType(Class<?> nrtype),True,,"

changeReturnType
public MethodType changeReturnType(Class<?> nrtype)
Finds or creates a method type with a different return type.
 Convenience method for methodType.

Parameters:
nrtype - a return parameter type to replace the old one with
Returns:
the same type, except with the return type change
Throws:
NullPointerException - if nrtype is null


"
7,MethodType,4,"MethodType dropParameterTypes(int start, int end)",True,,"

dropParameterTypes
public MethodType dropParameterTypes(int start,
                                     int end)
Finds or creates a method type with some parameter types omitted.
 Convenience method for methodType.

Parameters:
start - the index (zero-based) of the first parameter type to remove
end - the index (greater than start) of the first parameter type after not to remove
Returns:
the same type, except with the selected parameter(s) removed
Throws:
IndexOutOfBoundsException - if start is negative or greater than parameterCount()
                                  or if end is negative or greater than parameterCount()
                                  or if start is greater than end


"
7,MethodType,5,"MethodType insertParameterTypes(int pos, Class<?>... ptypes)",True,,"

insertParameterTypes
public MethodType insertParameterTypes(int num,
                                       Class<?>... ptypesToInsert)
Finds or creates a method type with additional parameter types.
 Convenience method for methodType.

Parameters:
num - the position (zero-based) of the inserted parameter type(s)
ptypesToInsert - zero or more new parameter types to insert into the parameter list
Returns:
the same type, except with the selected parameter(s) inserted
Throws:
IndexOutOfBoundsException - if num is negative or greater than parameterCount()
IllegalArgumentException - if any element of ptypesToInsert is void.class
                                  or if the resulting method type would have more than 255 parameter slots
NullPointerException - if ptypesToInsert or any of its elements is null


"
8,MutableCallSite,1,void setTarget(MethodHandle newTarget),True,,"

setTarget
public void setTarget(MethodHandle newTarget)
Updates the target method of this call site, as a normal variable.
 The type of the new target must agree with the type of the old target.
 
 The interactions with memory are the same
 as of a write to an ordinary variable, such as an array element or a
 non-volatile, non-final field.
 
 In particular, unrelated threads may fail to see the updated target
 until they perform a read from memory.
 Stronger guarantees can be created by putting appropriate operations
 into the bootstrap method and/or the target methods used
 at any given call site.

Specified by:
setTarget in class CallSite
Parameters:
newTarget - the new target
Throws:
NullPointerException - if the proposed new target is null
WrongMethodTypeException - if the proposed new target
         has a method type that differs from the previous target
See Also:
getTarget()


"
8,MutableCallSite,2,MethodHandle getTarget(),True,,"

getTarget
public final MethodHandle getTarget()
Returns the target method of the call site, which behaves
 like a normal field of the MutableCallSite.
 
 The interactions of getTarget with memory are the same
 as of a read from an ordinary variable, such as an array element or a
 non-volatile, non-final field.
 
 In particular, the current thread may choose to reuse the result
 of a previous read of the target from memory, and may fail to see
 a recent update to the target by another thread.

Specified by:
getTarget in class CallSite
Returns:
the linkage state of this call site, a method handle which can change over time
See Also:
setTarget(java.lang.invoke.MethodHandle)


"
8,MutableCallSite,3,void syncAll(MutableCallSite[] sites),True,,"

syncAll
public static void syncAll(MutableCallSite[] sites)
Performs a synchronization operation on each call site in the given array,
 forcing all other threads to throw away any cached values previously
 loaded from the target of any of the call sites.
 
 This operation does not reverse any calls that have already started
 on an old target value.
 (Java supports forward time travel only.)
 
 The overall effect is to force all future readers of each call site's target
 to accept the most recently stored value.
 (""Most recently"" is reckoned relative to the syncAll itself.)
 Conversely, the syncAll call may block until all readers have
 (somehow) decached all previous versions of each call site's target.
 
 To avoid race conditions, calls to setTarget and syncAll
 should generally be performed under some sort of mutual exclusion.
 Note that reader threads may observe an updated target as early
 as the setTarget call that install the value
 (and before the syncAll that confirms the value).
 On the other hand, reader threads may observe previous versions of
 the target until the syncAll call returns
 (and after the setTarget that attempts to convey the updated version).
 
 This operation is likely to be expensive and should be used sparingly.
 If possible, it should be buffered for batch processing on sets of call sites.
 
 If sites contains a null element,
 a NullPointerException will be raised.
 In this case, some non-null elements in the array may be
 processed before the method returns abnormally.
 Which elements these are (if any) is implementation-dependent.

 Java Memory Model details
 In terms of the Java Memory Model, this operation performs a synchronization
 action which is comparable in effect to the writing of a volatile variable
 by the current thread, and an eventual volatile read by every other thread
 that may access one of the affected call sites.
 
 The following effects are apparent, for each individual call site S:
 
A new volatile variable V is created, and written by the current thread.
     As defined by the JMM, this write is a global synchronization event.
 As is normal with thread-local ordering of write events,
     every action already performed by the current thread is
     taken to happen before the volatile write to V.
     (In some implementations, this means that the current thread
     performs a global release operation.)
 Specifically, the write to the current target of S is
     taken to happen before the volatile write to V.
 The volatile write to V is placed
     (in an implementation specific manner)
     in the global synchronization order.
 Consider an arbitrary thread T (other than the current thread).
     If T executes a synchronization action A
     after the volatile write to V (in the global synchronization order),
     it is therefore required to see either the current target
     of S, or a later write to that target,
     if it executes a read on the target of S.
     (This constraint is called ""synchronization-order consistency"".)
 The JMM specifically allows optimizing compilers to elide
     reads or writes of variables that are known to be useless.
     Such elided reads and writes have no effect on the happens-before
     relation.  Regardless of this fact, the volatile V
     will not be elided, even though its written value is
     indeterminate and its read value is not used.
 
 Because of the last point, the implementation behaves as if a
 volatile read of V were performed by T
 immediately after its action A.  In the local ordering
 of actions in T, this read happens before any future
 read of the target of S.  It is as if the
 implementation arbitrarily picked a read of S's target
 by T, and forced a read of V to precede it,
 thereby ensuring communication of the new target value.
 
 As long as the constraints of the Java Memory Model are obeyed,
 implementations may delay the completion of a syncAll
 operation while other threads (T above) continue to
 use previous values of S's target.
 However, implementations are (as always) encouraged to avoid
 livelock, and to eventually require all threads to take account
 of the updated target.

 
Discussion:
 For performance reasons, syncAll is not a virtual method
 on a single call site, but rather applies to a set of call sites.
 Some implementations may incur a large fixed overhead cost
 for processing one or more synchronization operations,
 but a small incremental cost for each additional call site.
 In any case, this operation is likely to be costly, since
 other threads may have to be somehow interrupted
 in order to make them notice the updated target value.
 However, it may be observed that a single call to synchronize
 several sites has the same formal effect as many calls,
 each on just one of the sites.

 
Implementation Note:
 Simple implementations of MutableCallSite may use
 a volatile variable for the target of a mutable call site.
 In such an implementation, the syncAll method can be a no-op,
 and yet it will conform to the JMM behavior documented above.

Parameters:
sites - an array of call sites to be synchronized
Throws:
NullPointerException - if the sites array reference is null
                              or the array contains a null


"
8,MutableCallSite,4,void syncWith(MutableCallSite other),False,,NULL
8,MutableCallSite,5,void setTargetNormal(MethodHandle newTarget),False,,NULL
9,SerializedLambda,1,String getImplMethodName(),True,,"

getImplMethodName
public String getImplMethodName()
Get the name of the implementation method.

Returns:
the name of the implementation method


"
9,SerializedLambda,2,String getImplMethodSignature(),True,,"

getImplMethodSignature
public String getImplMethodSignature()
Get the signature of the implementation method.

Returns:
the signature of the implementation method


"
9,SerializedLambda,3,String getImplMethodKind(),False,,NULL
9,SerializedLambda,4,Object getCapturedArg(int argIndex),True,,"

getCapturedArg
public Object getCapturedArg(int i)
Get a dynamic argument to the lambda capture site.

Parameters:
i - the argument to capture
Returns:
a dynamic argument to the lambda capture site


"
9,SerializedLambda,5,Object getCapturedArg(String argName),False,,NULL
10,SwitchPoint,1,SwitchPoint invalidateAndSwitch(),False,,NULL
10,SwitchPoint,2,boolean hasBeenInvalidated(),True,,"

hasBeenInvalidated
public boolean hasBeenInvalidated()
Determines if this switch point has been invalidated yet.

 
Discussion:
 Because of the one-way nature of invalidation, once a switch point begins
 to return true for hasBeenInvalidated,
 it will always do so in the future.
 On the other hand, a valid switch point visible to other threads may
 be invalidated at any moment, due to a request by another thread.
 
 Since invalidation is a global and immediate operation,
 the execution of this query, on a valid switchpoint,
 must be internally sequenced with any
 other threads that could cause invalidation.
 This query may therefore be expensive.
 The recommended way to build a boolean-valued method handle
 which queries the invalidation state of a switch point s is
 to call s.guardWithTest on
 constant true and false method handles.

Returns:
true if this switch point has been invalidated


"
10,SwitchPoint,3,void invalidate(),False,,NULL
10,SwitchPoint,4,boolean isValid(),False,,NULL
10,SwitchPoint,5,"void guardWithTest(MethodHandle fallback, MethodHandle target)",False,,NULL
11,VolatileCallSite,1,void setTarget(MethodHandle target),True,,"

setTarget
public void setTarget(MethodHandle newTarget)
Updates the target method of this call site, as a volatile variable.
 The type of the new target must agree with the type of the old target.
 
 The interactions with memory are the same as of a write to a volatile field.
 In particular, any threads is guaranteed to see the updated target
 the next time it calls getTarget.

Specified by:
setTarget in class CallSite
Parameters:
newTarget - the new target
Throws:
NullPointerException - if the proposed new target is null
WrongMethodTypeException - if the proposed new target
         has a method type that differs from the previous target
See Also:
getTarget()


"
11,VolatileCallSite,2,MethodHandle getTarget(),True,,"

getTarget
public final MethodHandle getTarget()
Returns the target method of the call site, which behaves
 like a volatile field of the VolatileCallSite.
 
 The interactions of getTarget with memory are the same
 as of a read from a volatile field.
 
 In particular, the current thread is required to issue a fresh
 read of the target from memory, and must not fail to see
 a recent update to the target by another thread.

Specified by:
getTarget in class CallSite
Returns:
the linkage state of this call site, a method handle which can change over time
See Also:
setTarget(java.lang.invoke.MethodHandle)


"
11,VolatileCallSite,3,void setTargetNormal(MethodHandle target),False,,NULL
11,VolatileCallSite,4,void setTargetVolatile(MethodHandle target),False,,NULL
11,VolatileCallSite,5,void syncAll(VolatileCallSite[] sites),False,,NULL
