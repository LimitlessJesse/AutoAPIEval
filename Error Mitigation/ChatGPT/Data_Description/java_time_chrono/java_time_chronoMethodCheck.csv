Sample Number,ClassName,Snippet Number,Method,Exist,Description,Full Description
0,AbstractChronology,1,"ChronoLocalDate date(int prolepticYear, int month, int dayOfMonth)",False,,NULL
0,AbstractChronology,2,ChronoLocalDate dateNow(),False,,NULL
0,AbstractChronology,3,ChronoLocalDate dateNow(Clock clock),False,,NULL
0,AbstractChronology,4,ChronoLocalDate dateNow(ZoneId zone),False,,NULL
0,AbstractChronology,5,ChronoLocalDate dateNow(Chronology chrono),False,,NULL
1,HijrahChronology,1,"HijrahDate date(int prolepticYear, int month, int dayOfMonth)",True,,"

date
public HijrahDate date(int prolepticYear,
                       int month,
                       int dayOfMonth)
Obtains a local date in Hijrah calendar system from the
 proleptic-year, month-of-year and day-of-month fields.

Specified by:
date in interface Chronology
Parameters:
prolepticYear - the proleptic-year
month - the month-of-year
dayOfMonth - the day-of-month
Returns:
the Hijrah local date, not null
Throws:
DateTimeException - if unable to create the date


"
1,HijrahChronology,2,HijrahDate date(TemporalAccessor temporal),True,,"

date
public HijrahDate date(TemporalAccessor temporal)
Description copied from interface: Chronology
Obtains a local date in this chronology from another temporal object.
 
 This obtains a date in this chronology based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ChronoLocalDate.
 
 The conversion typically uses the EPOCH_DAY
 field, which is standardized across calendar systems.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, aChronology::date.

Specified by:
date in interface Chronology
Parameters:
temporal - the temporal object to convert, not null
Returns:
the local date in this chronology, not null
See Also:
ChronoLocalDate.from(TemporalAccessor)


"
1,HijrahChronology,3,HijrahEra eraOf(int eraValue),True,,"

eraOf
public HijrahEra eraOf(int eraValue)
Description copied from interface: Chronology
Creates the chronology era object from the numeric value.
 
 The era is, conceptually, the largest division of the time-line.
 Most calendar systems have a single epoch dividing the time-line into two eras.
 However, some have multiple eras, such as one for the reign of each leader.
 The exact meaning is determined by the chronology according to the following constraints.
 
 The era in use at 1970-01-01 must have the value 1.
 Later eras must have sequentially higher values.
 Earlier eras must have sequentially lower values.
 Each chronology must refer to an enum or similar singleton to provide the era values.
 
 This method returns the singleton era of the correct type for the specified era value.

Specified by:
eraOf in interface Chronology
Parameters:
eraValue - the era value
Returns:
the calendar system era, not null


"
1,HijrahChronology,4,HijrahDate now(),False,,NULL
1,HijrahChronology,5,HijrahDate dateNow(Clock clock),True,,"

dateNow
public HijrahDate dateNow(Clock clock)
Description copied from interface: Chronology
Obtains the current local date in this chronology from the specified clock.
 
 This will query the specified clock to obtain the current date - today.
 Using this method allows the use of an alternate clock for testing.
 The alternate clock may be introduced using dependency injection.

Specified by:
dateNow in interface Chronology
Parameters:
clock - the clock to use, not null
Returns:
the current local date, not null


"
2,HijrahDate,1,HijrahDate plusDays(long days),False,,NULL
2,HijrahDate,2,HijrahDate minusDays(long days),False,,NULL
2,HijrahDate,3,HijrahDate with(TemporalAdjuster adjuster),True,,"

with
public HijrahDate with(TemporalAdjuster adjuster)
Returns an adjusted object of the same type as this object with the adjustment made.
 
 This adjusts this date-time according to the rules of the specified adjuster.
 A simple adjuster might simply set the one of the fields, such as the year field.
 A more complex adjuster might set the date to the last day of the month.
 A selection of common adjustments is provided in
 TemporalAdjusters.
 These include finding the ""last day of the month"" and ""next Wednesday"".
 The adjuster is responsible for handling special cases, such as the varying
 lengths of month and leap years.
 
 Some example code indicating how and why this method is used:
 
  date = date.with(Month.JULY);        // most key classes implement TemporalAdjuster
  date = date.with(lastDayOfMonth());  // static import from Adjusters
  date = date.with(next(WEDNESDAY));   // static import from Adjusters and DayOfWeek
 

Specified by:
with in interface ChronoLocalDate
Specified by:
with in interface Temporal
Parameters:
adjuster - the adjuster to use, not null
Returns:
an object of the same type with the specified adjustment made, not null
Throws:
DateTimeException - if unable to make the adjustment.
     For example, if the adjuster requires an ISO chronology
ArithmeticException - if numeric overflow occurs


"
2,HijrahDate,4,HijrahDate withYear(int year),False,,NULL
2,HijrahDate,5,HijrahDate withMonth(int month),False,,NULL
3,IsoChronology,1,IsoChronology getInstance(),False,,NULL
3,IsoChronology,2,boolean isLeapYear(long prolepticYear),True,,"

isLeapYear
public boolean isLeapYear(long prolepticYear)
Checks if the year is a leap year, according to the ISO proleptic
 calendar system rules.
 
 This method applies the current rules for leap years across the whole time-line.
 In general, a year is a leap year if it is divisible by four without
 remainder. However, years divisible by 100, are not leap years, with
 the exception of years divisible by 400 which are.
 
 For example, 1904 is a leap year it is divisible by 4.
 1900 was not a leap year as it is divisible by 100, however 2000 was a
 leap year as it is divisible by 400.
 
 The calculation is proleptic - applying the same rules into the far future and far past.
 This is historically inaccurate, but is correct for the ISO-8601 standard.

Specified by:
isLeapYear in interface Chronology
Parameters:
prolepticYear - the ISO proleptic year to check
Returns:
true if the year is leap, false otherwise


"
3,IsoChronology,3,"int prolepticYear(Era era, int yearOfEra)",True,,"

prolepticYear
public int prolepticYear(Era era,
                         int yearOfEra)
Description copied from interface: Chronology
Calculates the proleptic-year given the era and year-of-era.
 
 This combines the era and year-of-era into the single proleptic-year field.
 
 If the chronology makes active use of eras, such as JapaneseChronology
 then the year-of-era will be validated against the era.
 For other chronologies, validation is optional.

Specified by:
prolepticYear in interface Chronology
Parameters:
era - the era of the correct type for the chronology, not null
yearOfEra - the chronology year-of-era
Returns:
the proleptic-year


"
3,IsoChronology,4,IsoEra eraOf(int eraValue),True,,"

eraOf
public IsoEra eraOf(int eraValue)
Description copied from interface: Chronology
Creates the chronology era object from the numeric value.
 
 The era is, conceptually, the largest division of the time-line.
 Most calendar systems have a single epoch dividing the time-line into two eras.
 However, some have multiple eras, such as one for the reign of each leader.
 The exact meaning is determined by the chronology according to the following constraints.
 
 The era in use at 1970-01-01 must have the value 1.
 Later eras must have sequentially higher values.
 Earlier eras must have sequentially lower values.
 Each chronology must refer to an enum or similar singleton to provide the era values.
 
 This method returns the singleton era of the correct type for the specified era value.

Specified by:
eraOf in interface Chronology
Parameters:
eraValue - the era value
Returns:
the calendar system era, not null


"
3,IsoChronology,5,int eraValue(Era era),False,,NULL
4,JapaneseChronology,1,"JapaneseDate date(int prolepticYear, int month, int dayOfMonth)",True,,"

date
public JapaneseDate date(int prolepticYear,
                         int month,
                         int dayOfMonth)
Obtains a local date in Japanese calendar system from the
 proleptic-year, month-of-year and day-of-month fields.
 
 The Japanese proleptic year, month and day-of-month are the same as those
 in the ISO calendar system. They are not reset when the era changes.

Specified by:
date in interface Chronology
Parameters:
prolepticYear - the proleptic-year
month - the month-of-year
dayOfMonth - the day-of-month
Returns:
the Japanese local date, not null
Throws:
DateTimeException - if unable to create the date


"
4,JapaneseChronology,2,JapaneseEra eraOf(int eraValue),True,,"

eraOf
public JapaneseEra eraOf(int eraValue)
Returns the calendar system era object from the given numeric value.

 See the description of each Era for the numeric values of:
 JapaneseEra.HEISEI, JapaneseEra.SHOWA,JapaneseEra.TAISHO,
 JapaneseEra.MEIJI), only Meiji and later eras are supported.

Specified by:
eraOf in interface Chronology
Parameters:
eraValue - the era value
Returns:
the Japanese Era for the given numeric era value
Throws:
DateTimeException - if eraValue is invalid


"
4,JapaneseChronology,3,"JapaneseDate date(Era era, int yearOfEra, int month, int dayOfMonth)",True,,"

date
public JapaneseDate date(Era era,
                         int yearOfEra,
                         int month,
                         int dayOfMonth)
Obtains a local date in Japanese calendar system from the
 era, year-of-era, month-of-year and day-of-month fields.
 
 The Japanese month and day-of-month are the same as those in the
 ISO calendar system. They are not reset when the era changes.
 For example:
 
  6th Jan Showa 64 = ISO 1989-01-06
  7th Jan Showa 64 = ISO 1989-01-07
  8th Jan Heisei 1 = ISO 1989-01-08
  9th Jan Heisei 1 = ISO 1989-01-09
 

Specified by:
date in interface Chronology
Parameters:
era - the Japanese era, not null
yearOfEra - the year-of-era
month - the month-of-year
dayOfMonth - the day-of-month
Returns:
the Japanese local date, not null
Throws:
DateTimeException - if unable to create the date
ClassCastException - if the era is not a JapaneseEra


"
4,JapaneseChronology,4,JapaneseDate dateNow(),True,,"

dateNow
public JapaneseDate dateNow()
Description copied from interface: Chronology
Obtains the current local date in this chronology from the system clock in the default time-zone.
 
 This will query the system clock in the default
 time-zone to obtain the current date.
 
 Using this method will prevent the ability to use an alternate clock for testing
 because the clock is hard-coded.

Specified by:
dateNow in interface Chronology
Returns:
the current local date using the system clock and default time-zone, not null


"
4,JapaneseChronology,5,JapaneseDate dateNow(Clock clock),True,,"

dateNow
public JapaneseDate dateNow(Clock clock)
Description copied from interface: Chronology
Obtains the current local date in this chronology from the specified clock.
 
 This will query the specified clock to obtain the current date - today.
 Using this method allows the use of an alternate clock for testing.
 The alternate clock may be introduced using dependency injection.

Specified by:
dateNow in interface Chronology
Parameters:
clock - the clock to use, not null
Returns:
the current local date, not null


"
5,JapaneseDate,1,JapaneseDate plusDays(long days),False,,NULL
5,JapaneseDate,2,JapaneseDate minusDays(long days),False,,NULL
5,JapaneseDate,3,JapaneseEra getEra(),True,,"

getEra
public JapaneseEra getEra()
Gets the era applicable at this date.
 
 The Japanese calendar system has multiple eras defined by JapaneseEra.

Specified by:
getEra in interface ChronoLocalDate
Returns:
the era applicable at this date, not null


"
5,JapaneseDate,4,int lengthOfMonth(),True,,"

lengthOfMonth
public int lengthOfMonth()
Returns the length of the month represented by this date.
 
 This returns the length of the month in days.
 Month lengths match those of the ISO calendar system.

Specified by:
lengthOfMonth in interface ChronoLocalDate
Returns:
the length of the month in days


"
5,JapaneseDate,5,"JapaneseDate with(ChronoField field, long newValue)",False,,NULL
6,JapaneseEra,1,int getValue(),True,,"

getValue
public int getValue()
Gets the numeric era int value.
 
 The SHOWA era that contains 1970-01-01 (ISO calendar system) has the value 1.
 Later eras are numbered from 2 (HEISEI).
 Earlier eras are numbered 0 (TAISHO), -1 (MEIJI)).

Specified by:
getValue in interface Era
Returns:
the era value


"
6,JapaneseEra,2,"String getDisplayName(TextStyle style, Locale locale)",True,,"

getDisplayName
public String getDisplayName(TextStyle style,
                             Locale locale)
Gets the textual representation of this era.
 
 This returns the textual name used to identify the era,
 suitable for presentation to the user.
 The parameters control the style of the returned text and the locale.
 
 If no textual mapping is found then the numeric value is returned.

Specified by:
getDisplayName in interface Era
Parameters:
style - the style of the text required, not null
locale - the locale to use, not null
Returns:
the text value of the era, not null


"
6,JapaneseEra,3,boolean isSupported(TemporalField field),False,,NULL
6,JapaneseEra,4,JapaneseEra of(int japaneseEraValue),True,,"

of
public static JapaneseEra of(int japaneseEra)
Obtains an instance of JapaneseEra from an int value.
 
The value 1 is associated with the 'Showa' era, because
 it contains 1970-01-01 (ISO calendar system).
The values -1 and 0 are associated with two earlier
 eras, Meiji and Taisho, respectively.
A value greater than 1 is associated with a later era,
 beginning with Heisei (2).


 Every instance of JapaneseEra that is returned from the values()
 method has an int value (available via Era.getValue() which is
 accepted by this method.

Parameters:
japaneseEra - the era to represent
Returns:
the JapaneseEra singleton, not null
Throws:
DateTimeException - if the value is invalid


"
6,JapaneseEra,5,int compareTo(JapaneseEra other),False,,NULL
7,MinguoChronology,1,MinguoChronology of(String calendarId),False,,NULL
7,MinguoChronology,2,MinguoDate now(),False,,NULL
7,MinguoChronology,3,"MinguoDate date(int prolepticYear, int month, int dayOfMonth)",True,,"

date
public MinguoDate date(int prolepticYear,
                       int month,
                       int dayOfMonth)
Obtains a local date in Minguo calendar system from the
 proleptic-year, month-of-year and day-of-month fields.

Specified by:
date in interface Chronology
Parameters:
prolepticYear - the proleptic-year
month - the month-of-year
dayOfMonth - the day-of-month
Returns:
the Minguo local date, not null
Throws:
DateTimeException - if unable to create the date


"
7,MinguoChronology,4,MinguoDate date(TemporalAccessor temporal),True,,"

date
public MinguoDate date(TemporalAccessor temporal)
Description copied from interface: Chronology
Obtains a local date in this chronology from another temporal object.
 
 This obtains a date in this chronology based on the specified temporal.
 A TemporalAccessor represents an arbitrary set of date and time information,
 which this factory converts to an instance of ChronoLocalDate.
 
 The conversion typically uses the EPOCH_DAY
 field, which is standardized across calendar systems.
 
 This method matches the signature of the functional interface TemporalQuery
 allowing it to be used as a query via method reference, aChronology::date.

Specified by:
date in interface Chronology
Parameters:
temporal - the temporal object to convert, not null
Returns:
the local date in this chronology, not null
See Also:
ChronoLocalDate.from(TemporalAccessor)


"
7,MinguoChronology,5,"MinguoDate dateYearDay(int prolepticYear, int dayOfYear)",True,,"

dateYearDay
public MinguoDate dateYearDay(int prolepticYear,
                              int dayOfYear)
Obtains a local date in Minguo calendar system from the
 proleptic-year and day-of-year fields.

Specified by:
dateYearDay in interface Chronology
Parameters:
prolepticYear - the proleptic-year
dayOfYear - the day-of-year
Returns:
the Minguo local date, not null
Throws:
DateTimeException - if unable to create the date


"
8,MinguoDate,1,int getYear(),False,,NULL
8,MinguoDate,2,int getMonthValue(),False,,NULL
8,MinguoDate,3,int getDayOfMonth(),False,,NULL
8,MinguoDate,4,DayOfWeek getDayOfWeek(),False,,NULL
8,MinguoDate,5,LocalDate toLocalDate(),False,,NULL
9,ThaiBuddhistChronology,1,"ThaiBuddhistDate date(int prolepticYear, int month, int dayOfMonth)",True,,"

date
public ThaiBuddhistDate date(int prolepticYear,
                             int month,
                             int dayOfMonth)
Obtains a local date in Thai Buddhist calendar system from the
 proleptic-year, month-of-year and day-of-month fields.

Specified by:
date in interface Chronology
Parameters:
prolepticYear - the proleptic-year
month - the month-of-year
dayOfMonth - the day-of-month
Returns:
the Thai Buddhist local date, not null
Throws:
DateTimeException - if unable to create the date


"
9,ThaiBuddhistChronology,2,"ThaiBuddhistDate date(Era era, int yearOfEra, int month, int dayOfMonth)",True,,"

date
public ThaiBuddhistDate date(Era era,
                             int yearOfEra,
                             int month,
                             int dayOfMonth)
Obtains a local date in Thai Buddhist calendar system from the
 era, year-of-era, month-of-year and day-of-month fields.

Specified by:
date in interface Chronology
Parameters:
era - the Thai Buddhist era, not null
yearOfEra - the year-of-era
month - the month-of-year
dayOfMonth - the day-of-month
Returns:
the Thai Buddhist local date, not null
Throws:
DateTimeException - if unable to create the date
ClassCastException - if the era is not a ThaiBuddhistEra


"
9,ThaiBuddhistChronology,3,"ThaiBuddhistDate dateYearDay(int prolepticYear, int dayOfYear)",True,,"

dateYearDay
public ThaiBuddhistDate dateYearDay(int prolepticYear,
                                    int dayOfYear)
Obtains a local date in Thai Buddhist calendar system from the
 proleptic-year and day-of-year fields.

Specified by:
dateYearDay in interface Chronology
Parameters:
prolepticYear - the proleptic-year
dayOfYear - the day-of-year
Returns:
the Thai Buddhist local date, not null
Throws:
DateTimeException - if unable to create the date


"
9,ThaiBuddhistChronology,4,"ThaiBuddhistDate dateYearDay(Era era, int yearOfEra, int dayOfYear)",True,,"

dateYearDay
public ThaiBuddhistDate dateYearDay(Era era,
                                    int yearOfEra,
                                    int dayOfYear)
Obtains a local date in Thai Buddhist calendar system from the
 era, year-of-era and day-of-year fields.

Specified by:
dateYearDay in interface Chronology
Parameters:
era - the Thai Buddhist era, not null
yearOfEra - the year-of-era
dayOfYear - the day-of-year
Returns:
the Thai Buddhist local date, not null
Throws:
DateTimeException - if unable to create the date
ClassCastException - if the era is not a ThaiBuddhistEra


"
9,ThaiBuddhistChronology,5,"ThaiBuddhistDate resolveDate(Map<TemporalField, Long> fieldValues, ResolverStyle resolverStyle)",True,,"

resolveDate
public ThaiBuddhistDate resolveDate(Map<TemporalField,Long> fieldValues,
                                    ResolverStyle resolverStyle)
Description copied from class: AbstractChronology
Resolves parsed ChronoField values into a date during parsing.
 
 Most TemporalField implementations are resolved using the
 resolve method on the field. By contrast, the ChronoField class
 defines fields that only have meaning relative to the chronology.
 As such, ChronoField date fields are resolved here in the
 context of a specific chronology.
 
ChronoField instances are resolved by this method, which may
 be overridden in subclasses.
 
EPOCH_DAY - If present, this is converted to a date and
  all other date fields are then cross-checked against the date.
 PROLEPTIC_MONTH - If present, then it is split into the
  YEAR and MONTH_OF_YEAR. If the mode is strict or smart
  then the field is validated.
 YEAR_OF_ERA and ERA - If both are present, then they
  are combined to form a YEAR. In lenient mode, the YEAR_OF_ERA
  range is not validated, in smart and strict mode it is. The ERA is
  validated for range in all three modes. If only the YEAR_OF_ERA is
  present, and the mode is smart or lenient, then the last available era
  is assumed. In strict mode, no era is assumed and the YEAR_OF_ERA is
  left untouched. If only the ERA is present, then it is left untouched.
 YEAR, MONTH_OF_YEAR and DAY_OF_MONTH -
  If all three are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is smart or strict, then the month and day are validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the first month in the requested year,
  then adding the difference in months, then the difference in days.
  If the mode is smart, and the day-of-month is greater than the maximum for
  the year-month, then the day-of-month is adjusted to the last day-of-month.
  If the mode is strict, then the three fields must form a valid date.
 YEAR and DAY_OF_YEAR -
  If both are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the difference in days.
  If the mode is smart or strict, then the two fields must form a valid date.
 YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and
  ALIGNED_DAY_OF_WEEK_IN_MONTH -
  If all four are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the first month in the requested year, then adding
  the difference in months, then the difference in weeks, then in days.
  If the mode is smart or strict, then the all four fields are validated to
  their outer ranges. The date is then combined in a manner equivalent to
  creating a date on the first day of the requested year and month, then adding
  the amount in weeks and days to reach their values. If the mode is strict,
  the date is additionally validated to check that the day and week adjustment
  did not change the month.
 YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and
  DAY_OF_WEEK - If all four are present, then they are combined to
  form a date. The approach is the same as described above for
  years, months and weeks in ALIGNED_DAY_OF_WEEK_IN_MONTH.
  The day-of-week is adjusted as the next or same matching day-of-week once
  the years, months and weeks have been handled.
 YEAR, ALIGNED_WEEK_OF_YEAR and ALIGNED_DAY_OF_WEEK_IN_YEAR -
  If all three are present, then they are combined to form a date.
  In all three modes, the YEAR is validated.
  If the mode is lenient, then the date is combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the difference in weeks, then in days.
  If the mode is smart or strict, then the all three fields are validated to
  their outer ranges. The date is then combined in a manner equivalent to
  creating a date on the first day of the requested year, then adding
  the amount in weeks and days to reach their values. If the mode is strict,
  the date is additionally validated to check that the day and week adjustment
  did not change the year.
 YEAR, ALIGNED_WEEK_OF_YEAR and DAY_OF_WEEK -
  If all three are present, then they are combined to form a date.
  The approach is the same as described above for years and weeks in
  ALIGNED_DAY_OF_WEEK_IN_YEAR. The day-of-week is adjusted as the
  next or same matching day-of-week once the years and weeks have been handled.
 

 The default implementation is suitable for most calendar systems.
 If ChronoField.YEAR_OF_ERA is found without an ChronoField.ERA
 then the last era in Chronology.eras() is used.
 The implementation assumes a 7 day week, that the first day-of-month
 has the value 1, that first day-of-year has the value 1, and that the
 first of the month and year always exists.

Specified by:
resolveDate in interface Chronology
Overrides:
resolveDate in class AbstractChronology
Parameters:
fieldValues - the map of fields to values, which can be updated, not null
resolverStyle - the requested type of resolve, not null
Returns:
the resolved date, null if insufficient information to create a date


"
10,ThaiBuddhistDate,1,int getDayOfMonth(),False,,NULL
10,ThaiBuddhistDate,2,int getDayOfYear(),False,,NULL
10,ThaiBuddhistDate,3,int getMonthValue(),False,,NULL
10,ThaiBuddhistDate,4,int getYear(),False,,NULL
10,ThaiBuddhistDate,5,ThaiBuddhistDate plusDays(long daysToAdd),False,,NULL
