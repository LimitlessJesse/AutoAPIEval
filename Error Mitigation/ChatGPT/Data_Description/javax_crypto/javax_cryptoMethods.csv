ClassName,Method,Return Type,Description,Full Description
Cipher,doFinal(),byte[],"Finishes a multiple-part encryption or decryption operation, depending on how this cipher was initialized.","

doFinal
public final byte[] doFinal()
                     throws IllegalBlockSizeException,
                            BadPaddingException
Finishes a multiple-part encryption or decryption operation, depending
 on how this cipher was initialized.

 Input data that may have been buffered during a previous
 update operation is processed, with padding (if requested)
 being applied.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in a new buffer.

 Upon finishing, this method resets this cipher object to the state
 it was in when previously initialized via a call to init.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 init) more data.

 Note: if any exception is thrown, this cipher object may need to
 be reset before it can be used again.

Returns:
the new buffer with the result
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized)
IllegalBlockSizeException - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
BadPaddingException - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes
AEADBadTagException - if this cipher is decrypting in an
 AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value


"
Cipher,doFinal(byte[] input),byte[],"Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation.","

doFinal
public final byte[] doFinal(byte[] input)
                     throws IllegalBlockSizeException,
                            BadPaddingException
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation. The data is encrypted or decrypted,
 depending on how this cipher was initialized.

 The bytes in the input buffer, and any input bytes that
 may have been buffered during a previous update operation,
 are processed, with padding (if requested) being applied.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in a new buffer.

 Upon finishing, this method resets this cipher object to the state
 it was in when previously initialized via a call to init.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 init) more data.

 Note: if any exception is thrown, this cipher object may need to
 be reset before it can be used again.

Parameters:
input - the input buffer
Returns:
the new buffer with the result
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized)
IllegalBlockSizeException - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
BadPaddingException - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes
AEADBadTagException - if this cipher is decrypting in an
 AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value


"
Cipher,"doFinal(byte[] output, int outputOffset)",int,"Finishes a multiple-part encryption or decryption operation, depending on how this cipher was initialized.","

doFinal
public final int doFinal(byte[] output,
                         int outputOffset)
                  throws IllegalBlockSizeException,
                         ShortBufferException,
                         BadPaddingException
Finishes a multiple-part encryption or decryption operation, depending
 on how this cipher was initialized.

 Input data that may have been buffered during a previous
 update operation is processed, with padding (if requested)
 being applied.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in the output buffer, starting at
 outputOffset inclusive.

 If the output buffer is too small to hold the result,
 a ShortBufferException is thrown. In this case, repeat this
 call with a larger output buffer. Use
 getOutputSize to determine how big
 the output buffer should be.

 Upon finishing, this method resets this cipher object to the state
 it was in when previously initialized via a call to init.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 init) more data.

 Note: if any exception is thrown, this cipher object may need to
 be reset before it can be used again.

Parameters:
output - the buffer for the result
outputOffset - the offset in output where the result
 is stored
Returns:
the number of bytes stored in output
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized)
IllegalBlockSizeException - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
ShortBufferException - if the given output buffer is too small
 to hold the result
BadPaddingException - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes
AEADBadTagException - if this cipher is decrypting in an
 AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value


"
Cipher,"doFinal(byte[] input, int inputOffset, int inputLen)",byte[],"Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation.","

doFinal
public final byte[] doFinal(byte[] input,
                            int inputOffset,
                            int inputLen)
                     throws IllegalBlockSizeException,
                            BadPaddingException
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation. The data is encrypted or decrypted,
 depending on how this cipher was initialized.

 The first inputLen bytes in the input
 buffer, starting at inputOffset inclusive, and any input
 bytes that may have been buffered during a previous update
 operation, are processed, with padding (if requested) being applied.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in a new buffer.

 Upon finishing, this method resets this cipher object to the state
 it was in when previously initialized via a call to init.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 init) more data.

 Note: if any exception is thrown, this cipher object may need to
 be reset before it can be used again.

Parameters:
input - the input buffer
inputOffset - the offset in input where the input
 starts
inputLen - the input length
Returns:
the new buffer with the result
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized)
IllegalBlockSizeException - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
BadPaddingException - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes
AEADBadTagException - if this cipher is decrypting in an
 AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value


"
Cipher,"doFinal(byte[] input, int inputOffset, int inputLen, byte[] output)",int,"Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation.","

doFinal
public final int doFinal(byte[] input,
                         int inputOffset,
                         int inputLen,
                         byte[] output)
                  throws ShortBufferException,
                         IllegalBlockSizeException,
                         BadPaddingException
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation. The data is encrypted or decrypted,
 depending on how this cipher was initialized.

 The first inputLen bytes in the input
 buffer, starting at inputOffset inclusive, and any input
 bytes that may have been buffered during a previous update
 operation, are processed, with padding (if requested) being applied.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in the output buffer.

 If the output buffer is too small to hold the result,
 a ShortBufferException is thrown. In this case, repeat this
 call with a larger output buffer. Use
 getOutputSize to determine how big
 the output buffer should be.

 Upon finishing, this method resets this cipher object to the state
 it was in when previously initialized via a call to init.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 init) more data.

 Note: if any exception is thrown, this cipher object may need to
 be reset before it can be used again.

 Note: this method should be copy-safe, which means the
 input and output buffers can reference
 the same byte array and no unprocessed input data is overwritten
 when the result is copied into the output buffer.

Parameters:
input - the input buffer
inputOffset - the offset in input where the input
 starts
inputLen - the input length
output - the buffer for the result
Returns:
the number of bytes stored in output
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized)
IllegalBlockSizeException - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
ShortBufferException - if the given output buffer is too small
 to hold the result
BadPaddingException - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes
AEADBadTagException - if this cipher is decrypting in an
 AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value


"
Cipher,"doFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset)",int,"Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation.","

doFinal
public final int doFinal(byte[] input,
                         int inputOffset,
                         int inputLen,
                         byte[] output,
                         int outputOffset)
                  throws ShortBufferException,
                         IllegalBlockSizeException,
                         BadPaddingException
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation. The data is encrypted or decrypted,
 depending on how this cipher was initialized.

 The first inputLen bytes in the input
 buffer, starting at inputOffset inclusive, and any input
 bytes that may have been buffered during a previous
 update operation, are processed, with padding
 (if requested) being applied.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in the output buffer, starting at
 outputOffset inclusive.

 If the output buffer is too small to hold the result,
 a ShortBufferException is thrown. In this case, repeat this
 call with a larger output buffer. Use
 getOutputSize to determine how big
 the output buffer should be.

 Upon finishing, this method resets this cipher object to the state
 it was in when previously initialized via a call to init.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 init) more data.

 Note: if any exception is thrown, this cipher object may need to
 be reset before it can be used again.

 Note: this method should be copy-safe, which means the
 input and output buffers can reference
 the same byte array and no unprocessed input data is overwritten
 when the result is copied into the output buffer.

Parameters:
input - the input buffer
inputOffset - the offset in input where the input
 starts
inputLen - the input length
output - the buffer for the result
outputOffset - the offset in output where the result
 is stored
Returns:
the number of bytes stored in output
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized)
IllegalBlockSizeException - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
ShortBufferException - if the given output buffer is too small
 to hold the result
BadPaddingException - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes
AEADBadTagException - if this cipher is decrypting in an
 AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value


"
Cipher,"doFinal(ByteBuffer input, ByteBuffer output)",int,"Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation.","

doFinal
public final int doFinal(ByteBuffer input,
                         ByteBuffer output)
                  throws ShortBufferException,
                         IllegalBlockSizeException,
                         BadPaddingException
Encrypts or decrypts data in a single-part operation, or finishes a
 multiple-part operation. The data is encrypted or decrypted,
 depending on how this cipher was initialized.

 All input.remaining() bytes starting at
 input.position() are processed.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in the output buffer.
 Upon return, the input buffer's position will be equal
 to its limit; its limit will not have changed. The output buffer's
 position will have advanced by n, where n is the value returned
 by this method; the output buffer's limit will not have changed.

 If output.remaining() bytes are insufficient to
 hold the result, a ShortBufferException is thrown.
 In this case, repeat this call with a larger output buffer. Use
 getOutputSize to determine how big
 the output buffer should be.

 Upon finishing, this method resets this cipher object to the state
 it was in when previously initialized via a call to init.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 init) more data.

 Note: if any exception is thrown, this cipher object may need to
 be reset before it can be used again.

 Note: this method should be copy-safe, which means the
 input and output buffers can reference
 the same byte array and no unprocessed input data is overwritten
 when the result is copied into the output buffer.

Parameters:
input - the input ByteBuffer
output - the output ByteBuffer
Returns:
the number of bytes stored in output
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized)
IllegalArgumentException - if input and output are the
   same object
ReadOnlyBufferException - if the output buffer is read-only
IllegalBlockSizeException - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
ShortBufferException - if there is insufficient space in the
 output buffer
BadPaddingException - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes
AEADBadTagException - if this cipher is decrypting in an
 AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value
Since:
1.5


"
Cipher,getAlgorithm(),String,Returns the algorithm name of this Cipher object.,"

getAlgorithm
public final String getAlgorithm()
Returns the algorithm name of this Cipher object.

 This is the same name that was specified in one of the
 getInstance calls that created this Cipher
 object..

Returns:
the algorithm name of this Cipher object.


"
Cipher,getBlockSize(),int,Returns the block size (in bytes).,"

getBlockSize
public final int getBlockSize()
Returns the block size (in bytes).

Returns:
the block size (in bytes), or 0 if the underlying algorithm is
 not a block cipher


"
Cipher,getExemptionMechanism(),ExemptionMechanism,Returns the exemption mechanism object used with this cipher.,"

getExemptionMechanism
public final ExemptionMechanism getExemptionMechanism()
Returns the exemption mechanism object used with this cipher.

Returns:
the exemption mechanism object used with this cipher, or
 null if this cipher does not use any exemption mechanism.


"
Cipher,getInstance(String transformation),static Cipher,Returns a Cipher object that implements the specified transformation.,"

getInstance
public static final Cipher getInstance(String transformation)
                                throws NoSuchAlgorithmException,
                                       NoSuchPaddingException
Returns a Cipher object that implements the specified
 transformation.

  This method traverses the list of registered security Providers,
 starting with the most preferred Provider.
 A new Cipher object encapsulating the
 CipherSpi implementation from the first
 Provider that supports the specified algorithm is returned.

  Note that the list of registered providers may be retrieved via
 the Security.getProviders() method.

Parameters:
transformation - the name of the transformation, e.g.,
 AES/CBC/PKCS5Padding.
 See the Cipher section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard transformation names.
Returns:
a cipher that implements the requested transformation.
Throws:
NoSuchAlgorithmException - if transformation
          is null, empty, in an invalid format,
          or if no Provider supports a CipherSpi implementation for the
          specified algorithm.
NoSuchPaddingException - if transformation
          contains a padding scheme that is not available.
See Also:
Provider


"
Cipher,"getInstance(String transformation, Provider provider)",static Cipher,Returns a Cipher object that implements the specified transformation.,"

getInstance
public static final Cipher getInstance(String transformation,
                                       Provider provider)
                                throws NoSuchAlgorithmException,
                                       NoSuchPaddingException
Returns a Cipher object that implements the specified
 transformation.

  A new Cipher object encapsulating the
 CipherSpi implementation from the specified Provider
 object is returned.  Note that the specified Provider object
 does not have to be registered in the provider list.

Parameters:
transformation - the name of the transformation,
 e.g., AES/CBC/PKCS5Padding.
 See the Cipher section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard transformation names.
provider - the provider.
Returns:
a cipher that implements the requested transformation.
Throws:
NoSuchAlgorithmException - if transformation
          is null, empty, in an invalid format,
          or if a CipherSpi implementation for the specified algorithm
          is not available from the specified Provider object.
NoSuchPaddingException - if transformation
          contains a padding scheme that is not available.
IllegalArgumentException - if the provider
          is null.
See Also:
Provider


"
Cipher,"getInstance(String transformation, String provider)",static Cipher,Returns a Cipher object that implements the specified transformation.,"

getInstance
public static final Cipher getInstance(String transformation,
                                       String provider)
                                throws NoSuchAlgorithmException,
                                       NoSuchProviderException,
                                       NoSuchPaddingException
Returns a Cipher object that implements the specified
 transformation.

  A new Cipher object encapsulating the
 CipherSpi implementation from the specified provider
 is returned.  The specified provider must be registered
 in the security provider list.

  Note that the list of registered providers may be retrieved via
 the Security.getProviders() method.

Parameters:
transformation - the name of the transformation,
 e.g., AES/CBC/PKCS5Padding.
 See the Cipher section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard transformation names.
provider - the name of the provider.
Returns:
a cipher that implements the requested transformation.
Throws:
NoSuchAlgorithmException - if transformation
          is null, empty, in an invalid format,
          or if a CipherSpi implementation for the specified algorithm
          is not available from the specified provider.
NoSuchProviderException - if the specified provider is not
          registered in the security provider list.
NoSuchPaddingException - if transformation
          contains a padding scheme that is not available.
IllegalArgumentException - if the provider
          is null or empty.
See Also:
Provider


"
Cipher,getIV(),byte[],Returns the initialization vector (IV) in a new buffer.,"

getIV
public final byte[] getIV()
Returns the initialization vector (IV) in a new buffer.

 This is useful in the case where a random IV was created,
 or in the context of password-based encryption or
 decryption, where the IV is derived from a user-supplied password.

Returns:
the initialization vector in a new buffer, or null if the
 underlying algorithm does not use an IV, or if the IV has not yet
 been set.


"
Cipher,getMaxAllowedKeyLength(String transformation),static int,Returns the maximum key length for the specified transformation according to the installed JCE jurisdiction policy files.,"

getMaxAllowedKeyLength
public static final int getMaxAllowedKeyLength(String transformation)
                                        throws NoSuchAlgorithmException
Returns the maximum key length for the specified transformation
 according to the installed JCE jurisdiction policy files. If
 JCE unlimited strength jurisdiction policy files are installed,
 Integer.MAX_VALUE will be returned.
 For more information on default key size in JCE jurisdiction
 policy files, please see Appendix E in the
 
 Java Cryptography Architecture Reference Guide.

Parameters:
transformation - the cipher transformation.
Returns:
the maximum key length in bits or Integer.MAX_VALUE.
Throws:
NullPointerException - if transformation is null.
NoSuchAlgorithmException - if transformation
 is not a valid transformation, i.e. in the form of ""algorithm"" or
 ""algorithm/mode/padding"".
Since:
1.5


"
Cipher,getMaxAllowedParameterSpec(String transformation),static AlgorithmParameterSpec,Returns an AlgorithmParameterSpec object which contains the maximum cipher parameter value according to the jurisdiction policy file.,"

getMaxAllowedParameterSpec
public static final AlgorithmParameterSpec getMaxAllowedParameterSpec(String transformation)
                                                               throws NoSuchAlgorithmException
Returns an AlgorithmParameterSpec object which contains
 the maximum cipher parameter value according to the
 jurisdiction policy file. If JCE unlimited strength jurisdiction
 policy files are installed or there is no maximum limit on the
 parameters for the specified transformation in the policy file,
 null will be returned.

Parameters:
transformation - the cipher transformation.
Returns:
an AlgorithmParameterSpec which holds the maximum
 value or null.
Throws:
NullPointerException - if transformation
 is null.
NoSuchAlgorithmException - if transformation
 is not a valid transformation, i.e. in the form of ""algorithm"" or
 ""algorithm/mode/padding"".
Since:
1.5


"
Cipher,getOutputSize(int inputLen),int,"Returns the length in bytes that an output buffer would need to be in order to hold the result of the next update or doFinal operation, given the input length inputLen (in bytes).","

getOutputSize
public final int getOutputSize(int inputLen)
Returns the length in bytes that an output buffer would need to be in
 order to hold the result of the next update or
 doFinal operation, given the input length
 inputLen (in bytes).

 This call takes into account any unprocessed (buffered) data from a
 previous update call, padding, and AEAD tagging.

 The actual output length of the next update or
 doFinal call may be smaller than the length returned by
 this method.

Parameters:
inputLen - the input length (in bytes)
Returns:
the required output buffer size (in bytes)
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not yet been initialized)


"
Cipher,getParameters(),AlgorithmParameters,Returns the parameters used with this cipher.,"

getParameters
public final AlgorithmParameters getParameters()
Returns the parameters used with this cipher.

 The returned parameters may be the same that were used to initialize
 this cipher, or may contain a combination of default and random
 parameter values used by the underlying cipher implementation if this
 cipher requires algorithm parameters but was not initialized with any.

Returns:
the parameters used with this cipher, or null if this cipher
 does not use any parameters.


"
Cipher,getProvider(),Provider,Returns the provider of this Cipher object.,"

getProvider
public final Provider getProvider()
Returns the provider of this Cipher object.

Returns:
the provider of this Cipher object


"
Cipher,"init(int opmode, Certificate certificate)",void,Initializes this cipher with the public key from the given certificate.,"

init
public final void init(int opmode,
                       Certificate certificate)
                throws InvalidKeyException
Initializes this cipher with the public key from the given certificate.
  The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of opmode.

 If the certificate is of type X.509 and has a key usage
 extension field marked as critical, and the value of the key usage
 extension field implies that the public key in
 the certificate and its corresponding private key are not
 supposed to be used for the operation represented by the value
 of opmode,
 an InvalidKeyException
 is thrown.

  If this cipher requires any algorithm parameters that cannot be
 derived from the public key in the given certificate, the underlying
 cipher
 implementation is supposed to generate the required parameters itself
 (using provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 InvalidKeyException if it is being initialized for decryption or
 key unwrapping.
 The generated parameters can be retrieved using
 getParameters or
 getIV (if the parameter is an IV).

 If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.

 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them using the
 SecureRandom
 implementation of the highest-priority
 installed provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)

 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.

Parameters:
opmode - the operation mode of this cipher (this is one of the
 following:
 ENCRYPT_MODE, DECRYPT_MODE,
 WRAP_MODE or UNWRAP_MODE)
certificate - the certificate
Throws:
InvalidKeyException - if the public key in the given
 certificate is inappropriate for initializing this cipher, or this
 cipher requires algorithm parameters that cannot be determined from the
 public key in the given certificate, or the keysize of the public key
 in the given certificate has a keysize that exceeds the maximum
 allowable keysize (as determined by the configured jurisdiction policy
 files).
UnsupportedOperationException - if (@code opmode} is
 WRAP_MODE or UNWRAP_MODE but the mode is not implemented
 by the underlying CipherSpi.


"
Cipher,"init(int opmode, Certificate certificate, SecureRandom random)",void,Initializes this cipher with the public key from the given certificate and a source of randomness.,"

init
public final void init(int opmode,
                       Certificate certificate,
                       SecureRandom random)
                throws InvalidKeyException
Initializes this cipher with the public key from the given certificate
 and
 a source of randomness.

 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping
 or key unwrapping, depending on
 the value of opmode.

 If the certificate is of type X.509 and has a key usage
 extension field marked as critical, and the value of the key usage
 extension field implies that the public key in
 the certificate and its corresponding private key are not
 supposed to be used for the operation represented by the value of
 opmode,
 an InvalidKeyException
 is thrown.

 If this cipher requires any algorithm parameters that cannot be
 derived from the public key in the given certificate,
 the underlying cipher
 implementation is supposed to generate the required parameters itself
 (using provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 InvalidKeyException if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 getParameters or
 getIV (if the parameter is an IV).

 If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.

 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from random.

 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.

Parameters:
opmode - the operation mode of this cipher (this is one of the
 following:
 ENCRYPT_MODE, DECRYPT_MODE,
 WRAP_MODE or UNWRAP_MODE)
certificate - the certificate
random - the source of randomness
Throws:
InvalidKeyException - if the public key in the given
 certificate is inappropriate for initializing this cipher, or this
 cipher
 requires algorithm parameters that cannot be determined from the
 public key in the given certificate, or the keysize of the public key
 in the given certificate has a keysize that exceeds the maximum
 allowable keysize (as determined by the configured jurisdiction policy
 files).
UnsupportedOperationException - if (@code opmode} is
 WRAP_MODE or UNWRAP_MODE but the mode is not implemented
 by the underlying CipherSpi.


"
Cipher,"init(int opmode, Key key)",void,Initializes this cipher with a key.,"

init
public final void init(int opmode,
                       Key key)
                throws InvalidKeyException
Initializes this cipher with a key.

 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or key unwrapping, depending
 on the value of opmode.

 If this cipher requires any algorithm parameters that cannot be
 derived from the given key, the underlying cipher
 implementation is supposed to generate the required parameters itself
 (using provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 InvalidKeyException if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 getParameters or
 getIV (if the parameter is an IV).

 If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.

 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them using the SecureRandom
 implementation of the highest-priority
 installed provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)

 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.

Parameters:
opmode - the operation mode of this cipher (this is one of
 the following:
 ENCRYPT_MODE, DECRYPT_MODE,
 WRAP_MODE or UNWRAP_MODE)
key - the key
Throws:
InvalidKeyException - if the given key is inappropriate for
 initializing this cipher, or requires
 algorithm parameters that cannot be
 determined from the given key, or if the given key has a keysize that
 exceeds the maximum allowable keysize (as determined from the
 configured jurisdiction policy files).
UnsupportedOperationException - if (@code opmode} is
 WRAP_MODE or UNWRAP_MODE but the mode is not implemented
 by the underlying CipherSpi.


"
Cipher,"init(int opmode, Key key, AlgorithmParameters params)",void,Initializes this cipher with a key and a set of algorithm parameters.,"

init
public final void init(int opmode,
                       Key key,
                       AlgorithmParameters params)
                throws InvalidKeyException,
                       InvalidAlgorithmParameterException
Initializes this cipher with a key and a set of algorithm
 parameters.

 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of opmode.

 If this cipher requires any algorithm parameters and
 params is null, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 InvalidAlgorithmParameterException if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 getParameters or
 getIV (if the parameter is an IV).

 If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.

 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them using the SecureRandom
 implementation of the highest-priority
 installed provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)

 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.

Parameters:
opmode - the operation mode of this cipher (this is one of the
 following: ENCRYPT_MODE,
 DECRYPT_MODE, WRAP_MODE
 or UNWRAP_MODE)
key - the encryption key
params - the algorithm parameters
Throws:
InvalidKeyException - if the given key is inappropriate for
 initializing this cipher, or its keysize exceeds the maximum allowable
 keysize (as determined from the configured jurisdiction policy files).
InvalidAlgorithmParameterException - if the given algorithm
 parameters are inappropriate for this cipher,
 or this cipher requires
 algorithm parameters and params is null, or the given
 algorithm parameters imply a cryptographic strength that would exceed
 the legal limits (as determined from the configured jurisdiction
 policy files).
UnsupportedOperationException - if (@code opmode} is
 WRAP_MODE or UNWRAP_MODE but the mode is not implemented
 by the underlying CipherSpi.


"
Cipher,"init(int opmode, Key key, AlgorithmParameterSpec params)",void,Initializes this cipher with a key and a set of algorithm parameters.,"

init
public final void init(int opmode,
                       Key key,
                       AlgorithmParameterSpec params)
                throws InvalidKeyException,
                       InvalidAlgorithmParameterException
Initializes this cipher with a key and a set of algorithm
 parameters.

 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of opmode.

 If this cipher requires any algorithm parameters and
 params is null, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 InvalidAlgorithmParameterException if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 getParameters or
 getIV (if the parameter is an IV).

 If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.

 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them using the SecureRandom
 implementation of the highest-priority
 installed provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)

 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.

Parameters:
opmode - the operation mode of this cipher (this is one of the
 following:
 ENCRYPT_MODE, DECRYPT_MODE,
 WRAP_MODE or UNWRAP_MODE)
key - the encryption key
params - the algorithm parameters
Throws:
InvalidKeyException - if the given key is inappropriate for
 initializing this cipher, or its keysize exceeds the maximum allowable
 keysize (as determined from the configured jurisdiction policy files).
InvalidAlgorithmParameterException - if the given algorithm
 parameters are inappropriate for this cipher,
 or this cipher requires
 algorithm parameters and params is null, or the given
 algorithm parameters imply a cryptographic strength that would exceed
 the legal limits (as determined from the configured jurisdiction
 policy files).
UnsupportedOperationException - if (@code opmode} is
 WRAP_MODE or UNWRAP_MODE but the mode is not implemented
 by the underlying CipherSpi.


"
Cipher,"init(int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random)",void,"Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness.","

init
public final void init(int opmode,
                       Key key,
                       AlgorithmParameterSpec params,
                       SecureRandom random)
                throws InvalidKeyException,
                       InvalidAlgorithmParameterException
Initializes this cipher with a key, a set of algorithm
 parameters, and a source of randomness.

 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of opmode.

 If this cipher requires any algorithm parameters and
 params is null, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 InvalidAlgorithmParameterException if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 getParameters or
 getIV (if the parameter is an IV).

 If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.

 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from random.

 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.

Parameters:
opmode - the operation mode of this cipher (this is one of the
 following:
 ENCRYPT_MODE, DECRYPT_MODE,
 WRAP_MODE or UNWRAP_MODE)
key - the encryption key
params - the algorithm parameters
random - the source of randomness
Throws:
InvalidKeyException - if the given key is inappropriate for
 initializing this cipher, or its keysize exceeds the maximum allowable
 keysize (as determined from the configured jurisdiction policy files).
InvalidAlgorithmParameterException - if the given algorithm
 parameters are inappropriate for this cipher,
 or this cipher requires
 algorithm parameters and params is null, or the given
 algorithm parameters imply a cryptographic strength that would exceed
 the legal limits (as determined from the configured jurisdiction
 policy files).
UnsupportedOperationException - if (@code opmode} is
 WRAP_MODE or UNWRAP_MODE but the mode is not implemented
 by the underlying CipherSpi.


"
Cipher,"init(int opmode, Key key, AlgorithmParameters params, SecureRandom random)",void,"Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness.","

init
public final void init(int opmode,
                       Key key,
                       AlgorithmParameters params,
                       SecureRandom random)
                throws InvalidKeyException,
                       InvalidAlgorithmParameterException
Initializes this cipher with a key, a set of algorithm
 parameters, and a source of randomness.

 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of opmode.

 If this cipher requires any algorithm parameters and
 params is null, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 InvalidAlgorithmParameterException if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 getParameters or
 getIV (if the parameter is an IV).

 If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.

 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from random.

 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.

Parameters:
opmode - the operation mode of this cipher (this is one of the
 following: ENCRYPT_MODE,
 DECRYPT_MODE, WRAP_MODE
 or UNWRAP_MODE)
key - the encryption key
params - the algorithm parameters
random - the source of randomness
Throws:
InvalidKeyException - if the given key is inappropriate for
 initializing this cipher, or its keysize exceeds the maximum allowable
 keysize (as determined from the configured jurisdiction policy files).
InvalidAlgorithmParameterException - if the given algorithm
 parameters are inappropriate for this cipher,
 or this cipher requires
 algorithm parameters and params is null, or the given
 algorithm parameters imply a cryptographic strength that would exceed
 the legal limits (as determined from the configured jurisdiction
 policy files).
UnsupportedOperationException - if (@code opmode} is
 WRAP_MODE or UNWRAP_MODE but the mode is not implemented
 by the underlying CipherSpi.


"
Cipher,"init(int opmode, Key key, SecureRandom random)",void,Initializes this cipher with a key and a source of randomness.,"

init
public final void init(int opmode,
                       Key key,
                       SecureRandom random)
                throws InvalidKeyException
Initializes this cipher with a key and a source of randomness.

 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or  key unwrapping, depending
 on the value of opmode.

 If this cipher requires any algorithm parameters that cannot be
 derived from the given key, the underlying cipher
 implementation is supposed to generate the required parameters itself
 (using provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 InvalidKeyException if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 getParameters or
 getIV (if the parameter is an IV).

 If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.

 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from random.

 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.

Parameters:
opmode - the operation mode of this cipher (this is one of the
 following:
 ENCRYPT_MODE, DECRYPT_MODE,
 WRAP_MODE or UNWRAP_MODE)
key - the encryption key
random - the source of randomness
Throws:
InvalidKeyException - if the given key is inappropriate for
 initializing this cipher, or requires
 algorithm parameters that cannot be
 determined from the given key, or if the given key has a keysize that
 exceeds the maximum allowable keysize (as determined from the
 configured jurisdiction policy files).
UnsupportedOperationException - if (@code opmode} is
 WRAP_MODE or UNWRAP_MODE but the mode is not implemented
 by the underlying CipherSpi.


"
Cipher,"unwrap(byte[] wrappedKey, String wrappedKeyAlgorithm, int wrappedKeyType)",Key,Unwrap a previously wrapped key.,"

unwrap
public final Key unwrap(byte[] wrappedKey,
                        String wrappedKeyAlgorithm,
                        int wrappedKeyType)
                 throws InvalidKeyException,
                        NoSuchAlgorithmException
Unwrap a previously wrapped key.

Parameters:
wrappedKey - the key to be unwrapped.
wrappedKeyAlgorithm - the algorithm associated with the wrapped
 key.
wrappedKeyType - the type of the wrapped key. This must be one of
 SECRET_KEY, PRIVATE_KEY, or
 PUBLIC_KEY.
Returns:
the unwrapped key.
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized).
NoSuchAlgorithmException - if no installed providers
 can create keys of type wrappedKeyType for the
 wrappedKeyAlgorithm.
InvalidKeyException - if wrappedKey does not
 represent a wrapped key of type wrappedKeyType for
 the wrappedKeyAlgorithm.
UnsupportedOperationException - if the corresponding method in the
 CipherSpi is not supported.


"
Cipher,update(byte[] input),byte[],"Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part.","

update
public final byte[] update(byte[] input)
Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.

 The bytes in the input buffer are processed, and the
 result is stored in a new buffer.

 If input has a length of zero, this method returns
 null.

Parameters:
input - the input buffer
Returns:
the new buffer with the result, or null if the underlying
 cipher is a block cipher and the input data is too short to result in a
 new block.
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized)


"
Cipher,"update(byte[] input, int inputOffset, int inputLen)",byte[],"Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part.","

update
public final byte[] update(byte[] input,
                           int inputOffset,
                           int inputLen)
Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.

 The first inputLen bytes in the input
 buffer, starting at inputOffset inclusive, are processed,
 and the result is stored in a new buffer.

 If inputLen is zero, this method returns
 null.

Parameters:
input - the input buffer
inputOffset - the offset in input where the input
 starts
inputLen - the input length
Returns:
the new buffer with the result, or null if the underlying
 cipher is a block cipher and the input data is too short to result in a
 new block.
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized)


"
Cipher,"update(byte[] input, int inputOffset, int inputLen, byte[] output)",int,"Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part.","

update
public final int update(byte[] input,
                        int inputOffset,
                        int inputLen,
                        byte[] output)
                 throws ShortBufferException
Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.

 The first inputLen bytes in the input
 buffer, starting at inputOffset inclusive, are processed,
 and the result is stored in the output buffer.

 If the output buffer is too small to hold the result,
 a ShortBufferException is thrown. In this case, repeat this
 call with a larger output buffer. Use
 getOutputSize to determine how big
 the output buffer should be.

 If inputLen is zero, this method returns
 a length of zero.

 Note: this method should be copy-safe, which means the
 input and output buffers can reference
 the same byte array and no unprocessed input data is overwritten
 when the result is copied into the output buffer.

Parameters:
input - the input buffer
inputOffset - the offset in input where the input
 starts
inputLen - the input length
output - the buffer for the result
Returns:
the number of bytes stored in output
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized)
ShortBufferException - if the given output buffer is too small
 to hold the result


"
Cipher,"update(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset)",int,"Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part.","

update
public final int update(byte[] input,
                        int inputOffset,
                        int inputLen,
                        byte[] output,
                        int outputOffset)
                 throws ShortBufferException
Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.

 The first inputLen bytes in the input
 buffer, starting at inputOffset inclusive, are processed,
 and the result is stored in the output buffer, starting at
 outputOffset inclusive.

 If the output buffer is too small to hold the result,
 a ShortBufferException is thrown. In this case, repeat this
 call with a larger output buffer. Use
 getOutputSize to determine how big
 the output buffer should be.

 If inputLen is zero, this method returns
 a length of zero.

 Note: this method should be copy-safe, which means the
 input and output buffers can reference
 the same byte array and no unprocessed input data is overwritten
 when the result is copied into the output buffer.

Parameters:
input - the input buffer
inputOffset - the offset in input where the input
 starts
inputLen - the input length
output - the buffer for the result
outputOffset - the offset in output where the result
 is stored
Returns:
the number of bytes stored in output
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized)
ShortBufferException - if the given output buffer is too small
 to hold the result


"
Cipher,"update(ByteBuffer input, ByteBuffer output)",int,"Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part.","

update
public final int update(ByteBuffer input,
                        ByteBuffer output)
                 throws ShortBufferException
Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.

 All input.remaining() bytes starting at
 input.position() are processed. The result is stored
 in the output buffer.
 Upon return, the input buffer's position will be equal
 to its limit; its limit will not have changed. The output buffer's
 position will have advanced by n, where n is the value returned
 by this method; the output buffer's limit will not have changed.

 If output.remaining() bytes are insufficient to
 hold the result, a ShortBufferException is thrown.
 In this case, repeat this call with a larger output buffer. Use
 getOutputSize to determine how big
 the output buffer should be.

 Note: this method should be copy-safe, which means the
 input and output buffers can reference
 the same block of memory and no unprocessed input data is overwritten
 when the result is copied into the output buffer.

Parameters:
input - the input ByteBuffer
output - the output ByteByffer
Returns:
the number of bytes stored in output
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized)
IllegalArgumentException - if input and output are the
   same object
ReadOnlyBufferException - if the output buffer is read-only
ShortBufferException - if there is insufficient space in the
 output buffer
Since:
1.5


"
Cipher,updateAAD(byte[] src),void,Continues a multi-part update of the Additional Authentication Data (AAD).,"

updateAAD
public final void updateAAD(byte[] src)
Continues a multi-part update of the Additional Authentication
 Data (AAD).
 
 Calls to this method provide AAD to the cipher when operating in
 modes such as AEAD (GCM/CCM).  If this cipher is operating in
 either GCM or CCM mode, all AAD must be supplied before beginning
 operations on the ciphertext (via the update and
 doFinal methods).

Parameters:
src - the buffer containing the Additional Authentication Data
Throws:
IllegalArgumentException - if the src
 byte array is null
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized), does not accept AAD, or if
 operating in either GCM or CCM mode and one of the update
 methods has already been called for the active
 encryption/decryption operation
UnsupportedOperationException - if the corresponding method
 in the CipherSpi has not been overridden by an
 implementation
Since:
1.7


"
Cipher,"updateAAD(byte[] src, int offset, int len)",void,"Continues a multi-part update of the Additional Authentication Data (AAD), using a subset of the provided buffer.","

updateAAD
public final void updateAAD(byte[] src,
                            int offset,
                            int len)
Continues a multi-part update of the Additional Authentication
 Data (AAD), using a subset of the provided buffer.
 
 Calls to this method provide AAD to the cipher when operating in
 modes such as AEAD (GCM/CCM).  If this cipher is operating in
 either GCM or CCM mode, all AAD must be supplied before beginning
 operations on the ciphertext (via the update
 and doFinal methods).

Parameters:
src - the buffer containing the AAD
offset - the offset in src where the AAD input starts
len - the number of AAD bytes
Throws:
IllegalArgumentException - if the src
 byte array is null, or the offset or length
 is less than 0, or the sum of the offset and
 len is greater than the length of the
 src byte array
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized), does not accept AAD, or if
 operating in either GCM or CCM mode and one of the update
 methods has already been called for the active
 encryption/decryption operation
UnsupportedOperationException - if the corresponding method
 in the CipherSpi has not been overridden by an
 implementation
Since:
1.7


"
Cipher,updateAAD(ByteBuffer src),void,Continues a multi-part update of the Additional Authentication Data (AAD).,"

updateAAD
public final void updateAAD(ByteBuffer src)
Continues a multi-part update of the Additional Authentication
 Data (AAD).
 
 Calls to this method provide AAD to the cipher when operating in
 modes such as AEAD (GCM/CCM).  If this cipher is operating in
 either GCM or CCM mode, all AAD must be supplied before beginning
 operations on the ciphertext (via the update
 and doFinal methods).
 
 All src.remaining() bytes starting at
 src.position() are processed.
 Upon return, the input buffer's position will be equal
 to its limit; its limit will not have changed.

Parameters:
src - the buffer containing the AAD
Throws:
IllegalArgumentException - if the src ByteBuffer
 is null
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized), does not accept AAD, or if
 operating in either GCM or CCM mode and one of the update
 methods has already been called for the active
 encryption/decryption operation
UnsupportedOperationException - if the corresponding method
 in the CipherSpi has not been overridden by an
 implementation
Since:
1.7


"
Cipher,wrap(Key key),byte[],Wrap a key.,"

wrap
public final byte[] wrap(Key key)
                  throws IllegalBlockSizeException,
                         InvalidKeyException
Wrap a key.

Parameters:
key - the key to be wrapped.
Returns:
the wrapped key.
Throws:
IllegalStateException - if this cipher is in a wrong
 state (e.g., has not been initialized).
IllegalBlockSizeException - if this cipher is a block
 cipher, no padding has been requested, and the length of the
 encoding of the key to be wrapped is not a
 multiple of the block size.
InvalidKeyException - if it is impossible or unsafe to
 wrap the key with this cipher (e.g., a hardware protected key is
 being passed to a software-only cipher).
UnsupportedOperationException - if the corresponding method in the
 CipherSpi is not supported.


"
CipherInputStream,available(),int,Returns the number of bytes that can be read from this input stream without blocking.,"

available
public int available()
              throws IOException
Returns the number of bytes that can be read from this input
 stream without blocking. The available method of
 InputStream returns 0. This method
 should be overridden by subclasses.

Overrides:
available in class FilterInputStream
Returns:
the number of bytes that can be read from this input stream
             without blocking.
Throws:
IOException - if an I/O error occurs.
Since:
JCE1.2


"
CipherInputStream,close(),void,Closes this input stream and releases any system resources associated with the stream.,"

close
public void close()
           throws IOException
Closes this input stream and releases any system resources
 associated with the stream.
 
 The close method of CipherInputStream
 calls the close method of its underlying input
 stream.

Specified by:
close in interface Closeable
Specified by:
close in interface AutoCloseable
Overrides:
close in class FilterInputStream
Throws:
IOException - if an I/O error occurs.
Since:
JCE1.2
See Also:
FilterInputStream.in


"
CipherInputStream,markSupported(),boolean,"Tests if this input stream supports the mark and reset methods, which it does not.","

markSupported
public boolean markSupported()
Tests if this input stream supports the mark
 and reset methods, which it does not.

Overrides:
markSupported in class FilterInputStream
Returns:
false, since this class does not support the
          mark and reset methods.
Since:
JCE1.2
See Also:
InputStream.mark(int), 
InputStream.reset()


"
CipherInputStream,read(),int,Reads the next byte of data from this input stream.,"

read
public int read()
         throws IOException
Reads the next byte of data from this input stream. The value
 byte is returned as an int in the range
 0 to 255. If no byte is available
 because the end of the stream has been reached, the value
 -1 is returned. This method blocks until input data
 is available, the end of the stream is detected, or an exception
 is thrown.
 

Overrides:
read in class FilterInputStream
Returns:
the next byte of data, or -1 if the end of the
          stream is reached.
Throws:
IOException - if an I/O error occurs.
Since:
JCE1.2
See Also:
FilterInputStream.in


"
CipherInputStream,read(byte[] b),int,Reads up to b.length bytes of data from this input stream into an array of bytes.,"

read
public int read(byte[] b)
         throws IOException
Reads up to b.length bytes of data from this input
 stream into an array of bytes.
 
 The read method of InputStream calls
 the read method of three arguments with the arguments
 b, 0, and b.length.

Overrides:
read in class FilterInputStream
Parameters:
b - the buffer into which the data is read.
Returns:
the total number of bytes read into the buffer, or
             -1 is there is no more data because the end of
             the stream has been reached.
Throws:
IOException - if an I/O error occurs.
Since:
JCE1.2
See Also:
InputStream.read(byte[], int, int)


"
CipherInputStream,"read(byte[] b, int off, int len)",int,Reads up to len bytes of data from this input stream into an array of bytes.,"

read
public int read(byte[] b,
                int off,
                int len)
         throws IOException
Reads up to len bytes of data from this input stream
 into an array of bytes. This method blocks until some input is
 available. If the first argument is null, up to
 len bytes are read and discarded.

Overrides:
read in class FilterInputStream
Parameters:
b - the buffer into which the data is read.
off - the start offset in the destination array
                   buf
len - the maximum number of bytes read.
Returns:
the total number of bytes read into the buffer, or
             -1 if there is no more data because the end of
             the stream has been reached.
Throws:
IOException - if an I/O error occurs.
Since:
JCE1.2
See Also:
InputStream.read()


"
CipherInputStream,skip(long n),long,Skips n bytes of input from the bytes that can be read from this input stream without blocking.,"

skip
public long skip(long n)
          throws IOException
Skips n bytes of input from the bytes that can be read
 from this input stream without blocking.

 Fewer bytes than requested might be skipped.
 The actual number of bytes skipped is equal to n or
 the result of a call to
 available,
 whichever is smaller.
 If n is less than zero, no bytes are skipped.

 The actual number of bytes skipped is returned.

Overrides:
skip in class FilterInputStream
Parameters:
n - the number of bytes to be skipped.
Returns:
the actual number of bytes skipped.
Throws:
IOException - if an I/O error occurs.
Since:
JCE1.2


"
CipherOutputStream,close(),void,Closes this output stream and releases any system resources associated with this stream.,"

close
public void close()
           throws IOException
Closes this output stream and releases any system resources
 associated with this stream.
 
 This method invokes the doFinal method of the encapsulated
 cipher object, which causes any bytes buffered by the encapsulated
 cipher to be processed. The result is written out by calling the
 flush method of this output stream.
 
 This method resets the encapsulated cipher object to its initial state
 and calls the close method of the underlying output
 stream.

Specified by:
close in interface Closeable
Specified by:
close in interface AutoCloseable
Overrides:
close in class FilterOutputStream
Throws:
IOException - if an I/O error occurs.
Since:
JCE1.2
See Also:
FilterOutputStream.flush(), 
FilterOutputStream.out


"
CipherOutputStream,flush(),void,Flushes this output stream by forcing any buffered output bytes that have already been processed by the encapsulated cipher object to be written out.,"

flush
public void flush()
           throws IOException
Flushes this output stream by forcing any buffered output bytes
 that have already been processed by the encapsulated cipher object
 to be written out.

 Any bytes buffered by the encapsulated cipher
 and waiting to be processed by it will not be written out. For example,
 if the encapsulated cipher is a block cipher, and the total number of
 bytes written using one of the write methods is less than
 the cipher's block size, no bytes will be written out.

Specified by:
flush in interface Flushable
Overrides:
flush in class FilterOutputStream
Throws:
IOException - if an I/O error occurs.
Since:
JCE1.2
See Also:
FilterOutputStream.out


"
CipherOutputStream,write(byte[] b),void,Writes b.length bytes from the specified byte array to this output stream.,"

write
public void write(byte[] b)
           throws IOException
Writes b.length bytes from the specified byte array
 to this output stream.
 
 The write method of
 CipherOutputStream calls the write
 method of three arguments with the three arguments
 b, 0, and b.length.

Overrides:
write in class FilterOutputStream
Parameters:
b - the data.
Throws:
NullPointerException - if b is null.
IOException - if an I/O error occurs.
Since:
JCE1.2
See Also:
write(byte[], int, int)


"
CipherOutputStream,"write(byte[] b, int off, int len)",void,Writes len bytes from the specified byte array starting at offset off to this output stream.,"

write
public void write(byte[] b,
                  int off,
                  int len)
           throws IOException
Writes len bytes from the specified byte array
 starting at offset off to this output stream.

Overrides:
write in class FilterOutputStream
Parameters:
b - the data.
off - the start offset in the data.
len - the number of bytes to write.
Throws:
IOException - if an I/O error occurs.
Since:
JCE1.2
See Also:
FilterOutputStream.write(int)


"
CipherOutputStream,write(int b),void,Writes the specified byte to this output stream.,"

write
public void write(int b)
           throws IOException
Writes the specified byte to this output stream.

Overrides:
write in class FilterOutputStream
Parameters:
b - the byte.
Throws:
IOException - if an I/O error occurs.
Since:
JCE1.2


"
CipherSpi,"engineDoFinal(byte[] input, int inputOffset, int inputLen)",protected abstract byte[],"Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation.","

engineDoFinal
protected abstract byte[] engineDoFinal(byte[] input,
                                        int inputOffset,
                                        int inputLen)
                                 throws IllegalBlockSizeException,
                                        BadPaddingException
Encrypts or decrypts data in a single-part operation,
 or finishes a multiple-part operation.
 The data is encrypted or decrypted, depending on how this cipher was
 initialized.

 The first inputLen bytes in the input
 buffer, starting at inputOffset inclusive, and any input
 bytes that may have been buffered during a previous update
 operation, are processed, with padding (if requested) being applied.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in a new buffer.

 Upon finishing, this method resets this cipher object to the state
 it was in when previously initialized via a call to
 engineInit.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 engineInit) more data.

 Note: if any exception is thrown, this cipher object may need to
 be reset before it can be used again.

Parameters:
input - the input buffer
inputOffset - the offset in input where the input
 starts
inputLen - the input length
Returns:
the new buffer with the result
Throws:
IllegalBlockSizeException - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
BadPaddingException - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes
AEADBadTagException - if this cipher is decrypting in an
 AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value


"
CipherSpi,"engineDoFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset)",protected abstract int,"Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation.","

engineDoFinal
protected abstract int engineDoFinal(byte[] input,
                                     int inputOffset,
                                     int inputLen,
                                     byte[] output,
                                     int outputOffset)
                              throws ShortBufferException,
                                     IllegalBlockSizeException,
                                     BadPaddingException
Encrypts or decrypts data in a single-part operation,
 or finishes a multiple-part operation.
 The data is encrypted or decrypted, depending on how this cipher was
 initialized.

 The first inputLen bytes in the input
 buffer, starting at inputOffset inclusive, and any input
 bytes that may have been buffered during a previous update
 operation, are processed, with padding (if requested) being applied.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in the output buffer, starting at
 outputOffset inclusive.

 If the output buffer is too small to hold the result,
 a ShortBufferException is thrown.

 Upon finishing, this method resets this cipher object to the state
 it was in when previously initialized via a call to
 engineInit.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 engineInit) more data.

 Note: if any exception is thrown, this cipher object may need to
 be reset before it can be used again.

Parameters:
input - the input buffer
inputOffset - the offset in input where the input
 starts
inputLen - the input length
output - the buffer for the result
outputOffset - the offset in output where the result
 is stored
Returns:
the number of bytes stored in output
Throws:
IllegalBlockSizeException - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
ShortBufferException - if the given output buffer is too small
 to hold the result
BadPaddingException - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes
AEADBadTagException - if this cipher is decrypting in an
 AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value


"
CipherSpi,"engineDoFinal(ByteBuffer input, ByteBuffer output)",protected int,"Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation.","

engineDoFinal
protected int engineDoFinal(ByteBuffer input,
                            ByteBuffer output)
                     throws ShortBufferException,
                            IllegalBlockSizeException,
                            BadPaddingException
Encrypts or decrypts data in a single-part operation,
 or finishes a multiple-part operation.
 The data is encrypted or decrypted, depending on how this cipher was
 initialized.

 All input.remaining() bytes starting at
 input.position() are processed.
 If an AEAD mode such as GCM/CCM is being used, the authentication
 tag is appended in the case of encryption, or verified in the
 case of decryption.
 The result is stored in the output buffer.
 Upon return, the input buffer's position will be equal
 to its limit; its limit will not have changed. The output buffer's
 position will have advanced by n, where n is the value returned
 by this method; the output buffer's limit will not have changed.

 If output.remaining() bytes are insufficient to
 hold the result, a ShortBufferException is thrown.

 Upon finishing, this method resets this cipher object to the state
 it was in when previously initialized via a call to
 engineInit.
 That is, the object is reset and available to encrypt or decrypt
 (depending on the operation mode that was specified in the call to
 engineInit) more data.

 Note: if any exception is thrown, this cipher object may need to
 be reset before it can be used again.

 Subclasses should consider overriding this method if they can
 process ByteBuffers more efficiently than byte arrays.

Parameters:
input - the input ByteBuffer
output - the output ByteByffer
Returns:
the number of bytes stored in output
Throws:
IllegalBlockSizeException - if this cipher is a block cipher,
 no padding has been requested (only in encryption mode), and the total
 input length of the data processed by this cipher is not a multiple of
 block size; or if this encryption algorithm is unable to
 process the input data provided.
ShortBufferException - if there is insufficient space in the
 output buffer
BadPaddingException - if this cipher is in decryption mode,
 and (un)padding has been requested, but the decrypted data is not
 bounded by the appropriate padding bytes
AEADBadTagException - if this cipher is decrypting in an
 AEAD mode (such as GCM/CCM), and the received authentication tag
 does not match the calculated value
NullPointerException - if either parameter is null
Since:
1.5


"
CipherSpi,engineGetBlockSize(),protected abstract int,Returns the block size (in bytes).,"

engineGetBlockSize
protected abstract int engineGetBlockSize()
Returns the block size (in bytes).

Returns:
the block size (in bytes), or 0 if the underlying algorithm is
 not a block cipher


"
CipherSpi,engineGetIV(),protected abstract byte[],Returns the initialization vector (IV) in a new buffer.,"

engineGetIV
protected abstract byte[] engineGetIV()
Returns the initialization vector (IV) in a new buffer.

  This is useful in the context of password-based encryption or
 decryption, where the IV is derived from a user-provided passphrase.

Returns:
the initialization vector in a new buffer, or null if the
 underlying algorithm does not use an IV, or if the IV has not yet
 been set.


"
CipherSpi,engineGetKeySize(Key key),protected int,Returns the key size of the given key object in bits.,"

engineGetKeySize
protected int engineGetKeySize(Key key)
                        throws InvalidKeyException
Returns the key size of the given key object in bits.
 This concrete method has been added to this previously-defined
 abstract class. It throws an UnsupportedOperationException
 if it is not overridden by the provider.

Parameters:
key - the key object.
Returns:
the key size of the given key object.
Throws:
InvalidKeyException - if key is invalid.


"
CipherSpi,engineGetOutputSize(int inputLen),protected abstract int,"Returns the length in bytes that an output buffer would need to be in order to hold the result of the next update or doFinal operation, given the input length inputLen (in bytes).","

engineGetOutputSize
protected abstract int engineGetOutputSize(int inputLen)
Returns the length in bytes that an output buffer would
 need to be in order to hold the result of the next update
 or doFinal operation, given the input length
 inputLen (in bytes).

 This call takes into account any unprocessed (buffered) data from a
 previous update call, padding, and AEAD tagging.

 The actual output length of the next update or
 doFinal call may be smaller than the length returned by
 this method.

Parameters:
inputLen - the input length (in bytes)
Returns:
the required output buffer size (in bytes)


"
CipherSpi,engineGetParameters(),protected abstract AlgorithmParameters,Returns the parameters used with this cipher.,"

engineGetParameters
protected abstract AlgorithmParameters engineGetParameters()
Returns the parameters used with this cipher.

 The returned parameters may be the same that were used to initialize
 this cipher, or may contain a combination of default and random
 parameter values used by the underlying cipher implementation if this
 cipher requires algorithm parameters but was not initialized with any.

Returns:
the parameters used with this cipher, or null if this cipher
 does not use any parameters.


"
CipherSpi,"engineInit(int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random)",protected abstract void,"Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness.","

engineInit
protected abstract void engineInit(int opmode,
                                   Key key,
                                   AlgorithmParameterSpec params,
                                   SecureRandom random)
                            throws InvalidKeyException,
                                   InvalidAlgorithmParameterException
Initializes this cipher with a key, a set of
 algorithm parameters, and a source of randomness.

 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or key unwrapping, depending on
 the value of opmode.

 If this cipher requires any algorithm parameters and
 params is null, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 InvalidAlgorithmParameterException if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 engineGetParameters or
 engineGetIV (if the parameter is an IV).

 If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.

 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from random.

 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.

Parameters:
opmode - the operation mode of this cipher (this is one of
 the following:
 ENCRYPT_MODE, DECRYPT_MODE,
 WRAP_MODE or UNWRAP_MODE)
key - the encryption key
params - the algorithm parameters
random - the source of randomness
Throws:
InvalidKeyException - if the given key is inappropriate for
 initializing this cipher
InvalidAlgorithmParameterException - if the given algorithm
 parameters are inappropriate for this cipher,
 or if this cipher requires
 algorithm parameters and params is null.
UnsupportedOperationException - if opmode is
 WRAP_MODE or UNWRAP_MODE is not implemented
 by the cipher.


"
CipherSpi,"engineInit(int opmode, Key key, AlgorithmParameters params, SecureRandom random)",protected abstract void,"Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness.","

engineInit
protected abstract void engineInit(int opmode,
                                   Key key,
                                   AlgorithmParameters params,
                                   SecureRandom random)
                            throws InvalidKeyException,
                                   InvalidAlgorithmParameterException
Initializes this cipher with a key, a set of
 algorithm parameters, and a source of randomness.

 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or key unwrapping, depending on
 the value of opmode.

 If this cipher requires any algorithm parameters and
 params is null, the underlying cipher implementation is
 supposed to generate the required parameters itself (using
 provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 InvalidAlgorithmParameterException if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 engineGetParameters or
 engineGetIV (if the parameter is an IV).

 If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.

 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from random.

 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.

Parameters:
opmode - the operation mode of this cipher (this is one of
 the following:
 ENCRYPT_MODE, DECRYPT_MODE,
 WRAP_MODE or UNWRAP_MODE)
key - the encryption key
params - the algorithm parameters
random - the source of randomness
Throws:
InvalidKeyException - if the given key is inappropriate for
 initializing this cipher
InvalidAlgorithmParameterException - if the given algorithm
 parameters are inappropriate for this cipher,
 or if this cipher requires
 algorithm parameters and params is null.
UnsupportedOperationException - if opmode is
 WRAP_MODE or UNWRAP_MODE is not implemented
 by the cipher.


"
CipherSpi,"engineInit(int opmode, Key key, SecureRandom random)",protected abstract void,Initializes this cipher with a key and a source of randomness.,"

engineInit
protected abstract void engineInit(int opmode,
                                   Key key,
                                   SecureRandom random)
                            throws InvalidKeyException
Initializes this cipher with a key and a source
 of randomness.

 The cipher is initialized for one of the following four operations:
 encryption, decryption, key wrapping or key unwrapping, depending on
 the value of opmode.

 If this cipher requires any algorithm parameters that cannot be
 derived from the given key, the underlying cipher
 implementation is supposed to generate the required parameters itself
 (using provider-specific default or random values) if it is being
 initialized for encryption or key wrapping, and raise an
 InvalidKeyException if it is being
 initialized for decryption or key unwrapping.
 The generated parameters can be retrieved using
 engineGetParameters or
 engineGetIV (if the parameter is an IV).

 If this cipher requires algorithm parameters that cannot be
 derived from the input parameters, and there are no reasonable
 provider-specific default values, initialization will
 necessarily fail.

 If this cipher (including its underlying feedback or padding scheme)
 requires any random bytes (e.g., for parameter generation), it will get
 them from random.

 Note that when a Cipher object is initialized, it loses all
 previously-acquired state. In other words, initializing a Cipher is
 equivalent to creating a new instance of that Cipher and initializing
 it.

Parameters:
opmode - the operation mode of this cipher (this is one of
 the following:
 ENCRYPT_MODE, DECRYPT_MODE,
 WRAP_MODE or UNWRAP_MODE)
key - the encryption key
random - the source of randomness
Throws:
InvalidKeyException - if the given key is inappropriate for
 initializing this cipher, or requires
 algorithm parameters that cannot be
 determined from the given key.
UnsupportedOperationException - if opmode is
 WRAP_MODE or UNWRAP_MODE is not implemented
 by the cipher.


"
CipherSpi,engineSetMode(String mode),protected abstract void,Sets the mode of this cipher.,"

engineSetMode
protected abstract void engineSetMode(String mode)
                               throws NoSuchAlgorithmException
Sets the mode of this cipher.

Parameters:
mode - the cipher mode
Throws:
NoSuchAlgorithmException - if the requested cipher mode does
 not exist


"
CipherSpi,engineSetPadding(String padding),protected abstract void,Sets the padding mechanism of this cipher.,"

engineSetPadding
protected abstract void engineSetPadding(String padding)
                                  throws NoSuchPaddingException
Sets the padding mechanism of this cipher.

Parameters:
padding - the padding mechanism
Throws:
NoSuchPaddingException - if the requested padding mechanism
 does not exist


"
CipherSpi,"engineUnwrap(byte[] wrappedKey, String wrappedKeyAlgorithm, int wrappedKeyType)",protected Key,Unwrap a previously wrapped key.,"

engineUnwrap
protected Key engineUnwrap(byte[] wrappedKey,
                           String wrappedKeyAlgorithm,
                           int wrappedKeyType)
                    throws InvalidKeyException,
                           NoSuchAlgorithmException
Unwrap a previously wrapped key.

 This concrete method has been added to this previously-defined
 abstract class. (For backwards compatibility, it cannot be abstract.)
 It may be overridden by a provider to unwrap a previously wrapped key.
 Such an override is expected to throw an InvalidKeyException if
 the given wrapped key cannot be unwrapped.
 If this method is not overridden, it always throws an
 UnsupportedOperationException.

Parameters:
wrappedKey - the key to be unwrapped.
wrappedKeyAlgorithm - the algorithm associated with the wrapped
 key.
wrappedKeyType - the type of the wrapped key. This is one of
 SECRET_KEY, PRIVATE_KEY, or
 PUBLIC_KEY.
Returns:
the unwrapped key.
Throws:
NoSuchAlgorithmException - if no installed providers
 can create keys of type wrappedKeyType for the
 wrappedKeyAlgorithm.
InvalidKeyException - if wrappedKey does not
 represent a wrapped key of type wrappedKeyType for
 the wrappedKeyAlgorithm.
UnsupportedOperationException - if this method is not supported.


"
CipherSpi,"engineUpdate(byte[] input, int inputOffset, int inputLen)",protected abstract byte[],"Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part.","

engineUpdate
protected abstract byte[] engineUpdate(byte[] input,
                                       int inputOffset,
                                       int inputLen)
Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.

 The first inputLen bytes in the input
 buffer, starting at inputOffset inclusive, are processed,
 and the result is stored in a new buffer.

Parameters:
input - the input buffer
inputOffset - the offset in input where the input
 starts
inputLen - the input length
Returns:
the new buffer with the result, or null if the underlying
 cipher is a block cipher and the input data is too short to result in a
 new block.


"
CipherSpi,"engineUpdate(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset)",protected abstract int,"Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part.","

engineUpdate
protected abstract int engineUpdate(byte[] input,
                                    int inputOffset,
                                    int inputLen,
                                    byte[] output,
                                    int outputOffset)
                             throws ShortBufferException
Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.

 The first inputLen bytes in the input
 buffer, starting at inputOffset inclusive, are processed,
 and the result is stored in the output buffer, starting at
 outputOffset inclusive.

 If the output buffer is too small to hold the result,
 a ShortBufferException is thrown.

Parameters:
input - the input buffer
inputOffset - the offset in input where the input
 starts
inputLen - the input length
output - the buffer for the result
outputOffset - the offset in output where the result
 is stored
Returns:
the number of bytes stored in output
Throws:
ShortBufferException - if the given output buffer is too small
 to hold the result


"
CipherSpi,"engineUpdate(ByteBuffer input, ByteBuffer output)",protected int,"Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part.","

engineUpdate
protected int engineUpdate(ByteBuffer input,
                           ByteBuffer output)
                    throws ShortBufferException
Continues a multiple-part encryption or decryption operation
 (depending on how this cipher was initialized), processing another data
 part.

 All input.remaining() bytes starting at
 input.position() are processed. The result is stored
 in the output buffer.
 Upon return, the input buffer's position will be equal
 to its limit; its limit will not have changed. The output buffer's
 position will have advanced by n, where n is the value returned
 by this method; the output buffer's limit will not have changed.

 If output.remaining() bytes are insufficient to
 hold the result, a ShortBufferException is thrown.

 Subclasses should consider overriding this method if they can
 process ByteBuffers more efficiently than byte arrays.

Parameters:
input - the input ByteBuffer
output - the output ByteByffer
Returns:
the number of bytes stored in output
Throws:
ShortBufferException - if there is insufficient space in the
 output buffer
NullPointerException - if either parameter is null
Since:
1.5


"
CipherSpi,"engineUpdateAAD(byte[] src, int offset, int len)",protected void,"Continues a multi-part update of the Additional Authentication Data (AAD), using a subset of the provided buffer.","

engineUpdateAAD
protected void engineUpdateAAD(byte[] src,
                               int offset,
                               int len)
Continues a multi-part update of the Additional Authentication
 Data (AAD), using a subset of the provided buffer.
 
 Calls to this method provide AAD to the cipher when operating in
 modes such as AEAD (GCM/CCM).  If this cipher is operating in
 either GCM or CCM mode, all AAD must be supplied before beginning
 operations on the ciphertext (via the update and doFinal methods).

Parameters:
src - the buffer containing the AAD
offset - the offset in src where the AAD input starts
len - the number of AAD bytes
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized), does not accept AAD, or if
 operating in either GCM or CCM mode and one of the update
 methods has already been called for the active
 encryption/decryption operation
UnsupportedOperationException - if this method
 has not been overridden by an implementation
Since:
1.7


"
CipherSpi,engineUpdateAAD(ByteBuffer src),protected void,Continues a multi-part update of the Additional Authentication Data (AAD).,"

engineUpdateAAD
protected void engineUpdateAAD(ByteBuffer src)
Continues a multi-part update of the Additional Authentication
 Data (AAD).
 
 Calls to this method provide AAD to the cipher when operating in
 modes such as AEAD (GCM/CCM).  If this cipher is operating in
 either GCM or CCM mode, all AAD must be supplied before beginning
 operations on the ciphertext (via the update and doFinal methods).
 
 All src.remaining() bytes starting at
 src.position() are processed.
 Upon return, the input buffer's position will be equal
 to its limit; its limit will not have changed.

Parameters:
src - the buffer containing the AAD
Throws:
IllegalStateException - if this cipher is in a wrong state
 (e.g., has not been initialized), does not accept AAD, or if
 operating in either GCM or CCM mode and one of the update
 methods has already been called for the active
 encryption/decryption operation
UnsupportedOperationException - if this method
 has not been overridden by an implementation
Since:
1.7


"
CipherSpi,engineWrap(Key key),protected byte[],Wrap a key.,"

engineWrap
protected byte[] engineWrap(Key key)
                     throws IllegalBlockSizeException,
                            InvalidKeyException
Wrap a key.

 This concrete method has been added to this previously-defined
 abstract class. (For backwards compatibility, it cannot be abstract.)
 It may be overridden by a provider to wrap a key.
 Such an override is expected to throw an IllegalBlockSizeException or
 InvalidKeyException (under the specified circumstances),
 if the given key cannot be wrapped.
 If this method is not overridden, it always throws an
 UnsupportedOperationException.

Parameters:
key - the key to be wrapped.
Returns:
the wrapped key.
Throws:
IllegalBlockSizeException - if this cipher is a block cipher,
 no padding has been requested, and the length of the encoding of the
 key to be wrapped is not a multiple of the block size.
InvalidKeyException - if it is impossible or unsafe to
 wrap the key with this cipher (e.g., a hardware protected key is
 being passed to a software-only cipher).
UnsupportedOperationException - if this method is not supported.


"
EncryptedPrivateKeyInfo,getAlgName(),String,Returns the encryption algorithm.,"

getAlgName
public String getAlgName()
Returns the encryption algorithm.
 Note: Standard name is returned instead of the specified one
 in the constructor when such mapping is available.
 See Appendix A in the
 
 Java Cryptography Architecture Reference Guide
 for information about standard Cipher algorithm names.

Returns:
the encryption algorithm name.


"
EncryptedPrivateKeyInfo,getAlgParameters(),AlgorithmParameters,Returns the algorithm parameters used by the encryption algorithm.,"

getAlgParameters
public AlgorithmParameters getAlgParameters()
Returns the algorithm parameters used by the encryption algorithm.

Returns:
the algorithm parameters.


"
EncryptedPrivateKeyInfo,getEncoded(),byte[],Returns the ASN.1 encoding of this object.,"

getEncoded
public byte[] getEncoded()
                  throws IOException
Returns the ASN.1 encoding of this object.

Returns:
the ASN.1 encoding. Returns a new array
 each time this method is called.
Throws:
IOException - if error occurs when constructing its
 ASN.1 encoding.


"
EncryptedPrivateKeyInfo,getEncryptedData(),byte[],Returns the encrypted data.,"

getEncryptedData
public byte[] getEncryptedData()
Returns the encrypted data.

Returns:
the encrypted data. Returns a new array
 each time this method is called.


"
EncryptedPrivateKeyInfo,getKeySpec(Cipher cipher),PKCS8EncodedKeySpec,Extract the enclosed PKCS8EncodedKeySpec object from the encrypted data and return it.,"

getKeySpec
public PKCS8EncodedKeySpec getKeySpec(Cipher cipher)
                               throws InvalidKeySpecException
Extract the enclosed PKCS8EncodedKeySpec object from the
 encrypted data and return it.
 Note: In order to successfully retrieve the enclosed
 PKCS8EncodedKeySpec object, cipher needs
 to be initialized to either Cipher.DECRYPT_MODE or
 Cipher.UNWRAP_MODE, with the same key and parameters used
 for generating the encrypted data.

Parameters:
cipher - the initialized cipher object which will be
 used for decrypting the encrypted data.
Returns:
the PKCS8EncodedKeySpec object.
Throws:
NullPointerException - if cipher
 is null.
InvalidKeySpecException - if the given cipher is
 inappropriate for the encrypted data or the encrypted
 data is corrupted and cannot be decrypted.


"
EncryptedPrivateKeyInfo,getKeySpec(Key decryptKey),PKCS8EncodedKeySpec,Extract the enclosed PKCS8EncodedKeySpec object from the encrypted data and return it.,"

getKeySpec
public PKCS8EncodedKeySpec getKeySpec(Key decryptKey)
                               throws NoSuchAlgorithmException,
                                      InvalidKeyException
Extract the enclosed PKCS8EncodedKeySpec object from the
 encrypted data and return it.

Parameters:
decryptKey - key used for decrypting the encrypted data.
Returns:
the PKCS8EncodedKeySpec object.
Throws:
NullPointerException - if decryptKey
 is null.
NoSuchAlgorithmException - if cannot find appropriate
 cipher to decrypt the encrypted data.
InvalidKeyException - if decryptKey
 cannot be used to decrypt the encrypted data or the decryption
 result is not a valid PKCS8KeySpec.
Since:
1.5


"
EncryptedPrivateKeyInfo,"getKeySpec(Key decryptKey, Provider provider)",PKCS8EncodedKeySpec,Extract the enclosed PKCS8EncodedKeySpec object from the encrypted data and return it.,"

getKeySpec
public PKCS8EncodedKeySpec getKeySpec(Key decryptKey,
                                      Provider provider)
                               throws NoSuchAlgorithmException,
                                      InvalidKeyException
Extract the enclosed PKCS8EncodedKeySpec object from the
 encrypted data and return it.

Parameters:
decryptKey - key used for decrypting the encrypted data.
provider - the name of provider whose Cipher implementation
 will be used.
Returns:
the PKCS8EncodedKeySpec object.
Throws:
NullPointerException - if decryptKey
 or provider is null.
NoSuchAlgorithmException - if cannot find appropriate
 cipher to decrypt the encrypted data in provider.
InvalidKeyException - if decryptKey
 cannot be used to decrypt the encrypted data or the decryption
 result is not a valid PKCS8KeySpec.
Since:
1.5


"
EncryptedPrivateKeyInfo,"getKeySpec(Key decryptKey, String providerName)",PKCS8EncodedKeySpec,Extract the enclosed PKCS8EncodedKeySpec object from the encrypted data and return it.,"

getKeySpec
public PKCS8EncodedKeySpec getKeySpec(Key decryptKey,
                                      String providerName)
                               throws NoSuchProviderException,
                                      NoSuchAlgorithmException,
                                      InvalidKeyException
Extract the enclosed PKCS8EncodedKeySpec object from the
 encrypted data and return it.

Parameters:
decryptKey - key used for decrypting the encrypted data.
providerName - the name of provider whose Cipher
 implementation will be used.
Returns:
the PKCS8EncodedKeySpec object.
Throws:
NullPointerException - if decryptKey
 or providerName is null.
NoSuchProviderException - if no provider
 providerName is registered.
NoSuchAlgorithmException - if cannot find appropriate
 cipher to decrypt the encrypted data.
InvalidKeyException - if decryptKey
 cannot be used to decrypt the encrypted data or the decryption
 result is not a valid PKCS8KeySpec.
Since:
1.5


"
ExemptionMechanism,finalize(),protected void,Ensures that the key stored away by this ExemptionMechanism object will be wiped out when there are no more references to it.,"

finalize
protected void finalize()
Ensures that the key stored away by this ExemptionMechanism
 object will be wiped out when there are no more references to it.

Overrides:
finalize in class Object
See Also:
WeakReference, 
PhantomReference


"
ExemptionMechanism,genExemptionBlob(),byte[],Generates the exemption mechanism key blob.,"

genExemptionBlob
public final byte[] genExemptionBlob()
                              throws IllegalStateException,
                                     ExemptionMechanismException
Generates the exemption mechanism key blob.

Returns:
the new buffer with the result key blob.
Throws:
IllegalStateException - if this exemption mechanism is in
 a wrong state (e.g., has not been initialized).
ExemptionMechanismException - if problem(s) encountered in the
 process of generating.


"
ExemptionMechanism,genExemptionBlob(byte[] output),int,"Generates the exemption mechanism key blob, and stores the result in the output buffer.","

genExemptionBlob
public final int genExemptionBlob(byte[] output)
                           throws IllegalStateException,
                                  ShortBufferException,
                                  ExemptionMechanismException
Generates the exemption mechanism key blob, and stores the result in
 the output buffer.

 If the output buffer is too small to hold the result,
 a ShortBufferException is thrown. In this case, repeat this
 call with a larger output buffer. Use
 getOutputSize to determine how big
 the output buffer should be.

Parameters:
output - the buffer for the result
Returns:
the number of bytes stored in output
Throws:
IllegalStateException - if this exemption mechanism is in
 a wrong state (e.g., has not been initialized).
ShortBufferException - if the given output buffer is too small
 to hold the result.
ExemptionMechanismException - if problem(s) encountered in the
 process of generating.


"
ExemptionMechanism,"genExemptionBlob(byte[] output, int outputOffset)",int,"Generates the exemption mechanism key blob, and stores the result in the output buffer, starting at outputOffset inclusive.","

genExemptionBlob
public final int genExemptionBlob(byte[] output,
                                  int outputOffset)
                           throws IllegalStateException,
                                  ShortBufferException,
                                  ExemptionMechanismException
Generates the exemption mechanism key blob, and stores the result in
 the output buffer, starting at outputOffset
 inclusive.

 If the output buffer is too small to hold the result,
 a ShortBufferException is thrown. In this case, repeat this
 call with a larger output buffer. Use
 getOutputSize to determine how big
 the output buffer should be.

Parameters:
output - the buffer for the result
outputOffset - the offset in output where the result
 is stored
Returns:
the number of bytes stored in output
Throws:
IllegalStateException - if this exemption mechanism is in
 a wrong state (e.g., has not been initialized).
ShortBufferException - if the given output buffer is too small
 to hold the result.
ExemptionMechanismException - if problem(s) encountered in the
 process of generating.


"
ExemptionMechanism,getInstance(String algorithm),static ExemptionMechanism,Returns an ExemptionMechanism object that implements the specified exemption mechanism algorithm.,"

getInstance
public static final ExemptionMechanism getInstance(String algorithm)
                                            throws NoSuchAlgorithmException
Returns an ExemptionMechanism object that implements the
 specified exemption mechanism algorithm.

  This method traverses the list of registered security Providers,
 starting with the most preferred Provider.
 A new ExemptionMechanism object encapsulating the
 ExemptionMechanismSpi implementation from the first
 Provider that supports the specified algorithm is returned.

  Note that the list of registered providers may be retrieved via
 the Security.getProviders() method.

Parameters:
algorithm - the standard name of the requested exemption
 mechanism.
 See the ExemptionMechanism section in the
 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard exemption mechanism names.
Returns:
the new ExemptionMechanism object.
Throws:
NullPointerException - if algorithm
          is null.
NoSuchAlgorithmException - if no Provider supports an
          ExemptionMechanismSpi implementation for the
          specified algorithm.
See Also:
Provider


"
ExemptionMechanism,"getInstance(String algorithm, Provider provider)",static ExemptionMechanism,Returns an ExemptionMechanism object that implements the specified exemption mechanism algorithm.,"

getInstance
public static final ExemptionMechanism getInstance(String algorithm,
                                                   Provider provider)
                                            throws NoSuchAlgorithmException
Returns an ExemptionMechanism object that implements the
 specified exemption mechanism algorithm.

  A new ExemptionMechanism object encapsulating the
 ExemptionMechanismSpi implementation from the specified Provider
 object is returned.  Note that the specified Provider object
 does not have to be registered in the provider list.

Parameters:
algorithm - the standard name of the requested exemption mechanism.
 See the ExemptionMechanism section in the
 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard exemption mechanism names.
provider - the provider.
Returns:
the new ExemptionMechanism object.
Throws:
NullPointerException - if algorithm
          is null.
NoSuchAlgorithmException - if an ExemptionMechanismSpi
          implementation for the specified algorithm is not available
          from the specified Provider object.
IllegalArgumentException - if the provider
          is null.
See Also:
Provider


"
ExemptionMechanism,"getInstance(String algorithm, String provider)",static ExemptionMechanism,Returns an ExemptionMechanism object that implements the specified exemption mechanism algorithm.,"

getInstance
public static final ExemptionMechanism getInstance(String algorithm,
                                                   String provider)
                                            throws NoSuchAlgorithmException,
                                                   NoSuchProviderException
Returns an ExemptionMechanism object that implements the
 specified exemption mechanism algorithm.

  A new ExemptionMechanism object encapsulating the
 ExemptionMechanismSpi implementation from the specified provider
 is returned.  The specified provider must be registered
 in the security provider list.

  Note that the list of registered providers may be retrieved via
 the Security.getProviders() method.

Parameters:
algorithm - the standard name of the requested exemption mechanism.
 See the ExemptionMechanism section in the
 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard exemption mechanism names.
provider - the name of the provider.
Returns:
the new ExemptionMechanism object.
Throws:
NullPointerException - if algorithm
          is null.
NoSuchAlgorithmException - if an ExemptionMechanismSpi
          implementation for the specified algorithm is not
          available from the specified provider.
NoSuchProviderException - if the specified provider is not
          registered in the security provider list.
IllegalArgumentException - if the provider
          is null or empty.
See Also:
Provider


"
ExemptionMechanism,getName(),String,Returns the exemption mechanism name of this ExemptionMechanism object.,"

getName
public final String getName()
Returns the exemption mechanism name of this
 ExemptionMechanism object.

 This is the same name that was specified in one of the
 getInstance calls that created this
 ExemptionMechanism object.

Returns:
the exemption mechanism name of this
 ExemptionMechanism object.


"
ExemptionMechanism,getOutputSize(int inputLen),int,"Returns the length in bytes that an output buffer would need to be in order to hold the result of the next genExemptionBlob operation, given the input length inputLen (in bytes).","

getOutputSize
public final int getOutputSize(int inputLen)
                        throws IllegalStateException
Returns the length in bytes that an output buffer would need to be in
 order to hold the result of the next
 genExemptionBlob
 operation, given the input length inputLen (in bytes).

 The actual output length of the next
 genExemptionBlob
 call may be smaller than the length returned by this method.

Parameters:
inputLen - the input length (in bytes)
Returns:
the required output buffer size (in bytes)
Throws:
IllegalStateException - if this exemption mechanism is in a
 wrong state (e.g., has not yet been initialized)


"
ExemptionMechanism,getProvider(),Provider,Returns the provider of this ExemptionMechanism object.,"

getProvider
public final Provider getProvider()
Returns the provider of this ExemptionMechanism object.

Returns:
the provider of this ExemptionMechanism object.


"
ExemptionMechanism,init(Key key),void,Initializes this exemption mechanism with a key.,"

init
public final void init(Key key)
                throws InvalidKeyException,
                       ExemptionMechanismException
Initializes this exemption mechanism with a key.

 If this exemption mechanism requires any algorithm parameters
 that cannot be derived from the given key, the
 underlying exemption mechanism implementation is supposed to
 generate the required parameters itself (using provider-specific
 default values); in the case that algorithm parameters must be
 specified by the caller, an InvalidKeyException is raised.

Parameters:
key - the key for this exemption mechanism
Throws:
InvalidKeyException - if the given key is inappropriate for
 this exemption mechanism.
ExemptionMechanismException - if problem(s) encountered in the
 process of initializing.


"
ExemptionMechanism,"init(Key key, AlgorithmParameters params)",void,Initializes this exemption mechanism with a key and a set of algorithm parameters.,"

init
public final void init(Key key,
                       AlgorithmParameters params)
                throws InvalidKeyException,
                       InvalidAlgorithmParameterException,
                       ExemptionMechanismException
Initializes this exemption mechanism with a key and a set of algorithm
 parameters.

 If this exemption mechanism requires any algorithm parameters
 and params is null, the underlying exemption mechanism
 implementation is supposed to generate the required parameters itself
 (using provider-specific default values); in the case that algorithm
 parameters must be specified by the caller, an
 InvalidAlgorithmParameterException is raised.

Parameters:
key - the key for this exemption mechanism
params - the algorithm parameters
Throws:
InvalidKeyException - if the given key is inappropriate for
 this exemption mechanism.
InvalidAlgorithmParameterException - if the given algorithm
 parameters are inappropriate for this exemption mechanism.
ExemptionMechanismException - if problem(s) encountered in the
 process of initializing.


"
ExemptionMechanism,"init(Key key, AlgorithmParameterSpec params)",void,Initializes this exemption mechanism with a key and a set of algorithm parameters.,"

init
public final void init(Key key,
                       AlgorithmParameterSpec params)
                throws InvalidKeyException,
                       InvalidAlgorithmParameterException,
                       ExemptionMechanismException
Initializes this exemption mechanism with a key and a set of algorithm
 parameters.

 If this exemption mechanism requires any algorithm parameters
 and params is null, the underlying exemption
 mechanism implementation is supposed to generate the required
 parameters itself (using provider-specific default values); in the case
 that algorithm parameters must be specified by the caller, an
 InvalidAlgorithmParameterException is raised.

Parameters:
key - the key for this exemption mechanism
params - the algorithm parameters
Throws:
InvalidKeyException - if the given key is inappropriate for
 this exemption mechanism.
InvalidAlgorithmParameterException - if the given algorithm
 parameters are inappropriate for this exemption mechanism.
ExemptionMechanismException - if problem(s) encountered in the
 process of initializing.


"
ExemptionMechanism,isCryptoAllowed(Key key),boolean,Returns whether the result blob has been generated successfully by this exemption mechanism.,"

isCryptoAllowed
public final boolean isCryptoAllowed(Key key)
                              throws ExemptionMechanismException
Returns whether the result blob has been generated successfully by this
 exemption mechanism.

 The method also makes sure that the key passed in is the same as
 the one this exemption mechanism used in initializing and generating
 phases.

Parameters:
key - the key the crypto is going to use.
Returns:
whether the result blob of the same key has been generated
 successfully by this exemption mechanism; false if key
 is null.
Throws:
ExemptionMechanismException - if problem(s) encountered
 while determining whether the result blob has been generated successfully
 by this exemption mechanism object.


"
ExemptionMechanismSpi,engineGenExemptionBlob(),protected abstract byte[],Generates the exemption mechanism key blob.,"

engineGenExemptionBlob
protected abstract byte[] engineGenExemptionBlob()
                                          throws ExemptionMechanismException
Generates the exemption mechanism key blob.

Returns:
the new buffer with the result key blob.
Throws:
ExemptionMechanismException - if problem(s) encountered in the
 process of generating.


"
ExemptionMechanismSpi,"engineGenExemptionBlob(byte[] output, int outputOffset)",protected abstract int,"Generates the exemption mechanism key blob, and stores the result in the output buffer, starting at outputOffset inclusive.","

engineGenExemptionBlob
protected abstract int engineGenExemptionBlob(byte[] output,
                                              int outputOffset)
                                       throws ShortBufferException,
                                              ExemptionMechanismException
Generates the exemption mechanism key blob, and stores the result in
 the output buffer, starting at outputOffset
 inclusive.

 If the output buffer is too small to hold the result,
 a ShortBufferException is thrown. In this case, repeat this
 call with a larger output buffer. Use
 engineGetOutputSize to determine
 how big the output buffer should be.

Parameters:
output - the buffer for the result
outputOffset - the offset in output where the result
 is stored
Returns:
the number of bytes stored in output
Throws:
ShortBufferException - if the given output buffer is too small
 to hold the result.
ExemptionMechanismException - if problem(s) encountered in the
 process of generating.


"
ExemptionMechanismSpi,engineGetOutputSize(int inputLen),protected abstract int,"Returns the length in bytes that an output buffer would need to be in order to hold the result of the next engineGenExemptionBlob operation, given the input length inputLen (in bytes).","

engineGetOutputSize
protected abstract int engineGetOutputSize(int inputLen)
Returns the length in bytes that an output buffer would need to be in
 order to hold the result of the next
 engineGenExemptionBlob
 operation, given the input length inputLen (in bytes).

 The actual output length of the next
 engineGenExemptionBlob
 call may be smaller than the length returned by this method.

Parameters:
inputLen - the input length (in bytes)
Returns:
the required output buffer size (in bytes)


"
ExemptionMechanismSpi,engineInit(Key key),protected abstract void,Initializes this exemption mechanism with a key.,"

engineInit
protected abstract void engineInit(Key key)
                            throws InvalidKeyException,
                                   ExemptionMechanismException
Initializes this exemption mechanism with a key.

 If this exemption mechanism requires any algorithm parameters
 that cannot be derived from the given key, the underlying
 exemption mechanism implementation is supposed to generate the required
 parameters itself (using provider-specific default values); in the case
 that algorithm parameters must be specified by the caller, an
 InvalidKeyException is raised.

Parameters:
key - the key for this exemption mechanism
Throws:
InvalidKeyException - if the given key is inappropriate for
 this exemption mechanism.
ExemptionMechanismException - if problem(s) encountered in the
 process of initializing.


"
ExemptionMechanismSpi,"engineInit(Key key, AlgorithmParameters params)",protected abstract void,Initializes this exemption mechanism with a key and a set of algorithm parameters.,"

engineInit
protected abstract void engineInit(Key key,
                                   AlgorithmParameters params)
                            throws InvalidKeyException,
                                   InvalidAlgorithmParameterException,
                                   ExemptionMechanismException
Initializes this exemption mechanism with a key and a set of algorithm
 parameters.

 If this exemption mechanism requires any algorithm parameters
 and params is null, the underlying exemption mechanism
 implementation is supposed to generate the required parameters
 itself (using provider-specific default values); in the case that
 algorithm parameters must be specified by the caller, an
 InvalidAlgorithmParameterException is raised.

Parameters:
key - the key for this exemption mechanism
params - the algorithm parameters
Throws:
InvalidKeyException - if the given key is inappropriate for
 this exemption mechanism.
InvalidAlgorithmParameterException - if the given algorithm
 parameters are inappropriate for this exemption mechanism.
ExemptionMechanismException - if problem(s) encountered in the
 process of initializing.


"
ExemptionMechanismSpi,"engineInit(Key key, AlgorithmParameterSpec params)",protected abstract void,Initializes this exemption mechanism with a key and a set of algorithm parameters.,"

engineInit
protected abstract void engineInit(Key key,
                                   AlgorithmParameterSpec params)
                            throws InvalidKeyException,
                                   InvalidAlgorithmParameterException,
                                   ExemptionMechanismException
Initializes this exemption mechanism with a key and a set of algorithm
 parameters.

 If this exemption mechanism requires any algorithm parameters and
 params is null, the underlying exemption mechanism
 implementation is supposed to generate the required parameters
 itself (using provider-specific default values); in the case that
 algorithm parameters must be specified by the caller, an
 InvalidAlgorithmParameterException is raised.

Parameters:
key - the key for this exemption mechanism
params - the algorithm parameters
Throws:
InvalidKeyException - if the given key is inappropriate for
 this exemption mechanism.
InvalidAlgorithmParameterException - if the given algorithm
 parameters are inappropriate for this exemption mechanism.
ExemptionMechanismException - if problem(s) encountered in the
 process of initializing.


"
KeyAgreement,"doPhase(Key key, boolean lastPhase)",Key,Executes the next phase of this key agreement with the given key that was received from one of the other parties involved in this key agreement.,"

doPhase
public final Key doPhase(Key key,
                         boolean lastPhase)
                  throws InvalidKeyException,
                         IllegalStateException
Executes the next phase of this key agreement with the given
 key that was received from one of the other parties involved in this key
 agreement.

Parameters:
key - the key for this phase. For example, in the case of
 Diffie-Hellman between 2 parties, this would be the other party's
 Diffie-Hellman public key.
lastPhase - flag which indicates whether or not this is the last
 phase of this key agreement.
Returns:
the (intermediate) key resulting from this phase, or null
 if this phase does not yield a key
Throws:
InvalidKeyException - if the given key is inappropriate for
 this phase.
IllegalStateException - if this key agreement has not been
 initialized.


"
KeyAgreement,generateSecret(),byte[],Generates the shared secret and returns it in a new buffer.,"

generateSecret
public final byte[] generateSecret()
                            throws IllegalStateException
Generates the shared secret and returns it in a new buffer.

 This method resets this KeyAgreement object, so that it
 can be reused for further key agreements. Unless this key agreement is
 reinitialized with one of the init methods, the same
 private information and algorithm parameters will be used for
 subsequent key agreements.

Returns:
the new buffer with the shared secret
Throws:
IllegalStateException - if this key agreement has not been
 completed yet


"
KeyAgreement,"generateSecret(byte[] sharedSecret, int offset)",int,"Generates the shared secret, and places it into the buffer sharedSecret, beginning at offset inclusive.","

generateSecret
public final int generateSecret(byte[] sharedSecret,
                                int offset)
                         throws IllegalStateException,
                                ShortBufferException
Generates the shared secret, and places it into the buffer
 sharedSecret, beginning at offset inclusive.

 If the sharedSecret buffer is too small to hold the
 result, a ShortBufferException is thrown.
 In this case, this call should be repeated with a larger output buffer.

 This method resets this KeyAgreement object, so that it
 can be reused for further key agreements. Unless this key agreement is
 reinitialized with one of the init methods, the same
 private information and algorithm parameters will be used for
 subsequent key agreements.

Parameters:
sharedSecret - the buffer for the shared secret
offset - the offset in sharedSecret where the
 shared secret will be stored
Returns:
the number of bytes placed into sharedSecret
Throws:
IllegalStateException - if this key agreement has not been
 completed yet
ShortBufferException - if the given output buffer is too small
 to hold the secret


"
KeyAgreement,generateSecret(String algorithm),SecretKey,Creates the shared secret and returns it as a SecretKey object of the specified algorithm.,"

generateSecret
public final SecretKey generateSecret(String algorithm)
                               throws IllegalStateException,
                                      NoSuchAlgorithmException,
                                      InvalidKeyException
Creates the shared secret and returns it as a SecretKey
 object of the specified algorithm.

 This method resets this KeyAgreement object, so that it
 can be reused for further key agreements. Unless this key agreement is
 reinitialized with one of the init methods, the same
 private information and algorithm parameters will be used for
 subsequent key agreements.

Parameters:
algorithm - the requested secret-key algorithm
Returns:
the shared secret key
Throws:
IllegalStateException - if this key agreement has not been
 completed yet
NoSuchAlgorithmException - if the specified secret-key
 algorithm is not available
InvalidKeyException - if the shared secret-key material cannot
 be used to generate a secret key of the specified algorithm (e.g.,
 the key material is too short)


"
KeyAgreement,getAlgorithm(),String,Returns the algorithm name of this KeyAgreement object.,"

getAlgorithm
public final String getAlgorithm()
Returns the algorithm name of this KeyAgreement object.

 This is the same name that was specified in one of the
 getInstance calls that created this
 KeyAgreement object.

Returns:
the algorithm name of this KeyAgreement object.


"
KeyAgreement,getInstance(String algorithm),static KeyAgreement,Returns a KeyAgreement object that implements the specified key agreement algorithm.,"

getInstance
public static final KeyAgreement getInstance(String algorithm)
                                      throws NoSuchAlgorithmException
Returns a KeyAgreement object that implements the
 specified key agreement algorithm.

  This method traverses the list of registered security Providers,
 starting with the most preferred Provider.
 A new KeyAgreement object encapsulating the
 KeyAgreementSpi implementation from the first
 Provider that supports the specified algorithm is returned.

  Note that the list of registered providers may be retrieved via
 the Security.getProviders() method.

Parameters:
algorithm - the standard name of the requested key agreement
 algorithm.
 See the KeyAgreement section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard algorithm names.
Returns:
the new KeyAgreement object.
Throws:
NullPointerException - if the specified algorithm
          is null.
NoSuchAlgorithmException - if no Provider supports a
          KeyAgreementSpi implementation for the
          specified algorithm.
See Also:
Provider


"
KeyAgreement,"getInstance(String algorithm, Provider provider)",static KeyAgreement,Returns a KeyAgreement object that implements the specified key agreement algorithm.,"

getInstance
public static final KeyAgreement getInstance(String algorithm,
                                             Provider provider)
                                      throws NoSuchAlgorithmException
Returns a KeyAgreement object that implements the
 specified key agreement algorithm.

  A new KeyAgreement object encapsulating the
 KeyAgreementSpi implementation from the specified Provider
 object is returned.  Note that the specified Provider object
 does not have to be registered in the provider list.

Parameters:
algorithm - the standard name of the requested key agreement
 algorithm.
 See the KeyAgreement section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard algorithm names.
provider - the provider.
Returns:
the new KeyAgreement object.
Throws:
NullPointerException - if the specified algorithm
          is null.
NoSuchAlgorithmException - if a KeyAgreementSpi
          implementation for the specified algorithm is not available
          from the specified Provider object.
IllegalArgumentException - if the provider
          is null.
See Also:
Provider


"
KeyAgreement,"getInstance(String algorithm, String provider)",static KeyAgreement,Returns a KeyAgreement object that implements the specified key agreement algorithm.,"

getInstance
public static final KeyAgreement getInstance(String algorithm,
                                             String provider)
                                      throws NoSuchAlgorithmException,
                                             NoSuchProviderException
Returns a KeyAgreement object that implements the
 specified key agreement algorithm.

  A new KeyAgreement object encapsulating the
 KeyAgreementSpi implementation from the specified provider
 is returned.  The specified provider must be registered
 in the security provider list.

  Note that the list of registered providers may be retrieved via
 the Security.getProviders() method.

Parameters:
algorithm - the standard name of the requested key agreement
 algorithm.
 See the KeyAgreement section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard algorithm names.
provider - the name of the provider.
Returns:
the new KeyAgreement object.
Throws:
NullPointerException - if the specified algorithm
          is null.
NoSuchAlgorithmException - if a KeyAgreementSpi
          implementation for the specified algorithm is not
          available from the specified provider.
NoSuchProviderException - if the specified provider is not
          registered in the security provider list.
IllegalArgumentException - if the provider
          is null or empty.
See Also:
Provider


"
KeyAgreement,getProvider(),Provider,Returns the provider of this KeyAgreement object.,"

getProvider
public final Provider getProvider()
Returns the provider of this KeyAgreement object.

Returns:
the provider of this KeyAgreement object


"
KeyAgreement,init(Key key),void,"Initializes this key agreement with the given key, which is required to contain all the algorithm parameters required for this key agreement.","

init
public final void init(Key key)
                throws InvalidKeyException
Initializes this key agreement with the given key, which is required to
 contain all the algorithm parameters required for this key agreement.

  If this key agreement requires any random bytes, it will get
 them using the
 SecureRandom
 implementation of the highest-priority
 installed provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)

Parameters:
key - the party's private information. For example, in the case
 of the Diffie-Hellman key agreement, this would be the party's own
 Diffie-Hellman private key.
Throws:
InvalidKeyException - if the given key is
 inappropriate for this key agreement, e.g., is of the wrong type or
 has an incompatible algorithm type.


"
KeyAgreement,"init(Key key, AlgorithmParameterSpec params)",void,Initializes this key agreement with the given key and set of algorithm parameters.,"

init
public final void init(Key key,
                       AlgorithmParameterSpec params)
                throws InvalidKeyException,
                       InvalidAlgorithmParameterException
Initializes this key agreement with the given key and set of
 algorithm parameters.

  If this key agreement requires any random bytes, it will get
 them using the
 SecureRandom
 implementation of the highest-priority
 installed provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)

Parameters:
key - the party's private information. For example, in the case
 of the Diffie-Hellman key agreement, this would be the party's own
 Diffie-Hellman private key.
params - the key agreement parameters
Throws:
InvalidKeyException - if the given key is
 inappropriate for this key agreement, e.g., is of the wrong type or
 has an incompatible algorithm type.
InvalidAlgorithmParameterException - if the given parameters
 are inappropriate for this key agreement.


"
KeyAgreement,"init(Key key, AlgorithmParameterSpec params, SecureRandom random)",void,"Initializes this key agreement with the given key, set of algorithm parameters, and source of randomness.","

init
public final void init(Key key,
                       AlgorithmParameterSpec params,
                       SecureRandom random)
                throws InvalidKeyException,
                       InvalidAlgorithmParameterException
Initializes this key agreement with the given key, set of
 algorithm parameters, and source of randomness.

Parameters:
key - the party's private information. For example, in the case
 of the Diffie-Hellman key agreement, this would be the party's own
 Diffie-Hellman private key.
params - the key agreement parameters
random - the source of randomness
Throws:
InvalidKeyException - if the given key is
 inappropriate for this key agreement, e.g., is of the wrong type or
 has an incompatible algorithm type.
InvalidAlgorithmParameterException - if the given parameters
 are inappropriate for this key agreement.


"
KeyAgreement,"init(Key key, SecureRandom random)",void,Initializes this key agreement with the given key and source of randomness.,"

init
public final void init(Key key,
                       SecureRandom random)
                throws InvalidKeyException
Initializes this key agreement with the given key and source of
 randomness. The given key is required to contain all the algorithm
 parameters required for this key agreement.

  If the key agreement algorithm requires random bytes, it gets them
 from the given source of randomness, random.
 However, if the underlying
 algorithm implementation does not require any random bytes,
 random is ignored.

Parameters:
key - the party's private information. For example, in the case
 of the Diffie-Hellman key agreement, this would be the party's own
 Diffie-Hellman private key.
random - the source of randomness
Throws:
InvalidKeyException - if the given key is
 inappropriate for this key agreement, e.g., is of the wrong type or
 has an incompatible algorithm type.


"
KeyAgreementSpi,"engineDoPhase(Key key, boolean lastPhase)",protected abstract Key,Executes the next phase of this key agreement with the given key that was received from one of the other parties involved in this key agreement.,"

engineDoPhase
protected abstract Key engineDoPhase(Key key,
                                     boolean lastPhase)
                              throws InvalidKeyException,
                                     IllegalStateException
Executes the next phase of this key agreement with the given
 key that was received from one of the other parties involved in this key
 agreement.

Parameters:
key - the key for this phase. For example, in the case of
 Diffie-Hellman between 2 parties, this would be the other party's
 Diffie-Hellman public key.
lastPhase - flag which indicates whether or not this is the last
 phase of this key agreement.
Returns:
the (intermediate) key resulting from this phase, or null if
 this phase does not yield a key
Throws:
InvalidKeyException - if the given key is inappropriate for
 this phase.
IllegalStateException - if this key agreement has not been
 initialized.


"
KeyAgreementSpi,engineGenerateSecret(),protected abstract byte[],Generates the shared secret and returns it in a new buffer.,"

engineGenerateSecret
protected abstract byte[] engineGenerateSecret()
                                        throws IllegalStateException
Generates the shared secret and returns it in a new buffer.

 This method resets this KeyAgreementSpi object,
 so that it
 can be reused for further key agreements. Unless this key agreement is
 reinitialized with one of the engineInit methods, the same
 private information and algorithm parameters will be used for
 subsequent key agreements.

Returns:
the new buffer with the shared secret
Throws:
IllegalStateException - if this key agreement has not been
 completed yet


"
KeyAgreementSpi,"engineGenerateSecret(byte[] sharedSecret, int offset)",protected abstract int,"Generates the shared secret, and places it into the buffer sharedSecret, beginning at offset inclusive.","

engineGenerateSecret
protected abstract int engineGenerateSecret(byte[] sharedSecret,
                                            int offset)
                                     throws IllegalStateException,
                                            ShortBufferException
Generates the shared secret, and places it into the buffer
 sharedSecret, beginning at offset inclusive.

 If the sharedSecret buffer is too small to hold the
 result, a ShortBufferException is thrown.
 In this case, this call should be repeated with a larger output buffer.

 This method resets this KeyAgreementSpi object,
 so that it
 can be reused for further key agreements. Unless this key agreement is
 reinitialized with one of the engineInit methods, the same
 private information and algorithm parameters will be used for
 subsequent key agreements.

Parameters:
sharedSecret - the buffer for the shared secret
offset - the offset in sharedSecret where the
 shared secret will be stored
Returns:
the number of bytes placed into sharedSecret
Throws:
IllegalStateException - if this key agreement has not been
 completed yet
ShortBufferException - if the given output buffer is too small
 to hold the secret


"
KeyAgreementSpi,engineGenerateSecret(String algorithm),protected abstract SecretKey,Creates the shared secret and returns it as a secret key object of the requested algorithm type.,"

engineGenerateSecret
protected abstract SecretKey engineGenerateSecret(String algorithm)
                                           throws IllegalStateException,
                                                  NoSuchAlgorithmException,
                                                  InvalidKeyException
Creates the shared secret and returns it as a secret key object
 of the requested algorithm type.

 This method resets this KeyAgreementSpi object,
 so that it
 can be reused for further key agreements. Unless this key agreement is
 reinitialized with one of the engineInit methods, the same
 private information and algorithm parameters will be used for
 subsequent key agreements.

Parameters:
algorithm - the requested secret key algorithm
Returns:
the shared secret key
Throws:
IllegalStateException - if this key agreement has not been
 completed yet
NoSuchAlgorithmException - if the requested secret key
 algorithm is not available
InvalidKeyException - if the shared secret key material cannot
 be used to generate a secret key of the requested algorithm type (e.g.,
 the key material is too short)


"
KeyAgreementSpi,"engineInit(Key key, AlgorithmParameterSpec params, SecureRandom random)",protected abstract void,"Initializes this key agreement with the given key, set of algorithm parameters, and source of randomness.","

engineInit
protected abstract void engineInit(Key key,
                                   AlgorithmParameterSpec params,
                                   SecureRandom random)
                            throws InvalidKeyException,
                                   InvalidAlgorithmParameterException
Initializes this key agreement with the given key, set of
 algorithm parameters, and source of randomness.

Parameters:
key - the party's private information. For example, in the case
 of the Diffie-Hellman key agreement, this would be the party's own
 Diffie-Hellman private key.
params - the key agreement parameters
random - the source of randomness
Throws:
InvalidKeyException - if the given key is
 inappropriate for this key agreement, e.g., is of the wrong type or
 has an incompatible algorithm type.
InvalidAlgorithmParameterException - if the given parameters
 are inappropriate for this key agreement.


"
KeyAgreementSpi,"engineInit(Key key, SecureRandom random)",protected abstract void,Initializes this key agreement with the given key and source of randomness.,"

engineInit
protected abstract void engineInit(Key key,
                                   SecureRandom random)
                            throws InvalidKeyException
Initializes this key agreement with the given key and source of
 randomness. The given key is required to contain all the algorithm
 parameters required for this key agreement.

  If the key agreement algorithm requires random bytes, it gets them
 from the given source of randomness, random.
 However, if the underlying
 algorithm implementation does not require any random bytes,
 random is ignored.

Parameters:
key - the party's private information. For example, in the case
 of the Diffie-Hellman key agreement, this would be the party's own
 Diffie-Hellman private key.
random - the source of randomness
Throws:
InvalidKeyException - if the given key is
 inappropriate for this key agreement, e.g., is of the wrong type or
 has an incompatible algorithm type.


"
KeyGenerator,generateKey(),SecretKey,Generates a secret key.,"

generateKey
public final SecretKey generateKey()
Generates a secret key.

Returns:
the new key


"
KeyGenerator,getAlgorithm(),String,Returns the algorithm name of this KeyGenerator object.,"

getAlgorithm
public final String getAlgorithm()
Returns the algorithm name of this KeyGenerator object.

 This is the same name that was specified in one of the
 getInstance calls that created this
 KeyGenerator object.

Returns:
the algorithm name of this KeyGenerator object.


"
KeyGenerator,getInstance(String algorithm),static KeyGenerator,Returns a KeyGenerator object that generates secret keys for the specified algorithm.,"

getInstance
public static final KeyGenerator getInstance(String algorithm)
                                      throws NoSuchAlgorithmException
Returns a KeyGenerator object that generates secret keys
 for the specified algorithm.

  This method traverses the list of registered security Providers,
 starting with the most preferred Provider.
 A new KeyGenerator object encapsulating the
 KeyGeneratorSpi implementation from the first
 Provider that supports the specified algorithm is returned.

  Note that the list of registered providers may be retrieved via
 the Security.getProviders() method.

Parameters:
algorithm - the standard name of the requested key algorithm.
 See the KeyGenerator section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard algorithm names.
Returns:
the new KeyGenerator object.
Throws:
NullPointerException - if the specified algorithm is null.
NoSuchAlgorithmException - if no Provider supports a
          KeyGeneratorSpi implementation for the
          specified algorithm.
See Also:
Provider


"
KeyGenerator,"getInstance(String algorithm, Provider provider)",static KeyGenerator,Returns a KeyGenerator object that generates secret keys for the specified algorithm.,"

getInstance
public static final KeyGenerator getInstance(String algorithm,
                                             Provider provider)
                                      throws NoSuchAlgorithmException
Returns a KeyGenerator object that generates secret keys
 for the specified algorithm.

  A new KeyGenerator object encapsulating the
 KeyGeneratorSpi implementation from the specified Provider
 object is returned.  Note that the specified Provider object
 does not have to be registered in the provider list.

Parameters:
algorithm - the standard name of the requested key algorithm.
 See the KeyGenerator section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard algorithm names.
provider - the provider.
Returns:
the new KeyGenerator object.
Throws:
NullPointerException - if the specified algorithm is null.
NoSuchAlgorithmException - if a KeyGeneratorSpi
          implementation for the specified algorithm is not available
          from the specified Provider object.
IllegalArgumentException - if the provider
          is null.
See Also:
Provider


"
KeyGenerator,"getInstance(String algorithm, String provider)",static KeyGenerator,Returns a KeyGenerator object that generates secret keys for the specified algorithm.,"

getInstance
public static final KeyGenerator getInstance(String algorithm,
                                             String provider)
                                      throws NoSuchAlgorithmException,
                                             NoSuchProviderException
Returns a KeyGenerator object that generates secret keys
 for the specified algorithm.

  A new KeyGenerator object encapsulating the
 KeyGeneratorSpi implementation from the specified provider
 is returned.  The specified provider must be registered
 in the security provider list.

  Note that the list of registered providers may be retrieved via
 the Security.getProviders() method.

Parameters:
algorithm - the standard name of the requested key algorithm.
 See the KeyGenerator section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard algorithm names.
provider - the name of the provider.
Returns:
the new KeyGenerator object.
Throws:
NullPointerException - if the specified algorithm is null.
NoSuchAlgorithmException - if a KeyGeneratorSpi
          implementation for the specified algorithm is not
          available from the specified provider.
NoSuchProviderException - if the specified provider is not
          registered in the security provider list.
IllegalArgumentException - if the provider
          is null or empty.
See Also:
Provider


"
KeyGenerator,getProvider(),Provider,Returns the provider of this KeyGenerator object.,"

getProvider
public final Provider getProvider()
Returns the provider of this KeyGenerator object.

Returns:
the provider of this KeyGenerator object


"
KeyGenerator,init(AlgorithmParameterSpec params),void,Initializes this key generator with the specified parameter set.,"

init
public final void init(AlgorithmParameterSpec params)
                throws InvalidAlgorithmParameterException
Initializes this key generator with the specified parameter set.

  If this key generator requires any random bytes, it will get them
 using the
 SecureRandom
 implementation of the highest-priority installed
 provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)

Parameters:
params - the key generation parameters
Throws:
InvalidAlgorithmParameterException - if the given parameters
 are inappropriate for this key generator


"
KeyGenerator,"init(AlgorithmParameterSpec params, SecureRandom random)",void,Initializes this key generator with the specified parameter set and a user-provided source of randomness.,"

init
public final void init(AlgorithmParameterSpec params,
                       SecureRandom random)
                throws InvalidAlgorithmParameterException
Initializes this key generator with the specified parameter
 set and a user-provided source of randomness.

Parameters:
params - the key generation parameters
random - the source of randomness for this key generator
Throws:
InvalidAlgorithmParameterException - if params is
 inappropriate for this key generator


"
KeyGenerator,init(int keysize),void,Initializes this key generator for a certain keysize.,"

init
public final void init(int keysize)
Initializes this key generator for a certain keysize.

  If this key generator requires any random bytes, it will get them
 using the
 SecureRandom
 implementation of the highest-priority installed
 provider as the source of randomness.
 (If none of the installed providers supply an implementation of
 SecureRandom, a system-provided source of randomness will be used.)

Parameters:
keysize - the keysize. This is an algorithm-specific metric,
 specified in number of bits.
Throws:
InvalidParameterException - if the keysize is wrong or not
 supported.


"
KeyGenerator,"init(int keysize, SecureRandom random)",void,"Initializes this key generator for a certain keysize, using a user-provided source of randomness.","

init
public final void init(int keysize,
                       SecureRandom random)
Initializes this key generator for a certain keysize, using a
 user-provided source of randomness.

Parameters:
keysize - the keysize. This is an algorithm-specific metric,
 specified in number of bits.
random - the source of randomness for this key generator
Throws:
InvalidParameterException - if the keysize is wrong or not
 supported.


"
KeyGenerator,init(SecureRandom random),void,Initializes this key generator.,"

init
public final void init(SecureRandom random)
Initializes this key generator.

Parameters:
random - the source of randomness for this generator


"
KeyGeneratorSpi,engineGenerateKey(),protected abstract SecretKey,Generates a secret key.,"

engineGenerateKey
protected abstract SecretKey engineGenerateKey()
Generates a secret key.

Returns:
the new key


"
KeyGeneratorSpi,"engineInit(AlgorithmParameterSpec params, SecureRandom random)",protected abstract void,Initializes the key generator with the specified parameter set and a user-provided source of randomness.,"

engineInit
protected abstract void engineInit(AlgorithmParameterSpec params,
                                   SecureRandom random)
                            throws InvalidAlgorithmParameterException
Initializes the key generator with the specified parameter
 set and a user-provided source of randomness.

Parameters:
params - the key generation parameters
random - the source of randomness for this key generator
Throws:
InvalidAlgorithmParameterException - if params is
 inappropriate for this key generator


"
KeyGeneratorSpi,"engineInit(int keysize, SecureRandom random)",protected abstract void,"Initializes this key generator for a certain keysize, using the given source of randomness.","

engineInit
protected abstract void engineInit(int keysize,
                                   SecureRandom random)
Initializes this key generator for a certain keysize, using the given
 source of randomness.

Parameters:
keysize - the keysize. This is an algorithm-specific metric,
 specified in number of bits.
random - the source of randomness for this key generator
Throws:
InvalidParameterException - if the keysize is wrong or not
 supported.


"
KeyGeneratorSpi,engineInit(SecureRandom random),protected abstract void,Initializes the key generator.,"

engineInit
protected abstract void engineInit(SecureRandom random)
Initializes the key generator.

Parameters:
random - the source of randomness for this generator


"
Mac,clone(),Object,Returns a clone if the provider implementation is cloneable.,"

clone
public final Object clone()
                   throws CloneNotSupportedException
Returns a clone if the provider implementation is cloneable.

Overrides:
clone in class Object
Returns:
a clone if the provider implementation is cloneable.
Throws:
CloneNotSupportedException - if this is called on a
 delegate that does not support Cloneable.
See Also:
Cloneable


"
Mac,doFinal(),byte[],Finishes the MAC operation.,"

doFinal
public final byte[] doFinal()
                     throws IllegalStateException
Finishes the MAC operation.

 A call to this method resets this Mac object to the
 state it was in when previously initialized via a call to
 init(Key) or
 init(Key, AlgorithmParameterSpec).
 That is, the object is reset and available to generate another MAC from
 the same key, if desired, via new calls to update and
 doFinal.
 (In order to reuse this Mac object with a different key,
 it must be reinitialized via a call to init(Key) or
 init(Key, AlgorithmParameterSpec).

Returns:
the MAC result.
Throws:
IllegalStateException - if this Mac has not been
 initialized.


"
Mac,doFinal(byte[] input),byte[],Processes the given array of bytes and finishes the MAC operation.,"

doFinal
public final byte[] doFinal(byte[] input)
                     throws IllegalStateException
Processes the given array of bytes and finishes the MAC operation.

 A call to this method resets this Mac object to the
 state it was in when previously initialized via a call to
 init(Key) or
 init(Key, AlgorithmParameterSpec).
 That is, the object is reset and available to generate another MAC from
 the same key, if desired, via new calls to update and
 doFinal.
 (In order to reuse this Mac object with a different key,
 it must be reinitialized via a call to init(Key) or
 init(Key, AlgorithmParameterSpec).

Parameters:
input - data in bytes
Returns:
the MAC result.
Throws:
IllegalStateException - if this Mac has not been
 initialized.


"
Mac,"doFinal(byte[] output, int outOffset)",void,Finishes the MAC operation.,"

doFinal
public final void doFinal(byte[] output,
                          int outOffset)
                   throws ShortBufferException,
                          IllegalStateException
Finishes the MAC operation.

 A call to this method resets this Mac object to the
 state it was in when previously initialized via a call to
 init(Key) or
 init(Key, AlgorithmParameterSpec).
 That is, the object is reset and available to generate another MAC from
 the same key, if desired, via new calls to update and
 doFinal.
 (In order to reuse this Mac object with a different key,
 it must be reinitialized via a call to init(Key) or
 init(Key, AlgorithmParameterSpec).

 The MAC result is stored in output, starting at
 outOffset inclusive.

Parameters:
output - the buffer where the MAC result is stored
outOffset - the offset in output where the MAC is
 stored
Throws:
ShortBufferException - if the given output buffer is too small
 to hold the result
IllegalStateException - if this Mac has not been
 initialized.


"
Mac,getAlgorithm(),String,Returns the algorithm name of this Mac object.,"

getAlgorithm
public final String getAlgorithm()
Returns the algorithm name of this Mac object.

 This is the same name that was specified in one of the
 getInstance calls that created this
 Mac object.

Returns:
the algorithm name of this Mac object.


"
Mac,getInstance(String algorithm),static Mac,Returns a Mac object that implements the specified MAC algorithm.,"

getInstance
public static final Mac getInstance(String algorithm)
                             throws NoSuchAlgorithmException
Returns a Mac object that implements the
 specified MAC algorithm.

  This method traverses the list of registered security Providers,
 starting with the most preferred Provider.
 A new Mac object encapsulating the
 MacSpi implementation from the first
 Provider that supports the specified algorithm is returned.

  Note that the list of registered providers may be retrieved via
 the Security.getProviders() method.

Parameters:
algorithm - the standard name of the requested MAC algorithm.
 See the Mac section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard algorithm names.
Returns:
the new Mac object.
Throws:
NoSuchAlgorithmException - if no Provider supports a
          MacSpi implementation for the
          specified algorithm.
See Also:
Provider


"
Mac,"getInstance(String algorithm, Provider provider)",static Mac,Returns a Mac object that implements the specified MAC algorithm.,"

getInstance
public static final Mac getInstance(String algorithm,
                                    Provider provider)
                             throws NoSuchAlgorithmException
Returns a Mac object that implements the
 specified MAC algorithm.

  A new Mac object encapsulating the
 MacSpi implementation from the specified Provider
 object is returned.  Note that the specified Provider object
 does not have to be registered in the provider list.

Parameters:
algorithm - the standard name of the requested MAC algorithm.
 See the Mac section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard algorithm names.
provider - the provider.
Returns:
the new Mac object.
Throws:
NoSuchAlgorithmException - if a MacSpi
          implementation for the specified algorithm is not available
          from the specified Provider object.
IllegalArgumentException - if the provider
          is null.
See Also:
Provider


"
Mac,"getInstance(String algorithm, String provider)",static Mac,Returns a Mac object that implements the specified MAC algorithm.,"

getInstance
public static final Mac getInstance(String algorithm,
                                    String provider)
                             throws NoSuchAlgorithmException,
                                    NoSuchProviderException
Returns a Mac object that implements the
 specified MAC algorithm.

  A new Mac object encapsulating the
 MacSpi implementation from the specified provider
 is returned.  The specified provider must be registered
 in the security provider list.

  Note that the list of registered providers may be retrieved via
 the Security.getProviders() method.

Parameters:
algorithm - the standard name of the requested MAC algorithm.
 See the Mac section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard algorithm names.
provider - the name of the provider.
Returns:
the new Mac object.
Throws:
NoSuchAlgorithmException - if a MacSpi
          implementation for the specified algorithm is not
          available from the specified provider.
NoSuchProviderException - if the specified provider is not
          registered in the security provider list.
IllegalArgumentException - if the provider
          is null or empty.
See Also:
Provider


"
Mac,getMacLength(),int,Returns the length of the MAC in bytes.,"

getMacLength
public final int getMacLength()
Returns the length of the MAC in bytes.

Returns:
the MAC length in bytes.


"
Mac,getProvider(),Provider,Returns the provider of this Mac object.,"

getProvider
public final Provider getProvider()
Returns the provider of this Mac object.

Returns:
the provider of this Mac object.


"
Mac,init(Key key),void,Initializes this Mac object with the given key.,"

init
public final void init(Key key)
                throws InvalidKeyException
Initializes this Mac object with the given key.

Parameters:
key - the key.
Throws:
InvalidKeyException - if the given key is inappropriate for
 initializing this MAC.


"
Mac,"init(Key key, AlgorithmParameterSpec params)",void,Initializes this Mac object with the given key and algorithm parameters.,"

init
public final void init(Key key,
                       AlgorithmParameterSpec params)
                throws InvalidKeyException,
                       InvalidAlgorithmParameterException
Initializes this Mac object with the given key and
 algorithm parameters.

Parameters:
key - the key.
params - the algorithm parameters.
Throws:
InvalidKeyException - if the given key is inappropriate for
 initializing this MAC.
InvalidAlgorithmParameterException - if the given algorithm
 parameters are inappropriate for this MAC.


"
Mac,reset(),void,Resets this Mac object.,"

reset
public final void reset()
Resets this Mac object.

 A call to this method resets this Mac object to the
 state it was in when previously initialized via a call to
 init(Key) or
 init(Key, AlgorithmParameterSpec).
 That is, the object is reset and available to generate another MAC from
 the same key, if desired, via new calls to update and
 doFinal.
 (In order to reuse this Mac object with a different key,
 it must be reinitialized via a call to init(Key) or
 init(Key, AlgorithmParameterSpec).

"
Mac,update(byte input),void,Processes the given byte.,"

update
public final void update(byte input)
                  throws IllegalStateException
Processes the given byte.

Parameters:
input - the input byte to be processed.
Throws:
IllegalStateException - if this Mac has not been
 initialized.


"
Mac,update(byte[] input),void,Processes the given array of bytes.,"

update
public final void update(byte[] input)
                  throws IllegalStateException
Processes the given array of bytes.

Parameters:
input - the array of bytes to be processed.
Throws:
IllegalStateException - if this Mac has not been
 initialized.


"
Mac,"update(byte[] input, int offset, int len)",void,"Processes the first len bytes in input, starting at offset inclusive.","

update
public final void update(byte[] input,
                         int offset,
                         int len)
                  throws IllegalStateException
Processes the first len bytes in input,
 starting at offset inclusive.

Parameters:
input - the input buffer.
offset - the offset in input where the input starts.
len - the number of bytes to process.
Throws:
IllegalStateException - if this Mac has not been
 initialized.


"
Mac,update(ByteBuffer input),void,"Processes input.remaining() bytes in the ByteBuffer input, starting at input.position().","

update
public final void update(ByteBuffer input)
Processes input.remaining() bytes in the ByteBuffer
 input, starting at input.position().
 Upon return, the buffer's position will be equal to its limit;
 its limit will not have changed.

Parameters:
input - the ByteBuffer
Throws:
IllegalStateException - if this Mac has not been
 initialized.
Since:
1.5


"
MacSpi,clone(),Object,Returns a clone if the implementation is cloneable.,"

clone
public Object clone()
             throws CloneNotSupportedException
Returns a clone if the implementation is cloneable.

Overrides:
clone in class Object
Returns:
a clone if the implementation is cloneable.
Throws:
CloneNotSupportedException - if this is called
 on an implementation that does not support Cloneable.
See Also:
Cloneable


"
MacSpi,engineDoFinal(),protected abstract byte[],"Completes the MAC computation and resets the MAC for further use, maintaining the secret key that the MAC was initialized with.","

engineDoFinal
protected abstract byte[] engineDoFinal()
Completes the MAC computation and resets the MAC for further use,
 maintaining the secret key that the MAC was initialized with.

Returns:
the MAC result.


"
MacSpi,engineGetMacLength(),protected abstract int,Returns the length of the MAC in bytes.,"

engineGetMacLength
protected abstract int engineGetMacLength()
Returns the length of the MAC in bytes.

Returns:
the MAC length in bytes.


"
MacSpi,"engineInit(Key key, AlgorithmParameterSpec params)",protected abstract void,Initializes the MAC with the given (secret) key and algorithm parameters.,"

engineInit
protected abstract void engineInit(Key key,
                                   AlgorithmParameterSpec params)
                            throws InvalidKeyException,
                                   InvalidAlgorithmParameterException
Initializes the MAC with the given (secret) key and algorithm
 parameters.

Parameters:
key - the (secret) key.
params - the algorithm parameters.
Throws:
InvalidKeyException - if the given key is inappropriate for
 initializing this MAC.
InvalidAlgorithmParameterException - if the given algorithm
 parameters are inappropriate for this MAC.


"
MacSpi,engineReset(),protected abstract void,"Resets the MAC for further use, maintaining the secret key that the MAC was initialized with.","

engineReset
protected abstract void engineReset()
Resets the MAC for further use, maintaining the secret key that the
 MAC was initialized with.

"
MacSpi,engineUpdate(byte input),protected abstract void,Processes the given byte.,"

engineUpdate
protected abstract void engineUpdate(byte input)
Processes the given byte.

Parameters:
input - the input byte to be processed.


"
MacSpi,"engineUpdate(byte[] input, int offset, int len)",protected abstract void,"Processes the first len bytes in input, starting at offset inclusive.","

engineUpdate
protected abstract void engineUpdate(byte[] input,
                                     int offset,
                                     int len)
Processes the first len bytes in input,
 starting at offset inclusive.

Parameters:
input - the input buffer.
offset - the offset in input where the input starts.
len - the number of bytes to process.


"
MacSpi,engineUpdate(ByteBuffer input),protected void,"Processes input.remaining() bytes in the ByteBuffer input, starting at input.position().","

engineUpdate
protected void engineUpdate(ByteBuffer input)
Processes input.remaining() bytes in the ByteBuffer
 input, starting at input.position().
 Upon return, the buffer's position will be equal to its limit;
 its limit will not have changed.

 Subclasses should consider overriding this method if they can
 process ByteBuffers more efficiently than byte arrays.

Parameters:
input - the ByteBuffer
Since:
1.5


"
SealedObject,getAlgorithm(),String,Returns the algorithm that was used to seal this object.,"

getAlgorithm
public final String getAlgorithm()
Returns the algorithm that was used to seal this object.

Returns:
the algorithm that was used to seal this object.


"
SealedObject,getObject(Cipher c),Object,Retrieves the original (encapsulated) object.,"

getObject
public final Object getObject(Cipher c)
                       throws IOException,
                              ClassNotFoundException,
                              IllegalBlockSizeException,
                              BadPaddingException
Retrieves the original (encapsulated) object.

 The encapsulated object is unsealed (using the given Cipher,
 assuming that the Cipher is already properly initialized) and
 de-serialized, before it is returned.

Parameters:
c - the cipher used to unseal the object
Returns:
the original object.
Throws:
NullPointerException - if the given cipher is null.
IOException - if an error occurs during de-serialiazation
ClassNotFoundException - if an error occurs during
 de-serialiazation
IllegalBlockSizeException - if the given cipher is a block
 cipher, no padding has been requested, and the total input length is
 not a multiple of the cipher's block size
BadPaddingException - if the given cipher has been
 initialized for decryption, and padding has been specified, but
 the input data does not have proper expected padding bytes


"
SealedObject,getObject(Key key),Object,Retrieves the original (encapsulated) object.,"

getObject
public final Object getObject(Key key)
                       throws IOException,
                              ClassNotFoundException,
                              NoSuchAlgorithmException,
                              InvalidKeyException
Retrieves the original (encapsulated) object.

 This method creates a cipher for the algorithm that had been used in
 the sealing operation.
 If the default provider package provides an implementation of that
 algorithm, an instance of Cipher containing that implementation is used.
 If the algorithm is not available in the default package, other
 packages are searched.
 The Cipher object is initialized for decryption, using the given
 key and the parameters (if any) that had been used in the
 sealing operation.

 The encapsulated object is unsealed and de-serialized, before it is
 returned.

Parameters:
key - the key used to unseal the object.
Returns:
the original object.
Throws:
IOException - if an error occurs during de-serialiazation.
ClassNotFoundException - if an error occurs during
 de-serialiazation.
NoSuchAlgorithmException - if the algorithm to unseal the
 object is not available.
InvalidKeyException - if the given key cannot be used to unseal
 the object (e.g., it has the wrong algorithm).
NullPointerException - if key is null.


"
SealedObject,"getObject(Key key, String provider)",Object,Retrieves the original (encapsulated) object.,"

getObject
public final Object getObject(Key key,
                              String provider)
                       throws IOException,
                              ClassNotFoundException,
                              NoSuchAlgorithmException,
                              NoSuchProviderException,
                              InvalidKeyException
Retrieves the original (encapsulated) object.

 This method creates a cipher for the algorithm that had been used in
 the sealing operation, using an implementation of that algorithm from
 the given provider.
 The Cipher object is initialized for decryption, using the given
 key and the parameters (if any) that had been used in the
 sealing operation.

 The encapsulated object is unsealed and de-serialized, before it is
 returned.

Parameters:
key - the key used to unseal the object.
provider - the name of the provider of the algorithm to unseal
 the object.
Returns:
the original object.
Throws:
IllegalArgumentException - if the given provider is null
 or empty.
IOException - if an error occurs during de-serialiazation.
ClassNotFoundException - if an error occurs during
 de-serialiazation.
NoSuchAlgorithmException - if the algorithm to unseal the
 object is not available.
NoSuchProviderException - if the given provider is not
 configured.
InvalidKeyException - if the given key cannot be used to unseal
 the object (e.g., it has the wrong algorithm).
NullPointerException - if key is null.


"
SecretKeyFactory,generateSecret(KeySpec keySpec),SecretKey,Generates a SecretKey object from the provided key specification (key material).,"

generateSecret
public final SecretKey generateSecret(KeySpec keySpec)
                               throws InvalidKeySpecException
Generates a SecretKey object from the provided key
 specification (key material).

Parameters:
keySpec - the specification (key material) of the secret key
Returns:
the secret key
Throws:
InvalidKeySpecException - if the given key specification
 is inappropriate for this secret-key factory to produce a secret key.


"
SecretKeyFactory,getAlgorithm(),String,Returns the algorithm name of this SecretKeyFactory object.,"

getAlgorithm
public final String getAlgorithm()
Returns the algorithm name of this SecretKeyFactory object.

 This is the same name that was specified in one of the
 getInstance calls that created this
 SecretKeyFactory object.

Returns:
the algorithm name of this SecretKeyFactory
 object.


"
SecretKeyFactory,getInstance(String algorithm),static SecretKeyFactory,Returns a SecretKeyFactory object that converts secret keys of the specified algorithm.,"

getInstance
public static final SecretKeyFactory getInstance(String algorithm)
                                          throws NoSuchAlgorithmException
Returns a SecretKeyFactory object that converts
 secret keys of the specified algorithm.

  This method traverses the list of registered security Providers,
 starting with the most preferred Provider.
 A new SecretKeyFactory object encapsulating the
 SecretKeyFactorySpi implementation from the first
 Provider that supports the specified algorithm is returned.

  Note that the list of registered providers may be retrieved via
 the Security.getProviders() method.

Parameters:
algorithm - the standard name of the requested secret-key
 algorithm.
 See the SecretKeyFactory section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard algorithm names.
Returns:
the new SecretKeyFactory object.
Throws:
NullPointerException - if the specified algorithm
          is null.
NoSuchAlgorithmException - if no Provider supports a
          SecretKeyFactorySpi implementation for the
          specified algorithm.
See Also:
Provider


"
SecretKeyFactory,"getInstance(String algorithm, Provider provider)",static SecretKeyFactory,Returns a SecretKeyFactory object that converts secret keys of the specified algorithm.,"

getInstance
public static final SecretKeyFactory getInstance(String algorithm,
                                                 Provider provider)
                                          throws NoSuchAlgorithmException
Returns a SecretKeyFactory object that converts
 secret keys of the specified algorithm.

  A new SecretKeyFactory object encapsulating the
 SecretKeyFactorySpi implementation from the specified Provider
 object is returned.  Note that the specified Provider object
 does not have to be registered in the provider list.

Parameters:
algorithm - the standard name of the requested secret-key
 algorithm.
 See the SecretKeyFactory section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard algorithm names.
provider - the provider.
Returns:
the new SecretKeyFactory object.
Throws:
NullPointerException - if the specified algorithm
 is null.
NoSuchAlgorithmException - if a SecretKeyFactorySpi
          implementation for the specified algorithm is not available
          from the specified Provider object.
IllegalArgumentException - if the provider
          is null.
See Also:
Provider


"
SecretKeyFactory,"getInstance(String algorithm, String provider)",static SecretKeyFactory,Returns a SecretKeyFactory object that converts secret keys of the specified algorithm.,"

getInstance
public static final SecretKeyFactory getInstance(String algorithm,
                                                 String provider)
                                          throws NoSuchAlgorithmException,
                                                 NoSuchProviderException
Returns a SecretKeyFactory object that converts
 secret keys of the specified algorithm.

  A new SecretKeyFactory object encapsulating the
 SecretKeyFactorySpi implementation from the specified provider
 is returned.  The specified provider must be registered
 in the security provider list.

  Note that the list of registered providers may be retrieved via
 the Security.getProviders() method.

Parameters:
algorithm - the standard name of the requested secret-key
 algorithm.
 See the SecretKeyFactory section in the 
 Java Cryptography Architecture Standard Algorithm Name Documentation
 for information about standard algorithm names.
provider - the name of the provider.
Returns:
the new SecretKeyFactory object.
Throws:
NoSuchAlgorithmException - if a SecretKeyFactorySpi
          implementation for the specified algorithm is not
          available from the specified provider.
NullPointerException - if the specified algorithm
          is null.
NoSuchProviderException - if the specified provider is not
          registered in the security provider list.
IllegalArgumentException - if the provider
          is null or empty.
See Also:
Provider


"
SecretKeyFactory,"getKeySpec(SecretKey key, Class<?> keySpec)",KeySpec,Returns a specification (key material) of the given key object in the requested format.,"

getKeySpec
public final KeySpec getKeySpec(SecretKey key,
                                Class<?> keySpec)
                         throws InvalidKeySpecException
Returns a specification (key material) of the given key object
 in the requested format.

Parameters:
key - the key
keySpec - the requested format in which the key material shall be
 returned
Returns:
the underlying key specification (key material) in the
 requested format
Throws:
InvalidKeySpecException - if the requested key specification is
 inappropriate for the given key (e.g., the algorithms associated with
 key and keySpec do not match, or
 key references a key on a cryptographic hardware device
 whereas keySpec is the specification of a software-based
 key), or the given key cannot be dealt with
 (e.g., the given key has an algorithm or format not supported by this
 secret-key factory).


"
SecretKeyFactory,getProvider(),Provider,Returns the provider of this SecretKeyFactory object.,"

getProvider
public final Provider getProvider()
Returns the provider of this SecretKeyFactory object.

Returns:
the provider of this SecretKeyFactory object


"
SecretKeyFactory,translateKey(SecretKey key),SecretKey,"Translates a key object, whose provider may be unknown or potentially untrusted, into a corresponding key object of this secret-key factory.","

translateKey
public final SecretKey translateKey(SecretKey key)
                             throws InvalidKeyException
Translates a key object, whose provider may be unknown or potentially
 untrusted, into a corresponding key object of this secret-key factory.

Parameters:
key - the key whose provider is unknown or untrusted
Returns:
the translated key
Throws:
InvalidKeyException - if the given key cannot be processed
 by this secret-key factory.


"
SecretKeyFactorySpi,engineGenerateSecret(KeySpec keySpec),protected abstract SecretKey,Generates a SecretKey object from the provided key specification (key material).,"

engineGenerateSecret
protected abstract SecretKey engineGenerateSecret(KeySpec keySpec)
                                           throws InvalidKeySpecException
Generates a SecretKey object from the
 provided key specification (key material).

Parameters:
keySpec - the specification (key material) of the secret key
Returns:
the secret key
Throws:
InvalidKeySpecException - if the given key specification
 is inappropriate for this secret-key factory to produce a secret key.


"
SecretKeyFactorySpi,"engineGetKeySpec(SecretKey key, Class<?> keySpec)",protected abstract KeySpec,Returns a specification (key material) of the given key object in the requested format.,"

engineGetKeySpec
protected abstract KeySpec engineGetKeySpec(SecretKey key,
                                            Class<?> keySpec)
                                     throws InvalidKeySpecException
Returns a specification (key material) of the given key
 object in the requested format.

Parameters:
key - the key
keySpec - the requested format in which the key material shall be
 returned
Returns:
the underlying key specification (key material) in the
 requested format
Throws:
InvalidKeySpecException - if the requested key specification is
 inappropriate for the given key (e.g., the algorithms associated with
 key and keySpec do not match, or
 key references a key on a cryptographic hardware device
 whereas keySpec is the specification of a software-based
 key), or the given key cannot be dealt with
 (e.g., the given key has an algorithm or format not supported by this
 secret-key factory).


"
SecretKeyFactorySpi,engineTranslateKey(SecretKey key),protected abstract SecretKey,"Translates a key object, whose provider may be unknown or potentially untrusted, into a corresponding key object of this secret-key factory.","

engineTranslateKey
protected abstract SecretKey engineTranslateKey(SecretKey key)
                                         throws InvalidKeyException
Translates a key object, whose provider may be unknown or
 potentially untrusted, into a corresponding key object of this
 secret-key factory.

Parameters:
key - the key whose provider is unknown or untrusted
Returns:
the translated key
Throws:
InvalidKeyException - if the given key cannot be processed
 by this secret-key factory.


"
