ClassName,Method,Return Type,Description,Full Description
AbstractOwnableSynchronizer,getExclusiveOwnerThread(),protected Thread,"Returns the thread last set by setExclusiveOwnerThread, or null if never set.","

getExclusiveOwnerThread
protected final Thread getExclusiveOwnerThread()
Returns the thread last set by setExclusiveOwnerThread,
 or null if never set.  This method does not otherwise
 impose any synchronization or volatile field accesses.

Returns:
the owner thread


"
AbstractOwnableSynchronizer,setExclusiveOwnerThread(Thread thread),protected void,Sets the thread that currently owns exclusive access.,"

setExclusiveOwnerThread
protected final void setExclusiveOwnerThread(Thread thread)
Sets the thread that currently owns exclusive access.
 A null argument indicates that no thread owns access.
 This method does not otherwise impose any synchronization or
 volatile field accesses.

Parameters:
thread - the owner thread


"
AbstractQueuedLongSynchronizer,acquire(long arg),void,"Acquires in exclusive mode, ignoring interrupts.","

acquire
public final void acquire(long arg)
Acquires in exclusive mode, ignoring interrupts.  Implemented
 by invoking at least once tryAcquire(long),
 returning on success.  Otherwise the thread is queued, possibly
 repeatedly blocking and unblocking, invoking tryAcquire(long) until success.  This method can be used
 to implement method Lock.lock().

Parameters:
arg - the acquire argument.  This value is conveyed to
        tryAcquire(long) but is otherwise uninterpreted and
        can represent anything you like.


"
AbstractQueuedLongSynchronizer,acquireInterruptibly(long arg),void,"Acquires in exclusive mode, aborting if interrupted.","

acquireInterruptibly
public final void acquireInterruptibly(long arg)
                                throws InterruptedException
Acquires in exclusive mode, aborting if interrupted.
 Implemented by first checking interrupt status, then invoking
 at least once tryAcquire(long), returning on
 success.  Otherwise the thread is queued, possibly repeatedly
 blocking and unblocking, invoking tryAcquire(long)
 until success or the thread is interrupted.  This method can be
 used to implement method Lock.lockInterruptibly().

Parameters:
arg - the acquire argument.  This value is conveyed to
        tryAcquire(long) but is otherwise uninterpreted and
        can represent anything you like.
Throws:
InterruptedException - if the current thread is interrupted


"
AbstractQueuedLongSynchronizer,acquireShared(long arg),void,"Acquires in shared mode, ignoring interrupts.","

acquireShared
public final void acquireShared(long arg)
Acquires in shared mode, ignoring interrupts.  Implemented by
 first invoking at least once tryAcquireShared(long),
 returning on success.  Otherwise the thread is queued, possibly
 repeatedly blocking and unblocking, invoking tryAcquireShared(long) until success.

Parameters:
arg - the acquire argument.  This value is conveyed to
        tryAcquireShared(long) but is otherwise uninterpreted
        and can represent anything you like.


"
AbstractQueuedLongSynchronizer,acquireSharedInterruptibly(long arg),void,"Acquires in shared mode, aborting if interrupted.","

acquireSharedInterruptibly
public final void acquireSharedInterruptibly(long arg)
                                      throws InterruptedException
Acquires in shared mode, aborting if interrupted.  Implemented
 by first checking interrupt status, then invoking at least once
 tryAcquireShared(long), returning on success.  Otherwise the
 thread is queued, possibly repeatedly blocking and unblocking,
 invoking tryAcquireShared(long) until success or the thread
 is interrupted.

Parameters:
arg - the acquire argument.
 This value is conveyed to tryAcquireShared(long) but is
 otherwise uninterpreted and can represent anything
 you like.
Throws:
InterruptedException - if the current thread is interrupted


"
AbstractQueuedLongSynchronizer,"compareAndSetState(long expect, long update)",protected boolean,Atomically sets synchronization state to the given updated value if the current state value equals the expected value.,"

compareAndSetState
protected final boolean compareAndSetState(long expect,
                                           long update)
Atomically sets synchronization state to the given updated
 value if the current state value equals the expected value.
 This operation has memory semantics of a volatile read
 and write.

Parameters:
expect - the expected value
update - the new value
Returns:
true if successful. False return indicates that the actual
         value was not equal to the expected value.


"
AbstractQueuedLongSynchronizer,getExclusiveQueuedThreads(),Collection<Thread>,Returns a collection containing threads that may be waiting to acquire in exclusive mode.,"

getExclusiveQueuedThreads
public final Collection<Thread> getExclusiveQueuedThreads()
Returns a collection containing threads that may be waiting to
 acquire in exclusive mode. This has the same properties
 as getQueuedThreads() except that it only returns
 those threads waiting due to an exclusive acquire.

Returns:
the collection of threads


"
AbstractQueuedLongSynchronizer,getFirstQueuedThread(),Thread,"Returns the first (longest-waiting) thread in the queue, or null if no threads are currently queued.","

getFirstQueuedThread
public final Thread getFirstQueuedThread()
Returns the first (longest-waiting) thread in the queue, or
 null if no threads are currently queued.

 In this implementation, this operation normally returns in
 constant time, but may iterate upon contention if other threads are
 concurrently modifying the queue.

Returns:
the first (longest-waiting) thread in the queue, or
         null if no threads are currently queued


"
AbstractQueuedLongSynchronizer,getQueuedThreads(),Collection<Thread>,Returns a collection containing threads that may be waiting to acquire.,"

getQueuedThreads
public final Collection<Thread> getQueuedThreads()
Returns a collection containing threads that may be waiting to
 acquire.  Because the actual set of threads may change
 dynamically while constructing this result, the returned
 collection is only a best-effort estimate.  The elements of the
 returned collection are in no particular order.  This method is
 designed to facilitate construction of subclasses that provide
 more extensive monitoring facilities.

Returns:
the collection of threads


"
AbstractQueuedLongSynchronizer,getQueueLength(),int,Returns an estimate of the number of threads waiting to acquire.,"

getQueueLength
public final int getQueueLength()
Returns an estimate of the number of threads waiting to
 acquire.  The value is only an estimate because the number of
 threads may change dynamically while this method traverses
 internal data structures.  This method is designed for use in
 monitoring system state, not for synchronization
 control.

Returns:
the estimated number of threads waiting to acquire


"
AbstractQueuedLongSynchronizer,getSharedQueuedThreads(),Collection<Thread>,Returns a collection containing threads that may be waiting to acquire in shared mode.,"

getSharedQueuedThreads
public final Collection<Thread> getSharedQueuedThreads()
Returns a collection containing threads that may be waiting to
 acquire in shared mode. This has the same properties
 as getQueuedThreads() except that it only returns
 those threads waiting due to a shared acquire.

Returns:
the collection of threads


"
AbstractQueuedLongSynchronizer,getState(),protected long,Returns the current value of synchronization state.,"

getState
protected final long getState()
Returns the current value of synchronization state.
 This operation has memory semantics of a volatile read.

Returns:
current state value


"
AbstractQueuedLongSynchronizer,getWaitingThreads(AbstractQueuedLongSynchronizer.ConditionObject condition),Collection<Thread>,Returns a collection containing those threads that may be waiting on the given condition associated with this synchronizer.,"

getWaitingThreads
public final Collection<Thread> getWaitingThreads(AbstractQueuedLongSynchronizer.ConditionObject condition)
Returns a collection containing those threads that may be
 waiting on the given condition associated with this
 synchronizer.  Because the actual set of threads may change
 dynamically while constructing this result, the returned
 collection is only a best-effort estimate. The elements of the
 returned collection are in no particular order.

Parameters:
condition - the condition
Returns:
the collection of threads
Throws:
IllegalMonitorStateException - if exclusive synchronization
         is not held
IllegalArgumentException - if the given condition is
         not associated with this synchronizer
NullPointerException - if the condition is null


"
AbstractQueuedLongSynchronizer,getWaitQueueLength(AbstractQueuedLongSynchronizer.ConditionObject condition),int,Returns an estimate of the number of threads waiting on the given condition associated with this synchronizer.,"

getWaitQueueLength
public final int getWaitQueueLength(AbstractQueuedLongSynchronizer.ConditionObject condition)
Returns an estimate of the number of threads waiting on the
 given condition associated with this synchronizer. Note that
 because timeouts and interrupts may occur at any time, the
 estimate serves only as an upper bound on the actual number of
 waiters.  This method is designed for use in monitoring of the
 system state, not for synchronization control.

Parameters:
condition - the condition
Returns:
the estimated number of waiting threads
Throws:
IllegalMonitorStateException - if exclusive synchronization
         is not held
IllegalArgumentException - if the given condition is
         not associated with this synchronizer
NullPointerException - if the condition is null


"
AbstractQueuedLongSynchronizer,hasContended(),boolean,Queries whether any threads have ever contended to acquire this synchronizer; that is if an acquire method has ever blocked.,"

hasContended
public final boolean hasContended()
Queries whether any threads have ever contended to acquire this
 synchronizer; that is if an acquire method has ever blocked.

 In this implementation, this operation returns in
 constant time.

Returns:
true if there has ever been contention


"
AbstractQueuedLongSynchronizer,hasQueuedPredecessors(),boolean,Queries whether any threads have been waiting to acquire longer than the current thread.,"

hasQueuedPredecessors
public final boolean hasQueuedPredecessors()
Queries whether any threads have been waiting to acquire longer
 than the current thread.

 An invocation of this method is equivalent to (but may be
 more efficient than):
   
 getFirstQueuedThread() != Thread.currentThread() &&
 hasQueuedThreads()
Note that because cancellations due to interrupts and
 timeouts may occur at any time, a true return does not
 guarantee that some other thread will acquire before the current
 thread.  Likewise, it is possible for another thread to win a
 race to enqueue after this method has returned false,
 due to the queue being empty.

 This method is designed to be used by a fair synchronizer to
 avoid barging.
 Such a synchronizer's tryAcquire(long) method should return
 false, and its tryAcquireShared(long) method should
 return a negative value, if this method returns true
 (unless this is a reentrant acquire).  For example, the tryAcquire method for a fair, reentrant, exclusive mode
 synchronizer might look like this:

   
 protected boolean tryAcquire(int arg) {
   if (isHeldExclusively()) {
     // A reentrant acquire; increment hold count
     return true;
   } else if (hasQueuedPredecessors()) {
     return false;
   } else {
     // try to acquire normally
   }
 }

Returns:
true if there is a queued thread preceding the
         current thread, and false if the current thread
         is at the head of the queue or the queue is empty
Since:
1.7


"
AbstractQueuedLongSynchronizer,hasQueuedThreads(),boolean,Queries whether any threads are waiting to acquire.,"

hasQueuedThreads
public final boolean hasQueuedThreads()
Queries whether any threads are waiting to acquire. Note that
 because cancellations due to interrupts and timeouts may occur
 at any time, a true return does not guarantee that any
 other thread will ever acquire.

 In this implementation, this operation returns in
 constant time.

Returns:
true if there may be other threads waiting to acquire


"
AbstractQueuedLongSynchronizer,hasWaiters(AbstractQueuedLongSynchronizer.ConditionObject condition),boolean,Queries whether any threads are waiting on the given condition associated with this synchronizer.,"

hasWaiters
public final boolean hasWaiters(AbstractQueuedLongSynchronizer.ConditionObject condition)
Queries whether any threads are waiting on the given condition
 associated with this synchronizer. Note that because timeouts
 and interrupts may occur at any time, a true return
 does not guarantee that a future signal will awaken
 any threads.  This method is designed primarily for use in
 monitoring of the system state.

Parameters:
condition - the condition
Returns:
true if there are any waiting threads
Throws:
IllegalMonitorStateException - if exclusive synchronization
         is not held
IllegalArgumentException - if the given condition is
         not associated with this synchronizer
NullPointerException - if the condition is null


"
AbstractQueuedLongSynchronizer,isHeldExclusively(),protected boolean,Returns true if synchronization is held exclusively with respect to the current (calling) thread.,"

isHeldExclusively
protected boolean isHeldExclusively()
Returns true if synchronization is held exclusively with
 respect to the current (calling) thread.  This method is invoked
 upon each call to a non-waiting AbstractQueuedLongSynchronizer.ConditionObject method.
 (Waiting methods instead invoke release(long).)

 The default implementation throws UnsupportedOperationException. This method is invoked
 internally only within AbstractQueuedLongSynchronizer.ConditionObject methods, so need
 not be defined if conditions are not used.

Returns:
true if synchronization is held exclusively;
         false otherwise
Throws:
UnsupportedOperationException - if conditions are not supported


"
AbstractQueuedLongSynchronizer,isQueued(Thread thread),boolean,Returns true if the given thread is currently queued.,"

isQueued
public final boolean isQueued(Thread thread)
Returns true if the given thread is currently queued.

 This implementation traverses the queue to determine
 presence of the given thread.

Parameters:
thread - the thread
Returns:
true if the given thread is on the queue
Throws:
NullPointerException - if the thread is null


"
AbstractQueuedLongSynchronizer,owns(AbstractQueuedLongSynchronizer.ConditionObject condition),boolean,Queries whether the given ConditionObject uses this synchronizer as its lock.,"

owns
public final boolean owns(AbstractQueuedLongSynchronizer.ConditionObject condition)
Queries whether the given ConditionObject
 uses this synchronizer as its lock.

Parameters:
condition - the condition
Returns:
true if owned
Throws:
NullPointerException - if the condition is null


"
AbstractQueuedLongSynchronizer,release(long arg),boolean,Releases in exclusive mode.,"

release
public final boolean release(long arg)
Releases in exclusive mode.  Implemented by unblocking one or
 more threads if tryRelease(long) returns true.
 This method can be used to implement method Lock.unlock().

Parameters:
arg - the release argument.  This value is conveyed to
        tryRelease(long) but is otherwise uninterpreted and
        can represent anything you like.
Returns:
the value returned from tryRelease(long)


"
AbstractQueuedLongSynchronizer,releaseShared(long arg),boolean,Releases in shared mode.,"

releaseShared
public final boolean releaseShared(long arg)
Releases in shared mode.  Implemented by unblocking one or more
 threads if tryReleaseShared(long) returns true.

Parameters:
arg - the release argument.  This value is conveyed to
        tryReleaseShared(long) but is otherwise uninterpreted
        and can represent anything you like.
Returns:
the value returned from tryReleaseShared(long)


"
AbstractQueuedLongSynchronizer,setState(long newState),protected void,Sets the value of synchronization state.,"

setState
protected final void setState(long newState)
Sets the value of synchronization state.
 This operation has memory semantics of a volatile write.

Parameters:
newState - the new state value


"
AbstractQueuedLongSynchronizer,toString(),String,"Returns a string identifying this synchronizer, as well as its state.","

toString
public String toString()
Returns a string identifying this synchronizer, as well as its state.
 The state, in brackets, includes the String ""State =""
 followed by the current value of getState(), and either
 ""nonempty"" or ""empty"" depending on whether the
 queue is empty.

Overrides:
toString in class Object
Returns:
a string identifying this synchronizer, as well as its state


"
AbstractQueuedLongSynchronizer,tryAcquire(long arg),protected boolean,Attempts to acquire in exclusive mode.,"

tryAcquire
protected boolean tryAcquire(long arg)
Attempts to acquire in exclusive mode. This method should query
 if the state of the object permits it to be acquired in the
 exclusive mode, and if so to acquire it.

 This method is always invoked by the thread performing
 acquire.  If this method reports failure, the acquire method
 may queue the thread, if it is not already queued, until it is
 signalled by a release from some other thread. This can be used
 to implement method Lock.tryLock().

 The default
 implementation throws UnsupportedOperationException.

Parameters:
arg - the acquire argument. This value is always the one
        passed to an acquire method, or is the value saved on entry
        to a condition wait.  The value is otherwise uninterpreted
        and can represent anything you like.
Returns:
true if successful. Upon success, this object has
         been acquired.
Throws:
IllegalMonitorStateException - if acquiring would place this
         synchronizer in an illegal state. This exception must be
         thrown in a consistent fashion for synchronization to work
         correctly.
UnsupportedOperationException - if exclusive mode is not supported


"
AbstractQueuedLongSynchronizer,"tryAcquireNanos(long arg, long nanosTimeout)",boolean,"Attempts to acquire in exclusive mode, aborting if interrupted, and failing if the given timeout elapses.","

tryAcquireNanos
public final boolean tryAcquireNanos(long arg,
                                     long nanosTimeout)
                              throws InterruptedException
Attempts to acquire in exclusive mode, aborting if interrupted,
 and failing if the given timeout elapses.  Implemented by first
 checking interrupt status, then invoking at least once tryAcquire(long), returning on success.  Otherwise, the thread is
 queued, possibly repeatedly blocking and unblocking, invoking
 tryAcquire(long) until success or the thread is interrupted
 or the timeout elapses.  This method can be used to implement
 method Lock.tryLock(long, TimeUnit).

Parameters:
arg - the acquire argument.  This value is conveyed to
        tryAcquire(long) but is otherwise uninterpreted and
        can represent anything you like.
nanosTimeout - the maximum number of nanoseconds to wait
Returns:
true if acquired; false if timed out
Throws:
InterruptedException - if the current thread is interrupted


"
AbstractQueuedLongSynchronizer,tryAcquireShared(long arg),protected long,Attempts to acquire in shared mode.,"

tryAcquireShared
protected long tryAcquireShared(long arg)
Attempts to acquire in shared mode. This method should query if
 the state of the object permits it to be acquired in the shared
 mode, and if so to acquire it.

 This method is always invoked by the thread performing
 acquire.  If this method reports failure, the acquire method
 may queue the thread, if it is not already queued, until it is
 signalled by a release from some other thread.

 The default implementation throws UnsupportedOperationException.

Parameters:
arg - the acquire argument. This value is always the one
        passed to an acquire method, or is the value saved on entry
        to a condition wait.  The value is otherwise uninterpreted
        and can represent anything you like.
Returns:
a negative value on failure; zero if acquisition in shared
         mode succeeded but no subsequent shared-mode acquire can
         succeed; and a positive value if acquisition in shared
         mode succeeded and subsequent shared-mode acquires might
         also succeed, in which case a subsequent waiting thread
         must check availability. (Support for three different
         return values enables this method to be used in contexts
         where acquires only sometimes act exclusively.)  Upon
         success, this object has been acquired.
Throws:
IllegalMonitorStateException - if acquiring would place this
         synchronizer in an illegal state. This exception must be
         thrown in a consistent fashion for synchronization to work
         correctly.
UnsupportedOperationException - if shared mode is not supported


"
AbstractQueuedLongSynchronizer,"tryAcquireSharedNanos(long arg, long nanosTimeout)",boolean,"Attempts to acquire in shared mode, aborting if interrupted, and failing if the given timeout elapses.","

tryAcquireSharedNanos
public final boolean tryAcquireSharedNanos(long arg,
                                           long nanosTimeout)
                                    throws InterruptedException
Attempts to acquire in shared mode, aborting if interrupted, and
 failing if the given timeout elapses.  Implemented by first
 checking interrupt status, then invoking at least once tryAcquireShared(long), returning on success.  Otherwise, the
 thread is queued, possibly repeatedly blocking and unblocking,
 invoking tryAcquireShared(long) until success or the thread
 is interrupted or the timeout elapses.

Parameters:
arg - the acquire argument.  This value is conveyed to
        tryAcquireShared(long) but is otherwise uninterpreted
        and can represent anything you like.
nanosTimeout - the maximum number of nanoseconds to wait
Returns:
true if acquired; false if timed out
Throws:
InterruptedException - if the current thread is interrupted


"
AbstractQueuedLongSynchronizer,tryRelease(long arg),protected boolean,Attempts to set the state to reflect a release in exclusive mode.,"

tryRelease
protected boolean tryRelease(long arg)
Attempts to set the state to reflect a release in exclusive
 mode.

 This method is always invoked by the thread performing release.

 The default implementation throws
 UnsupportedOperationException.

Parameters:
arg - the release argument. This value is always the one
        passed to a release method, or the current state value upon
        entry to a condition wait.  The value is otherwise
        uninterpreted and can represent anything you like.
Returns:
true if this object is now in a fully released
         state, so that any waiting threads may attempt to acquire;
         and false otherwise.
Throws:
IllegalMonitorStateException - if releasing would place this
         synchronizer in an illegal state. This exception must be
         thrown in a consistent fashion for synchronization to work
         correctly.
UnsupportedOperationException - if exclusive mode is not supported


"
AbstractQueuedLongSynchronizer,tryReleaseShared(long arg),protected boolean,Attempts to set the state to reflect a release in shared mode.,"

tryReleaseShared
protected boolean tryReleaseShared(long arg)
Attempts to set the state to reflect a release in shared mode.

 This method is always invoked by the thread performing release.

 The default implementation throws
 UnsupportedOperationException.

Parameters:
arg - the release argument. This value is always the one
        passed to a release method, or the current state value upon
        entry to a condition wait.  The value is otherwise
        uninterpreted and can represent anything you like.
Returns:
true if this release of shared mode may permit a
         waiting acquire (shared or exclusive) to succeed; and
         false otherwise
Throws:
IllegalMonitorStateException - if releasing would place this
         synchronizer in an illegal state. This exception must be
         thrown in a consistent fashion for synchronization to work
         correctly.
UnsupportedOperationException - if shared mode is not supported


"
AbstractQueuedSynchronizer,acquire(int arg),void,"Acquires in exclusive mode, ignoring interrupts.","

acquire
public final void acquire(int arg)
Acquires in exclusive mode, ignoring interrupts.  Implemented
 by invoking at least once tryAcquire(int),
 returning on success.  Otherwise the thread is queued, possibly
 repeatedly blocking and unblocking, invoking tryAcquire(int) until success.  This method can be used
 to implement method Lock.lock().

Parameters:
arg - the acquire argument.  This value is conveyed to
        tryAcquire(int) but is otherwise uninterpreted and
        can represent anything you like.


"
AbstractQueuedSynchronizer,acquireInterruptibly(int arg),void,"Acquires in exclusive mode, aborting if interrupted.","

acquireInterruptibly
public final void acquireInterruptibly(int arg)
                                throws InterruptedException
Acquires in exclusive mode, aborting if interrupted.
 Implemented by first checking interrupt status, then invoking
 at least once tryAcquire(int), returning on
 success.  Otherwise the thread is queued, possibly repeatedly
 blocking and unblocking, invoking tryAcquire(int)
 until success or the thread is interrupted.  This method can be
 used to implement method Lock.lockInterruptibly().

Parameters:
arg - the acquire argument.  This value is conveyed to
        tryAcquire(int) but is otherwise uninterpreted and
        can represent anything you like.
Throws:
InterruptedException - if the current thread is interrupted


"
AbstractQueuedSynchronizer,acquireShared(int arg),void,"Acquires in shared mode, ignoring interrupts.","

acquireShared
public final void acquireShared(int arg)
Acquires in shared mode, ignoring interrupts.  Implemented by
 first invoking at least once tryAcquireShared(int),
 returning on success.  Otherwise the thread is queued, possibly
 repeatedly blocking and unblocking, invoking tryAcquireShared(int) until success.

Parameters:
arg - the acquire argument.  This value is conveyed to
        tryAcquireShared(int) but is otherwise uninterpreted
        and can represent anything you like.


"
AbstractQueuedSynchronizer,acquireSharedInterruptibly(int arg),void,"Acquires in shared mode, aborting if interrupted.","

acquireSharedInterruptibly
public final void acquireSharedInterruptibly(int arg)
                                      throws InterruptedException
Acquires in shared mode, aborting if interrupted.  Implemented
 by first checking interrupt status, then invoking at least once
 tryAcquireShared(int), returning on success.  Otherwise the
 thread is queued, possibly repeatedly blocking and unblocking,
 invoking tryAcquireShared(int) until success or the thread
 is interrupted.

Parameters:
arg - the acquire argument.
 This value is conveyed to tryAcquireShared(int) but is
 otherwise uninterpreted and can represent anything
 you like.
Throws:
InterruptedException - if the current thread is interrupted


"
AbstractQueuedSynchronizer,"compareAndSetState(int expect, int update)",protected boolean,Atomically sets synchronization state to the given updated value if the current state value equals the expected value.,"

compareAndSetState
protected final boolean compareAndSetState(int expect,
                                           int update)
Atomically sets synchronization state to the given updated
 value if the current state value equals the expected value.
 This operation has memory semantics of a volatile read
 and write.

Parameters:
expect - the expected value
update - the new value
Returns:
true if successful. False return indicates that the actual
         value was not equal to the expected value.


"
AbstractQueuedSynchronizer,getExclusiveQueuedThreads(),Collection<Thread>,Returns a collection containing threads that may be waiting to acquire in exclusive mode.,"

getExclusiveQueuedThreads
public final Collection<Thread> getExclusiveQueuedThreads()
Returns a collection containing threads that may be waiting to
 acquire in exclusive mode. This has the same properties
 as getQueuedThreads() except that it only returns
 those threads waiting due to an exclusive acquire.

Returns:
the collection of threads


"
AbstractQueuedSynchronizer,getFirstQueuedThread(),Thread,"Returns the first (longest-waiting) thread in the queue, or null if no threads are currently queued.","

getFirstQueuedThread
public final Thread getFirstQueuedThread()
Returns the first (longest-waiting) thread in the queue, or
 null if no threads are currently queued.

 In this implementation, this operation normally returns in
 constant time, but may iterate upon contention if other threads are
 concurrently modifying the queue.

Returns:
the first (longest-waiting) thread in the queue, or
         null if no threads are currently queued


"
AbstractQueuedSynchronizer,getQueuedThreads(),Collection<Thread>,Returns a collection containing threads that may be waiting to acquire.,"

getQueuedThreads
public final Collection<Thread> getQueuedThreads()
Returns a collection containing threads that may be waiting to
 acquire.  Because the actual set of threads may change
 dynamically while constructing this result, the returned
 collection is only a best-effort estimate.  The elements of the
 returned collection are in no particular order.  This method is
 designed to facilitate construction of subclasses that provide
 more extensive monitoring facilities.

Returns:
the collection of threads


"
AbstractQueuedSynchronizer,getQueueLength(),int,Returns an estimate of the number of threads waiting to acquire.,"

getQueueLength
public final int getQueueLength()
Returns an estimate of the number of threads waiting to
 acquire.  The value is only an estimate because the number of
 threads may change dynamically while this method traverses
 internal data structures.  This method is designed for use in
 monitoring system state, not for synchronization
 control.

Returns:
the estimated number of threads waiting to acquire


"
AbstractQueuedSynchronizer,getSharedQueuedThreads(),Collection<Thread>,Returns a collection containing threads that may be waiting to acquire in shared mode.,"

getSharedQueuedThreads
public final Collection<Thread> getSharedQueuedThreads()
Returns a collection containing threads that may be waiting to
 acquire in shared mode. This has the same properties
 as getQueuedThreads() except that it only returns
 those threads waiting due to a shared acquire.

Returns:
the collection of threads


"
AbstractQueuedSynchronizer,getState(),protected int,Returns the current value of synchronization state.,"

getState
protected final int getState()
Returns the current value of synchronization state.
 This operation has memory semantics of a volatile read.

Returns:
current state value


"
AbstractQueuedSynchronizer,getWaitingThreads(AbstractQueuedSynchronizer.ConditionObject condition),Collection<Thread>,Returns a collection containing those threads that may be waiting on the given condition associated with this synchronizer.,"

getWaitingThreads
public final Collection<Thread> getWaitingThreads(AbstractQueuedSynchronizer.ConditionObject condition)
Returns a collection containing those threads that may be
 waiting on the given condition associated with this
 synchronizer.  Because the actual set of threads may change
 dynamically while constructing this result, the returned
 collection is only a best-effort estimate. The elements of the
 returned collection are in no particular order.

Parameters:
condition - the condition
Returns:
the collection of threads
Throws:
IllegalMonitorStateException - if exclusive synchronization
         is not held
IllegalArgumentException - if the given condition is
         not associated with this synchronizer
NullPointerException - if the condition is null


"
AbstractQueuedSynchronizer,getWaitQueueLength(AbstractQueuedSynchronizer.ConditionObject condition),int,Returns an estimate of the number of threads waiting on the given condition associated with this synchronizer.,"

getWaitQueueLength
public final int getWaitQueueLength(AbstractQueuedSynchronizer.ConditionObject condition)
Returns an estimate of the number of threads waiting on the
 given condition associated with this synchronizer. Note that
 because timeouts and interrupts may occur at any time, the
 estimate serves only as an upper bound on the actual number of
 waiters.  This method is designed for use in monitoring of the
 system state, not for synchronization control.

Parameters:
condition - the condition
Returns:
the estimated number of waiting threads
Throws:
IllegalMonitorStateException - if exclusive synchronization
         is not held
IllegalArgumentException - if the given condition is
         not associated with this synchronizer
NullPointerException - if the condition is null


"
AbstractQueuedSynchronizer,hasContended(),boolean,Queries whether any threads have ever contended to acquire this synchronizer; that is if an acquire method has ever blocked.,"

hasContended
public final boolean hasContended()
Queries whether any threads have ever contended to acquire this
 synchronizer; that is if an acquire method has ever blocked.

 In this implementation, this operation returns in
 constant time.

Returns:
true if there has ever been contention


"
AbstractQueuedSynchronizer,hasQueuedPredecessors(),boolean,Queries whether any threads have been waiting to acquire longer than the current thread.,"

hasQueuedPredecessors
public final boolean hasQueuedPredecessors()
Queries whether any threads have been waiting to acquire longer
 than the current thread.

 An invocation of this method is equivalent to (but may be
 more efficient than):
   
 getFirstQueuedThread() != Thread.currentThread() &&
 hasQueuedThreads()
Note that because cancellations due to interrupts and
 timeouts may occur at any time, a true return does not
 guarantee that some other thread will acquire before the current
 thread.  Likewise, it is possible for another thread to win a
 race to enqueue after this method has returned false,
 due to the queue being empty.

 This method is designed to be used by a fair synchronizer to
 avoid barging.
 Such a synchronizer's tryAcquire(int) method should return
 false, and its tryAcquireShared(int) method should
 return a negative value, if this method returns true
 (unless this is a reentrant acquire).  For example, the tryAcquire method for a fair, reentrant, exclusive mode
 synchronizer might look like this:

   
 protected boolean tryAcquire(int arg) {
   if (isHeldExclusively()) {
     // A reentrant acquire; increment hold count
     return true;
   } else if (hasQueuedPredecessors()) {
     return false;
   } else {
     // try to acquire normally
   }
 }

Returns:
true if there is a queued thread preceding the
         current thread, and false if the current thread
         is at the head of the queue or the queue is empty
Since:
1.7


"
AbstractQueuedSynchronizer,hasQueuedThreads(),boolean,Queries whether any threads are waiting to acquire.,"

hasQueuedThreads
public final boolean hasQueuedThreads()
Queries whether any threads are waiting to acquire. Note that
 because cancellations due to interrupts and timeouts may occur
 at any time, a true return does not guarantee that any
 other thread will ever acquire.

 In this implementation, this operation returns in
 constant time.

Returns:
true if there may be other threads waiting to acquire


"
AbstractQueuedSynchronizer,hasWaiters(AbstractQueuedSynchronizer.ConditionObject condition),boolean,Queries whether any threads are waiting on the given condition associated with this synchronizer.,"

hasWaiters
public final boolean hasWaiters(AbstractQueuedSynchronizer.ConditionObject condition)
Queries whether any threads are waiting on the given condition
 associated with this synchronizer. Note that because timeouts
 and interrupts may occur at any time, a true return
 does not guarantee that a future signal will awaken
 any threads.  This method is designed primarily for use in
 monitoring of the system state.

Parameters:
condition - the condition
Returns:
true if there are any waiting threads
Throws:
IllegalMonitorStateException - if exclusive synchronization
         is not held
IllegalArgumentException - if the given condition is
         not associated with this synchronizer
NullPointerException - if the condition is null


"
AbstractQueuedSynchronizer,isHeldExclusively(),protected boolean,Returns true if synchronization is held exclusively with respect to the current (calling) thread.,"

isHeldExclusively
protected boolean isHeldExclusively()
Returns true if synchronization is held exclusively with
 respect to the current (calling) thread.  This method is invoked
 upon each call to a non-waiting AbstractQueuedSynchronizer.ConditionObject method.
 (Waiting methods instead invoke release(int).)

 The default implementation throws UnsupportedOperationException. This method is invoked
 internally only within AbstractQueuedSynchronizer.ConditionObject methods, so need
 not be defined if conditions are not used.

Returns:
true if synchronization is held exclusively;
         false otherwise
Throws:
UnsupportedOperationException - if conditions are not supported


"
AbstractQueuedSynchronizer,isQueued(Thread thread),boolean,Returns true if the given thread is currently queued.,"

isQueued
public final boolean isQueued(Thread thread)
Returns true if the given thread is currently queued.

 This implementation traverses the queue to determine
 presence of the given thread.

Parameters:
thread - the thread
Returns:
true if the given thread is on the queue
Throws:
NullPointerException - if the thread is null


"
AbstractQueuedSynchronizer,owns(AbstractQueuedSynchronizer.ConditionObject condition),boolean,Queries whether the given ConditionObject uses this synchronizer as its lock.,"

owns
public final boolean owns(AbstractQueuedSynchronizer.ConditionObject condition)
Queries whether the given ConditionObject
 uses this synchronizer as its lock.

Parameters:
condition - the condition
Returns:
true if owned
Throws:
NullPointerException - if the condition is null


"
AbstractQueuedSynchronizer,release(int arg),boolean,Releases in exclusive mode.,"

release
public final boolean release(int arg)
Releases in exclusive mode.  Implemented by unblocking one or
 more threads if tryRelease(int) returns true.
 This method can be used to implement method Lock.unlock().

Parameters:
arg - the release argument.  This value is conveyed to
        tryRelease(int) but is otherwise uninterpreted and
        can represent anything you like.
Returns:
the value returned from tryRelease(int)


"
AbstractQueuedSynchronizer,releaseShared(int arg),boolean,Releases in shared mode.,"

releaseShared
public final boolean releaseShared(int arg)
Releases in shared mode.  Implemented by unblocking one or more
 threads if tryReleaseShared(int) returns true.

Parameters:
arg - the release argument.  This value is conveyed to
        tryReleaseShared(int) but is otherwise uninterpreted
        and can represent anything you like.
Returns:
the value returned from tryReleaseShared(int)


"
AbstractQueuedSynchronizer,setState(int newState),protected void,Sets the value of synchronization state.,"

setState
protected final void setState(int newState)
Sets the value of synchronization state.
 This operation has memory semantics of a volatile write.

Parameters:
newState - the new state value


"
AbstractQueuedSynchronizer,toString(),String,"Returns a string identifying this synchronizer, as well as its state.","

toString
public String toString()
Returns a string identifying this synchronizer, as well as its state.
 The state, in brackets, includes the String ""State =""
 followed by the current value of getState(), and either
 ""nonempty"" or ""empty"" depending on whether the
 queue is empty.

Overrides:
toString in class Object
Returns:
a string identifying this synchronizer, as well as its state


"
AbstractQueuedSynchronizer,tryAcquire(int arg),protected boolean,Attempts to acquire in exclusive mode.,"

tryAcquire
protected boolean tryAcquire(int arg)
Attempts to acquire in exclusive mode. This method should query
 if the state of the object permits it to be acquired in the
 exclusive mode, and if so to acquire it.

 This method is always invoked by the thread performing
 acquire.  If this method reports failure, the acquire method
 may queue the thread, if it is not already queued, until it is
 signalled by a release from some other thread. This can be used
 to implement method Lock.tryLock().

 The default
 implementation throws UnsupportedOperationException.

Parameters:
arg - the acquire argument. This value is always the one
        passed to an acquire method, or is the value saved on entry
        to a condition wait.  The value is otherwise uninterpreted
        and can represent anything you like.
Returns:
true if successful. Upon success, this object has
         been acquired.
Throws:
IllegalMonitorStateException - if acquiring would place this
         synchronizer in an illegal state. This exception must be
         thrown in a consistent fashion for synchronization to work
         correctly.
UnsupportedOperationException - if exclusive mode is not supported


"
AbstractQueuedSynchronizer,"tryAcquireNanos(int arg, long nanosTimeout)",boolean,"Attempts to acquire in exclusive mode, aborting if interrupted, and failing if the given timeout elapses.","

tryAcquireNanos
public final boolean tryAcquireNanos(int arg,
                                     long nanosTimeout)
                              throws InterruptedException
Attempts to acquire in exclusive mode, aborting if interrupted,
 and failing if the given timeout elapses.  Implemented by first
 checking interrupt status, then invoking at least once tryAcquire(int), returning on success.  Otherwise, the thread is
 queued, possibly repeatedly blocking and unblocking, invoking
 tryAcquire(int) until success or the thread is interrupted
 or the timeout elapses.  This method can be used to implement
 method Lock.tryLock(long, TimeUnit).

Parameters:
arg - the acquire argument.  This value is conveyed to
        tryAcquire(int) but is otherwise uninterpreted and
        can represent anything you like.
nanosTimeout - the maximum number of nanoseconds to wait
Returns:
true if acquired; false if timed out
Throws:
InterruptedException - if the current thread is interrupted


"
AbstractQueuedSynchronizer,tryAcquireShared(int arg),protected int,Attempts to acquire in shared mode.,"

tryAcquireShared
protected int tryAcquireShared(int arg)
Attempts to acquire in shared mode. This method should query if
 the state of the object permits it to be acquired in the shared
 mode, and if so to acquire it.

 This method is always invoked by the thread performing
 acquire.  If this method reports failure, the acquire method
 may queue the thread, if it is not already queued, until it is
 signalled by a release from some other thread.

 The default implementation throws UnsupportedOperationException.

Parameters:
arg - the acquire argument. This value is always the one
        passed to an acquire method, or is the value saved on entry
        to a condition wait.  The value is otherwise uninterpreted
        and can represent anything you like.
Returns:
a negative value on failure; zero if acquisition in shared
         mode succeeded but no subsequent shared-mode acquire can
         succeed; and a positive value if acquisition in shared
         mode succeeded and subsequent shared-mode acquires might
         also succeed, in which case a subsequent waiting thread
         must check availability. (Support for three different
         return values enables this method to be used in contexts
         where acquires only sometimes act exclusively.)  Upon
         success, this object has been acquired.
Throws:
IllegalMonitorStateException - if acquiring would place this
         synchronizer in an illegal state. This exception must be
         thrown in a consistent fashion for synchronization to work
         correctly.
UnsupportedOperationException - if shared mode is not supported


"
AbstractQueuedSynchronizer,"tryAcquireSharedNanos(int arg, long nanosTimeout)",boolean,"Attempts to acquire in shared mode, aborting if interrupted, and failing if the given timeout elapses.","

tryAcquireSharedNanos
public final boolean tryAcquireSharedNanos(int arg,
                                           long nanosTimeout)
                                    throws InterruptedException
Attempts to acquire in shared mode, aborting if interrupted, and
 failing if the given timeout elapses.  Implemented by first
 checking interrupt status, then invoking at least once tryAcquireShared(int), returning on success.  Otherwise, the
 thread is queued, possibly repeatedly blocking and unblocking,
 invoking tryAcquireShared(int) until success or the thread
 is interrupted or the timeout elapses.

Parameters:
arg - the acquire argument.  This value is conveyed to
        tryAcquireShared(int) but is otherwise uninterpreted
        and can represent anything you like.
nanosTimeout - the maximum number of nanoseconds to wait
Returns:
true if acquired; false if timed out
Throws:
InterruptedException - if the current thread is interrupted


"
AbstractQueuedSynchronizer,tryRelease(int arg),protected boolean,Attempts to set the state to reflect a release in exclusive mode.,"

tryRelease
protected boolean tryRelease(int arg)
Attempts to set the state to reflect a release in exclusive
 mode.

 This method is always invoked by the thread performing release.

 The default implementation throws
 UnsupportedOperationException.

Parameters:
arg - the release argument. This value is always the one
        passed to a release method, or the current state value upon
        entry to a condition wait.  The value is otherwise
        uninterpreted and can represent anything you like.
Returns:
true if this object is now in a fully released
         state, so that any waiting threads may attempt to acquire;
         and false otherwise.
Throws:
IllegalMonitorStateException - if releasing would place this
         synchronizer in an illegal state. This exception must be
         thrown in a consistent fashion for synchronization to work
         correctly.
UnsupportedOperationException - if exclusive mode is not supported


"
AbstractQueuedSynchronizer,tryReleaseShared(int arg),protected boolean,Attempts to set the state to reflect a release in shared mode.,"

tryReleaseShared
protected boolean tryReleaseShared(int arg)
Attempts to set the state to reflect a release in shared mode.

 This method is always invoked by the thread performing release.

 The default implementation throws
 UnsupportedOperationException.

Parameters:
arg - the release argument. This value is always the one
        passed to a release method, or the current state value upon
        entry to a condition wait.  The value is otherwise
        uninterpreted and can represent anything you like.
Returns:
true if this release of shared mode may permit a
         waiting acquire (shared or exclusive) to succeed; and
         false otherwise
Throws:
IllegalMonitorStateException - if releasing would place this
         synchronizer in an illegal state. This exception must be
         thrown in a consistent fashion for synchronization to work
         correctly.
UnsupportedOperationException - if shared mode is not supported


"
LockSupport,getBlocker(Thread t),static Object,"Returns the blocker object supplied to the most recent invocation of a park method that has not yet unblocked, or null if not blocked.","

getBlocker
public static Object getBlocker(Thread t)
Returns the blocker object supplied to the most recent
 invocation of a park method that has not yet unblocked, or null
 if not blocked.  The value returned is just a momentary
 snapshot -- the thread may have since unblocked or blocked on a
 different blocker object.

Parameters:
t - the thread
Returns:
the blocker
Throws:
NullPointerException - if argument is null
Since:
1.6


"
LockSupport,park(),static void,Disables the current thread for thread scheduling purposes unless the permit is available.,"

park
public static void park()
Disables the current thread for thread scheduling purposes unless the
 permit is available.

 If the permit is available then it is consumed and the call
 returns immediately; otherwise the current thread becomes disabled
 for thread scheduling purposes and lies dormant until one of three
 things happens:

 
Some other thread invokes unpark with the
 current thread as the target; or

 Some other thread interrupts
 the current thread; or

 The call spuriously (that is, for no reason) returns.
 
This method does not report which of these caused the
 method to return. Callers should re-check the conditions which caused
 the thread to park in the first place. Callers may also determine,
 for example, the interrupt status of the thread upon return.

"
LockSupport,park(Object blocker),static void,Disables the current thread for thread scheduling purposes unless the permit is available.,"

park
public static void park(Object blocker)
Disables the current thread for thread scheduling purposes unless the
 permit is available.

 If the permit is available then it is consumed and the call returns
 immediately; otherwise
 the current thread becomes disabled for thread scheduling
 purposes and lies dormant until one of three things happens:

 
Some other thread invokes unpark with the
 current thread as the target; or

 Some other thread interrupts
 the current thread; or

 The call spuriously (that is, for no reason) returns.
 
This method does not report which of these caused the
 method to return. Callers should re-check the conditions which caused
 the thread to park in the first place. Callers may also determine,
 for example, the interrupt status of the thread upon return.

Parameters:
blocker - the synchronization object responsible for this
        thread parking
Since:
1.6


"
LockSupport,parkNanos(long nanos),static void,"Disables the current thread for thread scheduling purposes, for up to the specified waiting time, unless the permit is available.","

parkNanos
public static void parkNanos(long nanos)
Disables the current thread for thread scheduling purposes, for up to
 the specified waiting time, unless the permit is available.

 If the permit is available then it is consumed and the call
 returns immediately; otherwise the current thread becomes disabled
 for thread scheduling purposes and lies dormant until one of four
 things happens:

 
Some other thread invokes unpark with the
 current thread as the target; or

 Some other thread interrupts
 the current thread; or

 The specified waiting time elapses; or

 The call spuriously (that is, for no reason) returns.
 
This method does not report which of these caused the
 method to return. Callers should re-check the conditions which caused
 the thread to park in the first place. Callers may also determine,
 for example, the interrupt status of the thread, or the elapsed time
 upon return.

Parameters:
nanos - the maximum number of nanoseconds to wait


"
LockSupport,"parkNanos(Object blocker, long nanos)",static void,"Disables the current thread for thread scheduling purposes, for up to the specified waiting time, unless the permit is available.","

parkNanos
public static void parkNanos(Object blocker,
                             long nanos)
Disables the current thread for thread scheduling purposes, for up to
 the specified waiting time, unless the permit is available.

 If the permit is available then it is consumed and the call
 returns immediately; otherwise the current thread becomes disabled
 for thread scheduling purposes and lies dormant until one of four
 things happens:

 
Some other thread invokes unpark with the
 current thread as the target; or

 Some other thread interrupts
 the current thread; or

 The specified waiting time elapses; or

 The call spuriously (that is, for no reason) returns.
 
This method does not report which of these caused the
 method to return. Callers should re-check the conditions which caused
 the thread to park in the first place. Callers may also determine,
 for example, the interrupt status of the thread, or the elapsed time
 upon return.

Parameters:
blocker - the synchronization object responsible for this
        thread parking
nanos - the maximum number of nanoseconds to wait
Since:
1.6


"
LockSupport,parkUntil(long deadline),static void,"Disables the current thread for thread scheduling purposes, until the specified deadline, unless the permit is available.","

parkUntil
public static void parkUntil(long deadline)
Disables the current thread for thread scheduling purposes, until
 the specified deadline, unless the permit is available.

 If the permit is available then it is consumed and the call
 returns immediately; otherwise the current thread becomes disabled
 for thread scheduling purposes and lies dormant until one of four
 things happens:

 
Some other thread invokes unpark with the
 current thread as the target; or

 Some other thread interrupts
 the current thread; or

 The specified deadline passes; or

 The call spuriously (that is, for no reason) returns.
 
This method does not report which of these caused the
 method to return. Callers should re-check the conditions which caused
 the thread to park in the first place. Callers may also determine,
 for example, the interrupt status of the thread, or the current time
 upon return.

Parameters:
deadline - the absolute time, in milliseconds from the Epoch,
        to wait until


"
LockSupport,"parkUntil(Object blocker, long deadline)",static void,"Disables the current thread for thread scheduling purposes, until the specified deadline, unless the permit is available.","

parkUntil
public static void parkUntil(Object blocker,
                             long deadline)
Disables the current thread for thread scheduling purposes, until
 the specified deadline, unless the permit is available.

 If the permit is available then it is consumed and the call
 returns immediately; otherwise the current thread becomes disabled
 for thread scheduling purposes and lies dormant until one of four
 things happens:

 
Some other thread invokes unpark with the
 current thread as the target; or

 Some other thread interrupts the
 current thread; or

 The specified deadline passes; or

 The call spuriously (that is, for no reason) returns.
 
This method does not report which of these caused the
 method to return. Callers should re-check the conditions which caused
 the thread to park in the first place. Callers may also determine,
 for example, the interrupt status of the thread, or the current time
 upon return.

Parameters:
blocker - the synchronization object responsible for this
        thread parking
deadline - the absolute time, in milliseconds from the Epoch,
        to wait until
Since:
1.6


"
LockSupport,unpark(Thread thread),static void,"Makes available the permit for the given thread, if it was not already available.","

unpark
public static void unpark(Thread thread)
Makes available the permit for the given thread, if it
 was not already available.  If the thread was blocked on
 park then it will unblock.  Otherwise, its next call
 to park is guaranteed not to block. This operation
 is not guaranteed to have any effect at all if the given
 thread has not been started.

Parameters:
thread - the thread to unpark, or null, in which case
        this operation has no effect


"
ReentrantLock,getHoldCount(),int,Queries the number of holds on this lock by the current thread.,"

getHoldCount
public int getHoldCount()
Queries the number of holds on this lock by the current thread.

 A thread has a hold on a lock for each lock action that is not
 matched by an unlock action.

 The hold count information is typically only used for testing and
 debugging purposes. For example, if a certain section of code should
 not be entered with the lock already held then we can assert that
 fact:

   
 class X {
   ReentrantLock lock = new ReentrantLock();
   // ...
   public void m() {
     assert lock.getHoldCount() == 0;
     lock.lock();
     try {
       // ... method body
     } finally {
       lock.unlock();
     }
   }
 }

Returns:
the number of holds on this lock by the current thread,
         or zero if this lock is not held by the current thread


"
ReentrantLock,getOwner(),protected Thread,"Returns the thread that currently owns this lock, or null if not owned.","

getOwner
protected Thread getOwner()
Returns the thread that currently owns this lock, or
 null if not owned. When this method is called by a
 thread that is not the owner, the return value reflects a
 best-effort approximation of current lock status. For example,
 the owner may be momentarily null even if there are
 threads trying to acquire the lock but have not yet done so.
 This method is designed to facilitate construction of
 subclasses that provide more extensive lock monitoring
 facilities.

Returns:
the owner, or null if not owned


"
ReentrantLock,getQueuedThreads(),protected Collection<Thread>,Returns a collection containing threads that may be waiting to acquire this lock.,"

getQueuedThreads
protected Collection<Thread> getQueuedThreads()
Returns a collection containing threads that may be waiting to
 acquire this lock.  Because the actual set of threads may change
 dynamically while constructing this result, the returned
 collection is only a best-effort estimate.  The elements of the
 returned collection are in no particular order.  This method is
 designed to facilitate construction of subclasses that provide
 more extensive monitoring facilities.

Returns:
the collection of threads


"
ReentrantLock,getQueueLength(),int,Returns an estimate of the number of threads waiting to acquire this lock.,"

getQueueLength
public final int getQueueLength()
Returns an estimate of the number of threads waiting to
 acquire this lock.  The value is only an estimate because the number of
 threads may change dynamically while this method traverses
 internal data structures.  This method is designed for use in
 monitoring of the system state, not for synchronization
 control.

Returns:
the estimated number of threads waiting for this lock


"
ReentrantLock,getWaitingThreads(Condition condition),protected Collection<Thread>,Returns a collection containing those threads that may be waiting on the given condition associated with this lock.,"

getWaitingThreads
protected Collection<Thread> getWaitingThreads(Condition condition)
Returns a collection containing those threads that may be
 waiting on the given condition associated with this lock.
 Because the actual set of threads may change dynamically while
 constructing this result, the returned collection is only a
 best-effort estimate. The elements of the returned collection
 are in no particular order.  This method is designed to
 facilitate construction of subclasses that provide more
 extensive condition monitoring facilities.

Parameters:
condition - the condition
Returns:
the collection of threads
Throws:
IllegalMonitorStateException - if this lock is not held
IllegalArgumentException - if the given condition is
         not associated with this lock
NullPointerException - if the condition is null


"
ReentrantLock,getWaitQueueLength(Condition condition),int,Returns an estimate of the number of threads waiting on the given condition associated with this lock.,"

getWaitQueueLength
public int getWaitQueueLength(Condition condition)
Returns an estimate of the number of threads waiting on the
 given condition associated with this lock. Note that because
 timeouts and interrupts may occur at any time, the estimate
 serves only as an upper bound on the actual number of waiters.
 This method is designed for use in monitoring of the system
 state, not for synchronization control.

Parameters:
condition - the condition
Returns:
the estimated number of waiting threads
Throws:
IllegalMonitorStateException - if this lock is not held
IllegalArgumentException - if the given condition is
         not associated with this lock
NullPointerException - if the condition is null


"
ReentrantLock,hasQueuedThread(Thread thread),boolean,Queries whether the given thread is waiting to acquire this lock.,"

hasQueuedThread
public final boolean hasQueuedThread(Thread thread)
Queries whether the given thread is waiting to acquire this
 lock. Note that because cancellations may occur at any time, a
 true return does not guarantee that this thread
 will ever acquire this lock.  This method is designed primarily for use
 in monitoring of the system state.

Parameters:
thread - the thread
Returns:
true if the given thread is queued waiting for this lock
Throws:
NullPointerException - if the thread is null


"
ReentrantLock,hasQueuedThreads(),boolean,Queries whether any threads are waiting to acquire this lock.,"

hasQueuedThreads
public final boolean hasQueuedThreads()
Queries whether any threads are waiting to acquire this lock. Note that
 because cancellations may occur at any time, a true
 return does not guarantee that any other thread will ever
 acquire this lock.  This method is designed primarily for use in
 monitoring of the system state.

Returns:
true if there may be other threads waiting to
         acquire the lock


"
ReentrantLock,hasWaiters(Condition condition),boolean,Queries whether any threads are waiting on the given condition associated with this lock.,"

hasWaiters
public boolean hasWaiters(Condition condition)
Queries whether any threads are waiting on the given condition
 associated with this lock. Note that because timeouts and
 interrupts may occur at any time, a true return does
 not guarantee that a future signal will awaken any
 threads.  This method is designed primarily for use in
 monitoring of the system state.

Parameters:
condition - the condition
Returns:
true if there are any waiting threads
Throws:
IllegalMonitorStateException - if this lock is not held
IllegalArgumentException - if the given condition is
         not associated with this lock
NullPointerException - if the condition is null


"
ReentrantLock,isFair(),boolean,Returns true if this lock has fairness set true.,"

isFair
public final boolean isFair()
Returns true if this lock has fairness set true.

Returns:
true if this lock has fairness set true


"
ReentrantLock,isHeldByCurrentThread(),boolean,Queries if this lock is held by the current thread.,"

isHeldByCurrentThread
public boolean isHeldByCurrentThread()
Queries if this lock is held by the current thread.

 Analogous to the Thread.holdsLock(Object) method for
 built-in monitor locks, this method is typically used for
 debugging and testing. For example, a method that should only be
 called while a lock is held can assert that this is the case:

   
 class X {
   ReentrantLock lock = new ReentrantLock();
   // ...

   public void m() {
       assert lock.isHeldByCurrentThread();
       // ... method body
   }
 }
It can also be used to ensure that a reentrant lock is used
 in a non-reentrant manner, for example:

   
 class X {
   ReentrantLock lock = new ReentrantLock();
   // ...

   public void m() {
       assert !lock.isHeldByCurrentThread();
       lock.lock();
       try {
           // ... method body
       } finally {
           lock.unlock();
       }
   }
 }

Returns:
true if current thread holds this lock and
         false otherwise


"
ReentrantLock,isLocked(),boolean,Queries if this lock is held by any thread.,"

isLocked
public boolean isLocked()
Queries if this lock is held by any thread. This method is
 designed for use in monitoring of the system state,
 not for synchronization control.

Returns:
true if any thread holds this lock and
         false otherwise


"
ReentrantLock,lock(),void,Acquires the lock.,"

lock
public void lock()
Acquires the lock.

 Acquires the lock if it is not held by another thread and returns
 immediately, setting the lock hold count to one.

 If the current thread already holds the lock then the hold
 count is incremented by one and the method returns immediately.

 If the lock is held by another thread then the
 current thread becomes disabled for thread scheduling
 purposes and lies dormant until the lock has been acquired,
 at which time the lock hold count is set to one.

Specified by:
lock in interface Lock


"
ReentrantLock,lockInterruptibly(),void,Acquires the lock unless the current thread is interrupted.,"

lockInterruptibly
public void lockInterruptibly()
                       throws InterruptedException
Acquires the lock unless the current thread is
 interrupted.

 Acquires the lock if it is not held by another thread and returns
 immediately, setting the lock hold count to one.

 If the current thread already holds this lock then the hold count
 is incremented by one and the method returns immediately.

 If the lock is held by another thread then the
 current thread becomes disabled for thread scheduling
 purposes and lies dormant until one of two things happens:

 
The lock is acquired by the current thread; or

 Some other thread interrupts the
 current thread.

 
If the lock is acquired by the current thread then the lock hold
 count is set to one.

 If the current thread:

 
has its interrupted status set on entry to this method; or

 is interrupted while acquiring
 the lock,

 

 then InterruptedException is thrown and the current thread's
 interrupted status is cleared.

 In this implementation, as this method is an explicit
 interruption point, preference is given to responding to the
 interrupt over normal or reentrant acquisition of the lock.

Specified by:
lockInterruptibly in interface Lock
Throws:
InterruptedException - if the current thread is interrupted


"
ReentrantLock,newCondition(),Condition,Returns a Condition instance for use with this Lock instance.,"

newCondition
public Condition newCondition()
Returns a Condition instance for use with this
 Lock instance.

 The returned Condition instance supports the same
 usages as do the Object monitor methods (wait, notify, and notifyAll) when used with the built-in
 monitor lock.

 
If this lock is not held when any of the Condition
waiting or signalling methods are called, then an IllegalMonitorStateException is thrown.

 When the condition waiting
 methods are called the lock is released and, before they
 return, the lock is reacquired and the lock hold count restored
 to what it was when the method was called.

 If a thread is interrupted
 while waiting then the wait will terminate, an InterruptedException will be thrown, and the thread's
 interrupted status will be cleared.

  Waiting threads are signalled in FIFO order.

 The ordering of lock reacquisition for threads returning
 from waiting methods is the same as for threads initially
 acquiring the lock, which is in the default case not specified,
 but for fair locks favors those threads that have been
 waiting the longest.

 

Specified by:
newCondition in interface Lock
Returns:
the Condition object


"
ReentrantLock,toString(),String,"Returns a string identifying this lock, as well as its lock state.","

toString
public String toString()
Returns a string identifying this lock, as well as its lock state.
 The state, in brackets, includes either the String ""Unlocked""
 or the String ""Locked by"" followed by the
 name of the owning thread.

Overrides:
toString in class Object
Returns:
a string identifying this lock, as well as its lock state


"
ReentrantLock,tryLock(),boolean,Acquires the lock only if it is not held by another thread at the time of invocation.,"

tryLock
public boolean tryLock()
Acquires the lock only if it is not held by another thread at the time
 of invocation.

 Acquires the lock if it is not held by another thread and
 returns immediately with the value true, setting the
 lock hold count to one. Even when this lock has been set to use a
 fair ordering policy, a call to tryLock() will
 immediately acquire the lock if it is available, whether or not
 other threads are currently waiting for the lock.
 This ""barging"" behavior can be useful in certain
 circumstances, even though it breaks fairness. If you want to honor
 the fairness setting for this lock, then use
 tryLock(0, TimeUnit.SECONDS) 
 which is almost equivalent (it also detects interruption).

 If the current thread already holds this lock then the hold
 count is incremented by one and the method returns true.

 If the lock is held by another thread then this method will return
 immediately with the value false.

Specified by:
tryLock in interface Lock
Returns:
true if the lock was free and was acquired by the
         current thread, or the lock was already held by the current
         thread; and false otherwise


"
ReentrantLock,"tryLock(long timeout, TimeUnit unit)",boolean,Acquires the lock if it is not held by another thread within the given waiting time and the current thread has not been interrupted.,"

tryLock
public boolean tryLock(long timeout,
                       TimeUnit unit)
                throws InterruptedException
Acquires the lock if it is not held by another thread within the given
 waiting time and the current thread has not been
 interrupted.

 Acquires the lock if it is not held by another thread and returns
 immediately with the value true, setting the lock hold count
 to one. If this lock has been set to use a fair ordering policy then
 an available lock will not be acquired if any other threads
 are waiting for the lock. This is in contrast to the tryLock()
 method. If you want a timed tryLock that does permit barging on
 a fair lock then combine the timed and un-timed forms together:

   
 if (lock.tryLock() ||
     lock.tryLock(timeout, unit)) {
   ...
 }
If the current thread
 already holds this lock then the hold count is incremented by one and
 the method returns true.

 If the lock is held by another thread then the
 current thread becomes disabled for thread scheduling
 purposes and lies dormant until one of three things happens:

 
The lock is acquired by the current thread; or

 Some other thread interrupts
 the current thread; or

 The specified waiting time elapses

 
If the lock is acquired then the value true is returned and
 the lock hold count is set to one.

 If the current thread:

 
has its interrupted status set on entry to this method; or

 is interrupted while
 acquiring the lock,

 
 then InterruptedException is thrown and the current thread's
 interrupted status is cleared.

 If the specified waiting time elapses then the value false
 is returned.  If the time is less than or equal to zero, the method
 will not wait at all.

 In this implementation, as this method is an explicit
 interruption point, preference is given to responding to the
 interrupt over normal or reentrant acquisition of the lock, and
 over reporting the elapse of the waiting time.

Specified by:
tryLock in interface Lock
Parameters:
timeout - the time to wait for the lock
unit - the time unit of the timeout argument
Returns:
true if the lock was free and was acquired by the
         current thread, or the lock was already held by the current
         thread; and false if the waiting time elapsed before
         the lock could be acquired
Throws:
InterruptedException - if the current thread is interrupted
NullPointerException - if the time unit is null


"
ReentrantLock,unlock(),void,Attempts to release this lock.,"

unlock
public void unlock()
Attempts to release this lock.

 If the current thread is the holder of this lock then the hold
 count is decremented.  If the hold count is now zero then the lock
 is released.  If the current thread is not the holder of this
 lock then IllegalMonitorStateException is thrown.

Specified by:
unlock in interface Lock
Throws:
IllegalMonitorStateException - if the current thread does not
         hold this lock


"
ReentrantReadWriteLock,getOwner(),protected Thread,"Returns the thread that currently owns the write lock, or null if not owned.","

getOwner
protected Thread getOwner()
Returns the thread that currently owns the write lock, or
 null if not owned. When this method is called by a
 thread that is not the owner, the return value reflects a
 best-effort approximation of current lock status. For example,
 the owner may be momentarily null even if there are
 threads trying to acquire the lock but have not yet done so.
 This method is designed to facilitate construction of
 subclasses that provide more extensive lock monitoring
 facilities.

Returns:
the owner, or null if not owned


"
ReentrantReadWriteLock,getQueuedReaderThreads(),protected Collection<Thread>,Returns a collection containing threads that may be waiting to acquire the read lock.,"

getQueuedReaderThreads
protected Collection<Thread> getQueuedReaderThreads()
Returns a collection containing threads that may be waiting to
 acquire the read lock.  Because the actual set of threads may
 change dynamically while constructing this result, the returned
 collection is only a best-effort estimate.  The elements of the
 returned collection are in no particular order.  This method is
 designed to facilitate construction of subclasses that provide
 more extensive lock monitoring facilities.

Returns:
the collection of threads


"
ReentrantReadWriteLock,getQueuedThreads(),protected Collection<Thread>,Returns a collection containing threads that may be waiting to acquire either the read or write lock.,"

getQueuedThreads
protected Collection<Thread> getQueuedThreads()
Returns a collection containing threads that may be waiting to
 acquire either the read or write lock.  Because the actual set
 of threads may change dynamically while constructing this
 result, the returned collection is only a best-effort estimate.
 The elements of the returned collection are in no particular
 order.  This method is designed to facilitate construction of
 subclasses that provide more extensive monitoring facilities.

Returns:
the collection of threads


"
ReentrantReadWriteLock,getQueuedWriterThreads(),protected Collection<Thread>,Returns a collection containing threads that may be waiting to acquire the write lock.,"

getQueuedWriterThreads
protected Collection<Thread> getQueuedWriterThreads()
Returns a collection containing threads that may be waiting to
 acquire the write lock.  Because the actual set of threads may
 change dynamically while constructing this result, the returned
 collection is only a best-effort estimate.  The elements of the
 returned collection are in no particular order.  This method is
 designed to facilitate construction of subclasses that provide
 more extensive lock monitoring facilities.

Returns:
the collection of threads


"
ReentrantReadWriteLock,getQueueLength(),int,Returns an estimate of the number of threads waiting to acquire either the read or write lock.,"

getQueueLength
public final int getQueueLength()
Returns an estimate of the number of threads waiting to acquire
 either the read or write lock.  The value is only an estimate
 because the number of threads may change dynamically while this
 method traverses internal data structures.  This method is
 designed for use in monitoring of the system state, not for
 synchronization control.

Returns:
the estimated number of threads waiting for this lock


"
ReentrantReadWriteLock,getReadHoldCount(),int,Queries the number of reentrant read holds on this lock by the current thread.,"

getReadHoldCount
public int getReadHoldCount()
Queries the number of reentrant read holds on this lock by the
 current thread.  A reader thread has a hold on a lock for
 each lock action that is not matched by an unlock action.

Returns:
the number of holds on the read lock by the current thread,
         or zero if the read lock is not held by the current thread
Since:
1.6


"
ReentrantReadWriteLock,getReadLockCount(),int,Queries the number of read locks held for this lock.,"

getReadLockCount
public int getReadLockCount()
Queries the number of read locks held for this lock. This
 method is designed for use in monitoring system state, not for
 synchronization control.

Returns:
the number of read locks held


"
ReentrantReadWriteLock,getWaitingThreads(Condition condition),protected Collection<Thread>,Returns a collection containing those threads that may be waiting on the given condition associated with the write lock.,"

getWaitingThreads
protected Collection<Thread> getWaitingThreads(Condition condition)
Returns a collection containing those threads that may be
 waiting on the given condition associated with the write lock.
 Because the actual set of threads may change dynamically while
 constructing this result, the returned collection is only a
 best-effort estimate. The elements of the returned collection
 are in no particular order.  This method is designed to
 facilitate construction of subclasses that provide more
 extensive condition monitoring facilities.

Parameters:
condition - the condition
Returns:
the collection of threads
Throws:
IllegalMonitorStateException - if this lock is not held
IllegalArgumentException - if the given condition is
         not associated with this lock
NullPointerException - if the condition is null


"
ReentrantReadWriteLock,getWaitQueueLength(Condition condition),int,Returns an estimate of the number of threads waiting on the given condition associated with the write lock.,"

getWaitQueueLength
public int getWaitQueueLength(Condition condition)
Returns an estimate of the number of threads waiting on the
 given condition associated with the write lock. Note that because
 timeouts and interrupts may occur at any time, the estimate
 serves only as an upper bound on the actual number of waiters.
 This method is designed for use in monitoring of the system
 state, not for synchronization control.

Parameters:
condition - the condition
Returns:
the estimated number of waiting threads
Throws:
IllegalMonitorStateException - if this lock is not held
IllegalArgumentException - if the given condition is
         not associated with this lock
NullPointerException - if the condition is null


"
ReentrantReadWriteLock,getWriteHoldCount(),int,Queries the number of reentrant write holds on this lock by the current thread.,"

getWriteHoldCount
public int getWriteHoldCount()
Queries the number of reentrant write holds on this lock by the
 current thread.  A writer thread has a hold on a lock for
 each lock action that is not matched by an unlock action.

Returns:
the number of holds on the write lock by the current thread,
         or zero if the write lock is not held by the current thread


"
ReentrantReadWriteLock,hasQueuedThread(Thread thread),boolean,Queries whether the given thread is waiting to acquire either the read or write lock.,"

hasQueuedThread
public final boolean hasQueuedThread(Thread thread)
Queries whether the given thread is waiting to acquire either
 the read or write lock. Note that because cancellations may
 occur at any time, a true return does not guarantee
 that this thread will ever acquire a lock.  This method is
 designed primarily for use in monitoring of the system state.

Parameters:
thread - the thread
Returns:
true if the given thread is queued waiting for this lock
Throws:
NullPointerException - if the thread is null


"
ReentrantReadWriteLock,hasQueuedThreads(),boolean,Queries whether any threads are waiting to acquire the read or write lock.,"

hasQueuedThreads
public final boolean hasQueuedThreads()
Queries whether any threads are waiting to acquire the read or
 write lock. Note that because cancellations may occur at any
 time, a true return does not guarantee that any other
 thread will ever acquire a lock.  This method is designed
 primarily for use in monitoring of the system state.

Returns:
true if there may be other threads waiting to
         acquire the lock


"
ReentrantReadWriteLock,hasWaiters(Condition condition),boolean,Queries whether any threads are waiting on the given condition associated with the write lock.,"

hasWaiters
public boolean hasWaiters(Condition condition)
Queries whether any threads are waiting on the given condition
 associated with the write lock. Note that because timeouts and
 interrupts may occur at any time, a true return does
 not guarantee that a future signal will awaken any
 threads.  This method is designed primarily for use in
 monitoring of the system state.

Parameters:
condition - the condition
Returns:
true if there are any waiting threads
Throws:
IllegalMonitorStateException - if this lock is not held
IllegalArgumentException - if the given condition is
         not associated with this lock
NullPointerException - if the condition is null


"
ReentrantReadWriteLock,isFair(),boolean,Returns true if this lock has fairness set true.,"

isFair
public final boolean isFair()
Returns true if this lock has fairness set true.

Returns:
true if this lock has fairness set true


"
ReentrantReadWriteLock,isWriteLocked(),boolean,Queries if the write lock is held by any thread.,"

isWriteLocked
public boolean isWriteLocked()
Queries if the write lock is held by any thread. This method is
 designed for use in monitoring system state, not for
 synchronization control.

Returns:
true if any thread holds the write lock and
         false otherwise


"
ReentrantReadWriteLock,isWriteLockedByCurrentThread(),boolean,Queries if the write lock is held by the current thread.,"

isWriteLockedByCurrentThread
public boolean isWriteLockedByCurrentThread()
Queries if the write lock is held by the current thread.

Returns:
true if the current thread holds the write lock and
         false otherwise


"
ReentrantReadWriteLock,readLock(),ReentrantReadWriteLock.ReadLock,Returns the lock used for reading.,"

readLock
public ReentrantReadWriteLock.ReadLock readLock()
Description copied from interface: ReadWriteLock
Returns the lock used for reading.

Specified by:
readLock in interface ReadWriteLock
Returns:
the lock used for reading


"
ReentrantReadWriteLock,toString(),String,"Returns a string identifying this lock, as well as its lock state.","

toString
public String toString()
Returns a string identifying this lock, as well as its lock state.
 The state, in brackets, includes the String ""Write locks =""
 followed by the number of reentrantly held write locks, and the
 String ""Read locks ="" followed by the number of held
 read locks.

Overrides:
toString in class Object
Returns:
a string identifying this lock, as well as its lock state


"
ReentrantReadWriteLock,writeLock(),ReentrantReadWriteLock.WriteLock,Returns the lock used for writing.,"

writeLock
public ReentrantReadWriteLock.WriteLock writeLock()
Description copied from interface: ReadWriteLock
Returns the lock used for writing.

Specified by:
writeLock in interface ReadWriteLock
Returns:
the lock used for writing


"
ReentrantReadWriteLock.ReadLock,lock(),void,Acquires the read lock.,"

lock
public void lock()
Acquires the read lock.

 Acquires the read lock if the write lock is not held by
 another thread and returns immediately.

 If the write lock is held by another thread then
 the current thread becomes disabled for thread scheduling
 purposes and lies dormant until the read lock has been acquired.

Specified by:
lock in interface Lock


"
ReentrantReadWriteLock.ReadLock,lockInterruptibly(),void,Acquires the read lock unless the current thread is interrupted.,"

lockInterruptibly
public void lockInterruptibly()
                       throws InterruptedException
Acquires the read lock unless the current thread is
 interrupted.

 Acquires the read lock if the write lock is not held
 by another thread and returns immediately.

 If the write lock is held by another thread then the
 current thread becomes disabled for thread scheduling
 purposes and lies dormant until one of two things happens:

 
The read lock is acquired by the current thread; or

 Some other thread interrupts
 the current thread.

 
If the current thread:

 
has its interrupted status set on entry to this method; or

 is interrupted while
 acquiring the read lock,

 

 then InterruptedException is thrown and the current
 thread's interrupted status is cleared.

 In this implementation, as this method is an explicit
 interruption point, preference is given to responding to
 the interrupt over normal or reentrant acquisition of the
 lock.

Specified by:
lockInterruptibly in interface Lock
Throws:
InterruptedException - if the current thread is interrupted


"
ReentrantReadWriteLock.ReadLock,newCondition(),Condition,Throws UnsupportedOperationException because ReadLocks do not support conditions.,"

newCondition
public Condition newCondition()
Throws UnsupportedOperationException because
 ReadLocks do not support conditions.

Specified by:
newCondition in interface Lock
Returns:
A new Condition instance for this Lock instance
Throws:
UnsupportedOperationException - always


"
ReentrantReadWriteLock.ReadLock,toString(),String,"Returns a string identifying this lock, as well as its lock state.","

toString
public String toString()
Returns a string identifying this lock, as well as its lock state.
 The state, in brackets, includes the String ""Read locks =""
 followed by the number of held read locks.

Overrides:
toString in class Object
Returns:
a string identifying this lock, as well as its lock state


"
ReentrantReadWriteLock.ReadLock,tryLock(),boolean,Acquires the read lock only if the write lock is not held by another thread at the time of invocation.,"

tryLock
public boolean tryLock()
Acquires the read lock only if the write lock is not held by
 another thread at the time of invocation.

 Acquires the read lock if the write lock is not held by
 another thread and returns immediately with the value
 true. Even when this lock has been set to use a
 fair ordering policy, a call to tryLock()
will immediately acquire the read lock if it is
 available, whether or not other threads are currently
 waiting for the read lock.  This ""barging"" behavior
 can be useful in certain circumstances, even though it
 breaks fairness. If you want to honor the fairness setting
 for this lock, then use tryLock(0, TimeUnit.SECONDS)  which is almost equivalent
 (it also detects interruption).

 If the write lock is held by another thread then
 this method will return immediately with the value
 false.

Specified by:
tryLock in interface Lock
Returns:
true if the read lock was acquired


"
ReentrantReadWriteLock.ReadLock,"tryLock(long timeout, TimeUnit unit)",boolean,Acquires the read lock if the write lock is not held by another thread within the given waiting time and the current thread has not been interrupted.,"

tryLock
public boolean tryLock(long timeout,
                       TimeUnit unit)
                throws InterruptedException
Acquires the read lock if the write lock is not held by
 another thread within the given waiting time and the
 current thread has not been interrupted.

 Acquires the read lock if the write lock is not held by
 another thread and returns immediately with the value
 true. If this lock has been set to use a fair
 ordering policy then an available lock will not be
 acquired if any other threads are waiting for the
 lock. This is in contrast to the tryLock()
 method. If you want a timed tryLock that does
 permit barging on a fair lock then combine the timed and
 un-timed forms together:

   
 if (lock.tryLock() ||
     lock.tryLock(timeout, unit)) {
   ...
 }
If the write lock is held by another thread then the
 current thread becomes disabled for thread scheduling
 purposes and lies dormant until one of three things happens:

 
The read lock is acquired by the current thread; or

 Some other thread interrupts
 the current thread; or

 The specified waiting time elapses.

 
If the read lock is acquired then the value true is
 returned.

 If the current thread:

 
has its interrupted status set on entry to this method; or

 is interrupted while
 acquiring the read lock,

  then InterruptedException is thrown and the
 current thread's interrupted status is cleared.

 If the specified waiting time elapses then the value
 false is returned.  If the time is less than or
 equal to zero, the method will not wait at all.

 In this implementation, as this method is an explicit
 interruption point, preference is given to responding to
 the interrupt over normal or reentrant acquisition of the
 lock, and over reporting the elapse of the waiting time.

Specified by:
tryLock in interface Lock
Parameters:
timeout - the time to wait for the read lock
unit - the time unit of the timeout argument
Returns:
true if the read lock was acquired
Throws:
InterruptedException - if the current thread is interrupted
NullPointerException - if the time unit is null


"
ReentrantReadWriteLock.ReadLock,unlock(),void,Attempts to release this lock.,"

unlock
public void unlock()
Attempts to release this lock.

 If the number of readers is now zero then the lock
 is made available for write lock attempts.

Specified by:
unlock in interface Lock


"
ReentrantReadWriteLock.WriteLock,getHoldCount(),int,Queries the number of holds on this write lock by the current thread.,"

getHoldCount
public int getHoldCount()
Queries the number of holds on this write lock by the current
 thread.  A thread has a hold on a lock for each lock action
 that is not matched by an unlock action.  Identical in effect
 to ReentrantReadWriteLock.getWriteHoldCount().

Returns:
the number of holds on this lock by the current thread,
         or zero if this lock is not held by the current thread
Since:
1.6


"
ReentrantReadWriteLock.WriteLock,isHeldByCurrentThread(),boolean,Queries if this write lock is held by the current thread.,"

isHeldByCurrentThread
public boolean isHeldByCurrentThread()
Queries if this write lock is held by the current thread.
 Identical in effect to ReentrantReadWriteLock.isWriteLockedByCurrentThread().

Returns:
true if the current thread holds this lock and
         false otherwise
Since:
1.6


"
ReentrantReadWriteLock.WriteLock,lock(),void,Acquires the write lock.,"

lock
public void lock()
Acquires the write lock.

 Acquires the write lock if neither the read nor write lock
 are held by another thread
 and returns immediately, setting the write lock hold count to
 one.

 If the current thread already holds the write lock then the
 hold count is incremented by one and the method returns
 immediately.

 If the lock is held by another thread then the current
 thread becomes disabled for thread scheduling purposes and
 lies dormant until the write lock has been acquired, at which
 time the write lock hold count is set to one.

Specified by:
lock in interface Lock


"
ReentrantReadWriteLock.WriteLock,lockInterruptibly(),void,Acquires the write lock unless the current thread is interrupted.,"

lockInterruptibly
public void lockInterruptibly()
                       throws InterruptedException
Acquires the write lock unless the current thread is
 interrupted.

 Acquires the write lock if neither the read nor write lock
 are held by another thread
 and returns immediately, setting the write lock hold count to
 one.

 If the current thread already holds this lock then the
 hold count is incremented by one and the method returns
 immediately.

 If the lock is held by another thread then the current
 thread becomes disabled for thread scheduling purposes and
 lies dormant until one of two things happens:

 
The write lock is acquired by the current thread; or

 Some other thread interrupts
 the current thread.

 
If the write lock is acquired by the current thread then the
 lock hold count is set to one.

 If the current thread:

 
has its interrupted status set on entry to this method;
 or

 is interrupted while
 acquiring the write lock,

 

 then InterruptedException is thrown and the current
 thread's interrupted status is cleared.

 In this implementation, as this method is an explicit
 interruption point, preference is given to responding to
 the interrupt over normal or reentrant acquisition of the
 lock.

Specified by:
lockInterruptibly in interface Lock
Throws:
InterruptedException - if the current thread is interrupted


"
ReentrantReadWriteLock.WriteLock,newCondition(),Condition,Returns a Condition instance for use with this Lock instance.,"

newCondition
public Condition newCondition()
Returns a Condition instance for use with this
 Lock instance.
 The returned Condition instance supports the same
 usages as do the Object monitor methods (wait, notify, and notifyAll) when used with the built-in
 monitor lock.

 
If this write lock is not held when any Condition method is called then an IllegalMonitorStateException is thrown.  (Read locks are
 held independently of write locks, so are not checked or
 affected. However it is essentially always an error to
 invoke a condition waiting method when the current thread
 has also acquired read locks, since other threads that
 could unblock it will not be able to acquire the write
 lock.)

 When the condition waiting
 methods are called the write lock is released and, before
 they return, the write lock is reacquired and the lock hold
 count restored to what it was when the method was called.

 If a thread is interrupted while
 waiting then the wait will terminate, an InterruptedException will be thrown, and the thread's
 interrupted status will be cleared.

  Waiting threads are signalled in FIFO order.

 The ordering of lock reacquisition for threads returning
 from waiting methods is the same as for threads initially
 acquiring the lock, which is in the default case not specified,
 but for fair locks favors those threads that have been
 waiting the longest.

 

Specified by:
newCondition in interface Lock
Returns:
the Condition object


"
ReentrantReadWriteLock.WriteLock,toString(),String,"Returns a string identifying this lock, as well as its lock state.","

toString
public String toString()
Returns a string identifying this lock, as well as its lock
 state.  The state, in brackets includes either the String
 ""Unlocked"" or the String ""Locked by""
 followed by the name of the owning thread.

Overrides:
toString in class Object
Returns:
a string identifying this lock, as well as its lock state


"
ReentrantReadWriteLock.WriteLock,tryLock(),boolean,Acquires the write lock only if it is not held by another thread at the time of invocation.,"

tryLock
public boolean tryLock()
Acquires the write lock only if it is not held by another thread
 at the time of invocation.

 Acquires the write lock if neither the read nor write lock
 are held by another thread
 and returns immediately with the value true,
 setting the write lock hold count to one. Even when this lock has
 been set to use a fair ordering policy, a call to
 tryLock() will immediately acquire the
 lock if it is available, whether or not other threads are
 currently waiting for the write lock.  This ""barging""
 behavior can be useful in certain circumstances, even
 though it breaks fairness. If you want to honor the
 fairness setting for this lock, then use tryLock(0, TimeUnit.SECONDS) 
 which is almost equivalent (it also detects interruption).

 If the current thread already holds this lock then the
 hold count is incremented by one and the method returns
 true.

 If the lock is held by another thread then this method
 will return immediately with the value false.

Specified by:
tryLock in interface Lock
Returns:
true if the lock was free and was acquired
 by the current thread, or the write lock was already held
 by the current thread; and false otherwise.


"
ReentrantReadWriteLock.WriteLock,"tryLock(long timeout, TimeUnit unit)",boolean,Acquires the write lock if it is not held by another thread within the given waiting time and the current thread has not been interrupted.,"

tryLock
public boolean tryLock(long timeout,
                       TimeUnit unit)
                throws InterruptedException
Acquires the write lock if it is not held by another thread
 within the given waiting time and the current thread has
 not been interrupted.

 Acquires the write lock if neither the read nor write lock
 are held by another thread
 and returns immediately with the value true,
 setting the write lock hold count to one. If this lock has been
 set to use a fair ordering policy then an available lock
 will not be acquired if any other threads are
 waiting for the write lock. This is in contrast to the tryLock() method. If you want a timed tryLock
 that does permit barging on a fair lock then combine the
 timed and un-timed forms together:

   
 if (lock.tryLock() ||
     lock.tryLock(timeout, unit)) {
   ...
 }
If the current thread already holds this lock then the
 hold count is incremented by one and the method returns
 true.

 If the lock is held by another thread then the current
 thread becomes disabled for thread scheduling purposes and
 lies dormant until one of three things happens:

 
The write lock is acquired by the current thread; or

 Some other thread interrupts
 the current thread; or

 The specified waiting time elapses

 
If the write lock is acquired then the value true is
 returned and the write lock hold count is set to one.

 If the current thread:

 
has its interrupted status set on entry to this method;
 or

 is interrupted while
 acquiring the write lock,

 

 then InterruptedException is thrown and the current
 thread's interrupted status is cleared.

 If the specified waiting time elapses then the value
 false is returned.  If the time is less than or
 equal to zero, the method will not wait at all.

 In this implementation, as this method is an explicit
 interruption point, preference is given to responding to
 the interrupt over normal or reentrant acquisition of the
 lock, and over reporting the elapse of the waiting time.

Specified by:
tryLock in interface Lock
Parameters:
timeout - the time to wait for the write lock
unit - the time unit of the timeout argument
Returns:
true if the lock was free and was acquired
 by the current thread, or the write lock was already held by the
 current thread; and false if the waiting time
 elapsed before the lock could be acquired.
Throws:
InterruptedException - if the current thread is interrupted
NullPointerException - if the time unit is null


"
ReentrantReadWriteLock.WriteLock,unlock(),void,Attempts to release this lock.,"

unlock
public void unlock()
Attempts to release this lock.

 If the current thread is the holder of this lock then
 the hold count is decremented. If the hold count is now
 zero then the lock is released.  If the current thread is
 not the holder of this lock then IllegalMonitorStateException is thrown.

Specified by:
unlock in interface Lock
Throws:
IllegalMonitorStateException - if the current thread does not
 hold this lock


"
StampedLock,asReadLock(),Lock,"Returns a plain Lock view of this StampedLock in which the Lock.lock() method is mapped to readLock(), and similarly for other methods.","

asReadLock
public Lock asReadLock()
Returns a plain Lock view of this StampedLock in which
 the Lock.lock() method is mapped to readLock(),
 and similarly for other methods. The returned Lock does not
 support a Condition; method Lock.newCondition() throws UnsupportedOperationException.

Returns:
the lock


"
StampedLock,asReadWriteLock(),ReadWriteLock,"Returns a ReadWriteLock view of this StampedLock in which the ReadWriteLock.readLock() method is mapped to asReadLock(), and ReadWriteLock.writeLock() to asWriteLock().","

asReadWriteLock
public ReadWriteLock asReadWriteLock()
Returns a ReadWriteLock view of this StampedLock in
 which the ReadWriteLock.readLock() method is mapped to
 asReadLock(), and ReadWriteLock.writeLock() to
 asWriteLock().

Returns:
the lock


"
StampedLock,asWriteLock(),Lock,"Returns a plain Lock view of this StampedLock in which the Lock.lock() method is mapped to writeLock(), and similarly for other methods.","

asWriteLock
public Lock asWriteLock()
Returns a plain Lock view of this StampedLock in which
 the Lock.lock() method is mapped to writeLock(),
 and similarly for other methods. The returned Lock does not
 support a Condition; method Lock.newCondition() throws UnsupportedOperationException.

Returns:
the lock


"
StampedLock,getReadLockCount(),int,Queries the number of read locks held for this lock.,"

getReadLockCount
public int getReadLockCount()
Queries the number of read locks held for this lock. This
 method is designed for use in monitoring system state, not for
 synchronization control.

Returns:
the number of read locks held


"
StampedLock,isReadLocked(),boolean,Returns true if the lock is currently held non-exclusively.,"

isReadLocked
public boolean isReadLocked()
Returns true if the lock is currently held non-exclusively.

Returns:
true if the lock is currently held non-exclusively


"
StampedLock,isWriteLocked(),boolean,Returns true if the lock is currently held exclusively.,"

isWriteLocked
public boolean isWriteLocked()
Returns true if the lock is currently held exclusively.

Returns:
true if the lock is currently held exclusively


"
StampedLock,readLock(),long,"Non-exclusively acquires the lock, blocking if necessary until available.","

readLock
public long readLock()
Non-exclusively acquires the lock, blocking if necessary
 until available.

Returns:
a stamp that can be used to unlock or convert mode


"
StampedLock,readLockInterruptibly(),long,"Non-exclusively acquires the lock, blocking if necessary until available or the current thread is interrupted.","

readLockInterruptibly
public long readLockInterruptibly()
                           throws InterruptedException
Non-exclusively acquires the lock, blocking if necessary
 until available or the current thread is interrupted.
 Behavior under interruption matches that specified
 for method Lock.lockInterruptibly().

Returns:
a stamp that can be used to unlock or convert mode
Throws:
InterruptedException - if the current thread is interrupted
 before acquiring the lock


"
StampedLock,toString(),String,"Returns a string identifying this lock, as well as its lock state.","

toString
public String toString()
Returns a string identifying this lock, as well as its lock
 state.  The state, in brackets, includes the String ""Unlocked"" or the String ""Write-locked"" or the String
 ""Read-locks:"" followed by the current number of
 read-locks held.

Overrides:
toString in class Object
Returns:
a string identifying this lock, as well as its lock state


"
StampedLock,tryConvertToOptimisticRead(long stamp),long,"If the lock state matches the given stamp then, if the stamp represents holding a lock, releases it and returns an observation stamp.","

tryConvertToOptimisticRead
public long tryConvertToOptimisticRead(long stamp)
If the lock state matches the given stamp then, if the stamp
 represents holding a lock, releases it and returns an
 observation stamp.  Or, if an optimistic read, returns it if
 validated. This method returns zero in all other cases, and so
 may be useful as a form of ""tryUnlock"".

Parameters:
stamp - a stamp
Returns:
a valid optimistic read stamp, or zero on failure


"
StampedLock,tryConvertToReadLock(long stamp),long,"If the lock state matches the given stamp, performs one of the following actions.","

tryConvertToReadLock
public long tryConvertToReadLock(long stamp)
If the lock state matches the given stamp, performs one of
 the following actions. If the stamp represents holding a write
 lock, releases it and obtains a read lock.  Or, if a read lock,
 returns it. Or, if an optimistic read, acquires a read lock and
 returns a read stamp only if immediately available. This method
 returns zero in all other cases.

Parameters:
stamp - a stamp
Returns:
a valid read stamp, or zero on failure


"
StampedLock,tryConvertToWriteLock(long stamp),long,"If the lock state matches the given stamp, performs one of the following actions.","

tryConvertToWriteLock
public long tryConvertToWriteLock(long stamp)
If the lock state matches the given stamp, performs one of
 the following actions. If the stamp represents holding a write
 lock, returns it.  Or, if a read lock, if the write lock is
 available, releases the read lock and returns a write stamp.
 Or, if an optimistic read, returns a write stamp only if
 immediately available. This method returns zero in all other
 cases.

Parameters:
stamp - a stamp
Returns:
a valid write stamp, or zero on failure


"
StampedLock,tryOptimisticRead(),long,"Returns a stamp that can later be validated, or zero if exclusively locked.","

tryOptimisticRead
public long tryOptimisticRead()
Returns a stamp that can later be validated, or zero
 if exclusively locked.

Returns:
a stamp, or zero if exclusively locked


"
StampedLock,tryReadLock(),long,Non-exclusively acquires the lock if it is immediately available.,"

tryReadLock
public long tryReadLock()
Non-exclusively acquires the lock if it is immediately available.

Returns:
a stamp that can be used to unlock or convert mode,
 or zero if the lock is not available


"
StampedLock,"tryReadLock(long time, TimeUnit unit)",long,Non-exclusively acquires the lock if it is available within the given time and the current thread has not been interrupted.,"

tryReadLock
public long tryReadLock(long time,
                        TimeUnit unit)
                 throws InterruptedException
Non-exclusively acquires the lock if it is available within the
 given time and the current thread has not been interrupted.
 Behavior under timeout and interruption matches that specified
 for method Lock.tryLock(long,TimeUnit).

Parameters:
time - the maximum time to wait for the lock
unit - the time unit of the time argument
Returns:
a stamp that can be used to unlock or convert mode,
 or zero if the lock is not available
Throws:
InterruptedException - if the current thread is interrupted
 before acquiring the lock


"
StampedLock,tryUnlockRead(),boolean,"Releases one hold of the read lock if it is held, without requiring a stamp value.","

tryUnlockRead
public boolean tryUnlockRead()
Releases one hold of the read lock if it is held, without
 requiring a stamp value. This method may be useful for recovery
 after errors.

Returns:
true if the read lock was held, else false


"
StampedLock,tryUnlockWrite(),boolean,"Releases the write lock if it is held, without requiring a stamp value.","

tryUnlockWrite
public boolean tryUnlockWrite()
Releases the write lock if it is held, without requiring a
 stamp value. This method may be useful for recovery after
 errors.

Returns:
true if the lock was held, else false


"
StampedLock,tryWriteLock(),long,Exclusively acquires the lock if it is immediately available.,"

tryWriteLock
public long tryWriteLock()
Exclusively acquires the lock if it is immediately available.

Returns:
a stamp that can be used to unlock or convert mode,
 or zero if the lock is not available


"
StampedLock,"tryWriteLock(long time, TimeUnit unit)",long,Exclusively acquires the lock if it is available within the given time and the current thread has not been interrupted.,"

tryWriteLock
public long tryWriteLock(long time,
                         TimeUnit unit)
                  throws InterruptedException
Exclusively acquires the lock if it is available within the
 given time and the current thread has not been interrupted.
 Behavior under timeout and interruption matches that specified
 for method Lock.tryLock(long,TimeUnit).

Parameters:
time - the maximum time to wait for the lock
unit - the time unit of the time argument
Returns:
a stamp that can be used to unlock or convert mode,
 or zero if the lock is not available
Throws:
InterruptedException - if the current thread is interrupted
 before acquiring the lock


"
StampedLock,unlock(long stamp),void,"If the lock state matches the given stamp, releases the corresponding mode of the lock.","

unlock
public void unlock(long stamp)
If the lock state matches the given stamp, releases the
 corresponding mode of the lock.

Parameters:
stamp - a stamp returned by a lock operation
Throws:
IllegalMonitorStateException - if the stamp does
 not match the current state of this lock


"
StampedLock,unlockRead(long stamp),void,"If the lock state matches the given stamp, releases the non-exclusive lock.","

unlockRead
public void unlockRead(long stamp)
If the lock state matches the given stamp, releases the
 non-exclusive lock.

Parameters:
stamp - a stamp returned by a read-lock operation
Throws:
IllegalMonitorStateException - if the stamp does
 not match the current state of this lock


"
StampedLock,unlockWrite(long stamp),void,"If the lock state matches the given stamp, releases the exclusive lock.","

unlockWrite
public void unlockWrite(long stamp)
If the lock state matches the given stamp, releases the
 exclusive lock.

Parameters:
stamp - a stamp returned by a write-lock operation
Throws:
IllegalMonitorStateException - if the stamp does
 not match the current state of this lock


"
StampedLock,validate(long stamp),boolean,Returns true if the lock has not been exclusively acquired since issuance of the given stamp.,"

validate
public boolean validate(long stamp)
Returns true if the lock has not been exclusively acquired
 since issuance of the given stamp. Always returns false if the
 stamp is zero. Always returns true if the stamp represents a
 currently held lock. Invoking this method with a value not
 obtained from tryOptimisticRead() or a locking method
 for this lock has no defined effect or result.

Parameters:
stamp - a stamp
Returns:
true if the lock has not been exclusively acquired
 since issuance of the given stamp; else false


"
StampedLock,writeLock(),long,"Exclusively acquires the lock, blocking if necessary until available.","

writeLock
public long writeLock()
Exclusively acquires the lock, blocking if necessary
 until available.

Returns:
a stamp that can be used to unlock or convert mode


"
StampedLock,writeLockInterruptibly(),long,"Exclusively acquires the lock, blocking if necessary until available or the current thread is interrupted.","

writeLockInterruptibly
public long writeLockInterruptibly()
                            throws InterruptedException
Exclusively acquires the lock, blocking if necessary
 until available or the current thread is interrupted.
 Behavior under interruption matches that specified
 for method Lock.lockInterruptibly().

Returns:
a stamp that can be used to unlock or convert mode
Throws:
InterruptedException - if the current thread is interrupted
 before acquiring the lock


"
