ClassName,Method,Return Type,Description,Full Description
Clipboard,addFlavorListener(FlavorListener listener),void,Registers the specified FlavorListener to receive FlavorEvents from this clipboard.,"

addFlavorListener
public void addFlavorListener(FlavorListener listener)
Registers the specified FlavorListener to receive
 FlavorEvents from this clipboard.
 If listener is null, no exception
 is thrown and no action is performed.

Parameters:
listener - the listener to be added
Since:
1.5
See Also:
removeFlavorListener(java.awt.datatransfer.FlavorListener), 
getFlavorListeners(), 
FlavorListener, 
FlavorEvent


"
Clipboard,getAvailableDataFlavors(),DataFlavor[],Returns an array of DataFlavors in which the current contents of this clipboard can be provided.,"

getAvailableDataFlavors
public DataFlavor[] getAvailableDataFlavors()
Returns an array of DataFlavors in which the current
 contents of this clipboard can be provided. If there are no
 DataFlavors available, this method returns a zero-length
 array.

Returns:
an array of DataFlavors in which the current
         contents of this clipboard can be provided
Throws:
IllegalStateException - if this clipboard is currently unavailable
Since:
1.5


"
Clipboard,getContents(Object requestor),Transferable,Returns a transferable object representing the current contents of the clipboard.,"

getContents
public Transferable getContents(Object requestor)
Returns a transferable object representing the current contents
 of the clipboard.  If the clipboard currently has no contents,
 it returns null. The parameter Object requestor is
 not currently used.  The method throws
 IllegalStateException if the clipboard is currently
 unavailable.  For example, on some platforms, the system clipboard is
 unavailable while it is accessed by another application.

Parameters:
requestor - the object requesting the clip data  (not used)
Returns:
the current transferable object on the clipboard
Throws:
IllegalStateException - if the clipboard is currently unavailable
See Also:
Toolkit.getSystemClipboard()


"
Clipboard,getData(DataFlavor flavor),Object,Returns an object representing the current contents of this clipboard in the specified DataFlavor.,"

getData
public Object getData(DataFlavor flavor)
               throws UnsupportedFlavorException,
                      IOException
Returns an object representing the current contents of this clipboard
 in the specified DataFlavor.
 The class of the object returned is defined by the representation
 class of flavor.

Parameters:
flavor - the requested DataFlavor for the contents
Returns:
an object representing the current contents of this clipboard
         in the specified DataFlavor
Throws:
NullPointerException - if flavor is null
IllegalStateException - if this clipboard is currently unavailable
UnsupportedFlavorException - if the requested DataFlavor
         is not available
IOException - if the data in the requested DataFlavor
         can not be retrieved
Since:
1.5
See Also:
DataFlavor.getRepresentationClass()


"
Clipboard,getFlavorListeners(),FlavorListener[],Returns an array of all the FlavorListeners currently registered on this Clipboard.,"

getFlavorListeners
public FlavorListener[] getFlavorListeners()
Returns an array of all the FlavorListeners currently
 registered on this Clipboard.

Returns:
all of this clipboard's FlavorListeners or an empty
         array if no listeners are currently registered
Since:
1.5
See Also:
addFlavorListener(java.awt.datatransfer.FlavorListener), 
removeFlavorListener(java.awt.datatransfer.FlavorListener), 
FlavorListener, 
FlavorEvent


"
Clipboard,getName(),String,Returns the name of this clipboard object.,"

getName
public String getName()
Returns the name of this clipboard object.

See Also:
Toolkit.getSystemClipboard()


"
Clipboard,isDataFlavorAvailable(DataFlavor flavor),boolean,Returns whether or not the current contents of this clipboard can be provided in the specified DataFlavor.,"

isDataFlavorAvailable
public boolean isDataFlavorAvailable(DataFlavor flavor)
Returns whether or not the current contents of this clipboard can be
 provided in the specified DataFlavor.

Parameters:
flavor - the requested DataFlavor for the contents
Returns:
true if the current contents of this clipboard
         can be provided in the specified DataFlavor;
         false otherwise
Throws:
NullPointerException - if flavor is null
IllegalStateException - if this clipboard is currently unavailable
Since:
1.5


"
Clipboard,removeFlavorListener(FlavorListener listener),void,Removes the specified FlavorListener so that it no longer receives FlavorEvents from this Clipboard.,"

removeFlavorListener
public void removeFlavorListener(FlavorListener listener)
Removes the specified FlavorListener so that it no longer
 receives FlavorEvents from this Clipboard.
 This method performs no function, nor does it throw an exception, if
 the listener specified by the argument was not previously added to this
 Clipboard.
 If listener is null, no exception
 is thrown and no action is performed.

Parameters:
listener - the listener to be removed
Since:
1.5
See Also:
addFlavorListener(java.awt.datatransfer.FlavorListener), 
getFlavorListeners(), 
FlavorListener, 
FlavorEvent


"
Clipboard,"setContents(Transferable contents, ClipboardOwner owner)",void,Sets the current contents of the clipboard to the specified transferable object and registers the specified clipboard owner as the owner of the new contents.,"

setContents
public void setContents(Transferable contents,
                        ClipboardOwner owner)
Sets the current contents of the clipboard to the specified
 transferable object and registers the specified clipboard owner
 as the owner of the new contents.
 
 If there is an existing owner different from the argument
 owner, that owner is notified that it no longer
 holds ownership of the clipboard contents via an invocation
 of ClipboardOwner.lostOwnership() on that owner.
 An implementation of setContents() is free not
 to invoke lostOwnership() directly from this method.
 For example, lostOwnership() may be invoked later on
 a different thread. The same applies to FlavorListeners
 registered on this clipboard.
 
 The method throws IllegalStateException if the clipboard
 is currently unavailable. For example, on some platforms, the system
 clipboard is unavailable while it is accessed by another application.

Parameters:
contents - the transferable object representing the
                 clipboard content
owner - the object which owns the clipboard content
Throws:
IllegalStateException - if the clipboard is currently unavailable
See Also:
Toolkit.getSystemClipboard()


"
DataFlavor,clone(),Object,Returns a clone of this DataFlavor.,"

clone
public Object clone()
             throws CloneNotSupportedException
Returns a clone of this DataFlavor.

Overrides:
clone in class Object
Returns:
a clone of this DataFlavor
Throws:
CloneNotSupportedException - if the object's class does not
               support the Cloneable interface. Subclasses
               that override the clone method can also
               throw this exception to indicate that an instance cannot
               be cloned.
See Also:
Cloneable


"
DataFlavor,equals(DataFlavor that),boolean,This method has the same behavior as equals(Object).,"

equals
public boolean equals(DataFlavor that)
This method has the same behavior as equals(Object).
 The only difference being that it takes a DataFlavor instance
 as a parameter.

Parameters:
that - the DataFlavor to compare with
        this
Returns:
true if that is equivalent to this
         DataFlavor; false otherwise
See Also:
selectBestTextFlavor(java.awt.datatransfer.DataFlavor[])


"
DataFlavor,equals(Object o),boolean,"Indicates whether some other object is ""equal to"" this one.","

equals
public boolean equals(Object o)
Indicates whether some other object is ""equal to"" this one.
 
 The equals method implements an equivalence relation
 on non-null object references:
 
It is reflexive: for any non-null reference value
     x, x.equals(x) should return
     true.
 It is symmetric: for any non-null reference values
     x and y, x.equals(y)
     should return true if and only if
     y.equals(x) returns true.
 It is transitive: for any non-null reference values
     x, y, and z, if
     x.equals(y) returns true and
     y.equals(z) returns true, then
     x.equals(z) should return true.
 It is consistent: for any non-null reference values
     x and y, multiple invocations of
     x.equals(y) consistently return true
     or consistently return false, provided no
     information used in equals comparisons on the
     objects is modified.
 For any non-null reference value x,
     x.equals(null) should return false.
 

 The equals method for class Object implements
 the most discriminating possible equivalence relation on objects;
 that is, for any non-null reference values x and
 y, this method returns true if and only
 if x and y refer to the same object
 (x == y has the value true).
 
 Note that it is generally necessary to override the hashCode
 method whenever this method is overridden, so as to maintain the
 general contract for the hashCode method, which states
 that equal objects must have equal hash codes.
 
 The equals comparison for the DataFlavor class is implemented
 as follows: Two DataFlavors are considered equal if and
 only if their MIME primary type and subtype and representation class are
 equal. Additionally, if the primary type is ""text"", the subtype denotes
 a text flavor which supports the charset parameter, and the
 representation class is not java.io.Reader,
 java.lang.String, java.nio.CharBuffer, or
 [C, the charset parameter must also be equal.
 If a charset is not explicitly specified for one or both
 DataFlavors, the platform default encoding is assumed. See
 selectBestTextFlavor for a list of text flavors which
 support the charset parameter.

Overrides:
equals in class Object
Parameters:
o - the Object to compare with this
Returns:
true if that is equivalent to this
         DataFlavor; false otherwise
See Also:
selectBestTextFlavor(java.awt.datatransfer.DataFlavor[])


"
DataFlavor,equals(String s),boolean,"Deprecated. As inconsistent with hashCode() contract, use isMimeTypeEqual(String) instead.","

equals
@Deprecated
public boolean equals(String s)
Deprecated. As inconsistent with hashCode() contract,
             use isMimeTypeEqual(String) instead.
Compares only the mimeType against the passed in
 String and representationClass is
 not considered in the comparison.

 If representationClass needs to be compared, then
 equals(new DataFlavor(s)) may be used.

Parameters:
s - the mimeType to compare.
Returns:
true if the String (MimeType) is equal; false otherwise or if
         s is null


"
DataFlavor,getDefaultRepresentationClass(),Class<?>,NULL,"

getDefaultRepresentationClass
public final Class<?> getDefaultRepresentationClass()

"
DataFlavor,getDefaultRepresentationClassAsString(),String,NULL,"

getDefaultRepresentationClassAsString
public final String getDefaultRepresentationClassAsString()

"
DataFlavor,getHumanPresentableName(),String,Returns the human presentable name for the data format that this DataFlavor represents.,"

getHumanPresentableName
public String getHumanPresentableName()
Returns the human presentable name for the data format that this
 DataFlavor represents.  This name would be localized
 for different countries.

Returns:
the human presentable name for the data format that this
    DataFlavor represents


"
DataFlavor,getMimeType(),String,Returns the MIME type string for this DataFlavor.,"

getMimeType
public String getMimeType()
Returns the MIME type string for this DataFlavor.

Returns:
the MIME type string for this flavor


"
DataFlavor,getParameter(String paramName),String,"Returns the human presentable name for this DataFlavor if paramName equals ""humanPresentableName"".","

getParameter
public String getParameter(String paramName)
Returns the human presentable name for this DataFlavor
 if paramName equals ""humanPresentableName"".  Otherwise
 returns the MIME type value associated with paramName.

Parameters:
paramName - the parameter name requested
Returns:
the value of the name parameter, or null
  if there is no associated value


"
DataFlavor,getPrimaryType(),String,Returns the primary MIME type for this DataFlavor.,"

getPrimaryType
public String getPrimaryType()
Returns the primary MIME type for this DataFlavor.

Returns:
the primary MIME type of this DataFlavor


"
DataFlavor,getReaderForText(Transferable transferable),Reader,"Gets a Reader for a text flavor, decoded, if necessary, for the expected charset (encoding).","

getReaderForText
public Reader getReaderForText(Transferable transferable)
                        throws UnsupportedFlavorException,
                               IOException
Gets a Reader for a text flavor, decoded, if necessary, for the expected
 charset (encoding). The supported representation classes are
 java.io.Reader, java.lang.String,
 java.nio.CharBuffer, [C,
 java.io.InputStream, java.nio.ByteBuffer,
 and [B.
 
 Because text flavors which do not support the charset parameter are
 encoded in a non-standard format, this method should not be called for
 such flavors. However, in order to maintain backward-compatibility,
 if this method is called for such a flavor, this method will treat the
 flavor as though it supports the charset parameter and attempt to
 decode it accordingly. See selectBestTextFlavor for a list
 of text flavors which do not support the charset parameter.

Parameters:
transferable - the Transferable whose data will be
        requested in this flavor
Returns:
a Reader to read the Transferable's
         data
Throws:
IllegalArgumentException - if the representation class
            is not one of the seven listed above
IllegalArgumentException - if the Transferable
            has null data
NullPointerException - if the Transferable is
            null
UnsupportedEncodingException - if this flavor's representation
            is java.io.InputStream,
            java.nio.ByteBuffer, or [B and
            this flavor's encoding is not supported by this
            implementation of the Java platform
UnsupportedFlavorException - if the Transferable
            does not support this flavor
IOException - if the data cannot be read because of an
            I/O error
Since:
1.3
See Also:
selectBestTextFlavor(java.awt.datatransfer.DataFlavor[])


"
DataFlavor,getRepresentationClass(),Class<?>,Returns the Class which objects supporting this DataFlavor will return when this DataFlavor is requested.,"

getRepresentationClass
public Class<?> getRepresentationClass()
Returns the Class which objects supporting this
 DataFlavor will return when this DataFlavor
 is requested.

Returns:
the Class which objects supporting this
 DataFlavor will return when this DataFlavor
 is requested


"
DataFlavor,getSubType(),String,Returns the sub MIME type of this DataFlavor.,"

getSubType
public String getSubType()
Returns the sub MIME type of this DataFlavor.

Returns:
the Sub MIME type of this DataFlavor


"
DataFlavor,getTextPlainUnicodeFlavor(),static DataFlavor,"Returns a DataFlavor representing plain text with Unicode encoding, where:","

getTextPlainUnicodeFlavor
public static final DataFlavor getTextPlainUnicodeFlavor()
Returns a DataFlavor representing plain text with Unicode
 encoding, where:
 
     representationClass = java.io.InputStream
     mimeType            = ""text/plain;
                            charset=<platform default Unicode encoding>""
 
 Sun's implementation for Microsoft Windows uses the encoding utf-16le.
 Sun's implementation for Solaris and Linux uses the encoding
 iso-10646-ucs-2.

Returns:
a DataFlavor representing plain text
    with Unicode encoding
Since:
1.3


"
DataFlavor,hashCode(),int,Returns hash code for this DataFlavor.,"

hashCode
public int hashCode()
Returns hash code for this DataFlavor.
 For two equal DataFlavors, hash codes are equal.
 For the String
 that matches DataFlavor.equals(String), it is not
 guaranteed that DataFlavor's hash code is equal
 to the hash code of the String.

Overrides:
hashCode in class Object
Returns:
a hash code for this DataFlavor
See Also:
Object.equals(java.lang.Object), 
System.identityHashCode(java.lang.Object)


"
DataFlavor,isFlavorJavaFileListType(),boolean,Returns true if the DataFlavor specified represents a list of file objects.,"

isFlavorJavaFileListType
public boolean isFlavorJavaFileListType()
Returns true if the DataFlavor specified represents
 a list of file objects.

Returns:
true if the DataFlavor specified represents
   a List of File objects


"
DataFlavor,isFlavorRemoteObjectType(),boolean,Returns true if the DataFlavor specified represents a remote object.,"

isFlavorRemoteObjectType
public boolean isFlavorRemoteObjectType()
Returns true if the DataFlavor specified represents
 a remote object.

Returns:
true if the DataFlavor specified represents
  a Remote Object


"
DataFlavor,isFlavorSerializedObjectType(),boolean,Returns true if the DataFlavor specified represents a serialized object.,"

isFlavorSerializedObjectType
public boolean isFlavorSerializedObjectType()
Returns true if the DataFlavor specified represents
 a serialized object.

Returns:
true if the DataFlavor specified represents
   a Serialized Object


"
DataFlavor,isFlavorTextType(),boolean,Returns whether this DataFlavor is a valid text flavor for this implementation of the Java platform.,"

isFlavorTextType
public boolean isFlavorTextType()
Returns whether this DataFlavor is a valid text flavor for
 this implementation of the Java platform. Only flavors equivalent to
 DataFlavor.stringFlavor and DataFlavors with
 a primary MIME type of ""text"" can be valid text flavors.
 
 If this flavor supports the charset parameter, it must be equivalent to
 DataFlavor.stringFlavor, or its representation must be
 java.io.Reader, java.lang.String,
 java.nio.CharBuffer, [C,
 java.io.InputStream, java.nio.ByteBuffer, or
 [B. If the representation is
 java.io.InputStream, java.nio.ByteBuffer, or
 [B, then this flavor's charset parameter must
 be supported by this implementation of the Java platform. If a charset
 is not specified, then the platform default charset, which is always
 supported, is assumed.
 
 If this flavor does not support the charset parameter, its
 representation must be java.io.InputStream,
 java.nio.ByteBuffer, or [B.
 
 See selectBestTextFlavor for a list of text flavors which
 support the charset parameter.

Returns:
true if this DataFlavor is a valid
         text flavor as described above; false otherwise
Since:
1.4
See Also:
selectBestTextFlavor(java.awt.datatransfer.DataFlavor[])


"
DataFlavor,isMimeTypeEqual(DataFlavor dataFlavor),boolean,Compares the mimeType of two DataFlavor objects.,"

isMimeTypeEqual
public final boolean isMimeTypeEqual(DataFlavor dataFlavor)
Compares the mimeType of two DataFlavor
 objects. No parameters are considered.

Parameters:
dataFlavor - the DataFlavor to be compared
Returns:
true if the MimeTypes are equal,
  otherwise false


"
DataFlavor,isMimeTypeEqual(String mimeType),boolean,Returns whether the string representation of the MIME type passed in is equivalent to the MIME type of this DataFlavor.,"

isMimeTypeEqual
public boolean isMimeTypeEqual(String mimeType)
Returns whether the string representation of the MIME type passed in
 is equivalent to the MIME type of this DataFlavor.
 Parameters are not included in the comparison.

Parameters:
mimeType - the string representation of the MIME type
Returns:
true if the string representation of the MIME type passed in is
         equivalent to the MIME type of this DataFlavor;
         false otherwise
Throws:
NullPointerException - if mimeType is null


"
DataFlavor,isMimeTypeSerializedObject(),boolean,Does the DataFlavor represent a serialized object?,"

isMimeTypeSerializedObject
public boolean isMimeTypeSerializedObject()
Does the DataFlavor represent a serialized object?

"
DataFlavor,isRepresentationClassByteBuffer(),boolean,Returns whether the representation class for this DataFlavor is java.nio.ByteBuffer or a subclass thereof.,"

isRepresentationClassByteBuffer
public boolean isRepresentationClassByteBuffer()
Returns whether the representation class for this
 DataFlavor is java.nio.ByteBuffer or a
 subclass thereof.

Since:
1.4


"
DataFlavor,isRepresentationClassCharBuffer(),boolean,Returns whether the representation class for this DataFlavor is java.nio.CharBuffer or a subclass thereof.,"

isRepresentationClassCharBuffer
public boolean isRepresentationClassCharBuffer()
Returns whether the representation class for this
 DataFlavor is java.nio.CharBuffer or a
 subclass thereof.

Since:
1.4


"
DataFlavor,isRepresentationClassInputStream(),boolean,Does the DataFlavor represent a java.io.InputStream?,"

isRepresentationClassInputStream
public boolean isRepresentationClassInputStream()
Does the DataFlavor represent a
 java.io.InputStream?

"
DataFlavor,isRepresentationClassReader(),boolean,Returns whether the representation class for this DataFlavor is java.io.Reader or a subclass thereof.,"

isRepresentationClassReader
public boolean isRepresentationClassReader()
Returns whether the representation class for this
 DataFlavor is java.io.Reader or a subclass
 thereof.

Since:
1.4


"
DataFlavor,isRepresentationClassRemote(),boolean,Returns true if the representation class is Remote.,"

isRepresentationClassRemote
public boolean isRepresentationClassRemote()
Returns true if the representation class is Remote.

Returns:
true if the representation class is Remote


"
DataFlavor,isRepresentationClassSerializable(),boolean,Returns true if the representation class can be serialized.,"

isRepresentationClassSerializable
public boolean isRepresentationClassSerializable()
Returns true if the representation class can be serialized.

Returns:
true if the representation class can be serialized


"
DataFlavor,match(DataFlavor that),boolean,Identical to equals(DataFlavor).,"

match
public boolean match(DataFlavor that)
Identical to equals(DataFlavor).

Parameters:
that - the DataFlavor to compare with
        this
Returns:
true if that is equivalent to this
         DataFlavor; false otherwise
Since:
1.3
See Also:
selectBestTextFlavor(java.awt.datatransfer.DataFlavor[])


"
DataFlavor,normalizeMimeType(String mimeType),protected String,Deprecated.,"

normalizeMimeType
@Deprecated
protected String normalizeMimeType(String mimeType)
Deprecated. 
Called for each MIME type string to give DataFlavor subtypes
 the opportunity to change how the normalization of MIME types is
 accomplished.  One possible use would be to add default
 parameter/value pairs in cases where none are present in the MIME
 type string passed in.

 This method is never invoked by this implementation from 1.1 onwards.

"
DataFlavor,"normalizeMimeTypeParameter(String parameterName, String parameterValue)",protected String,Deprecated.,"

normalizeMimeTypeParameter
@Deprecated
protected String normalizeMimeTypeParameter(String parameterName,
                                                        String parameterValue)
Deprecated. 
Called on DataFlavor for every MIME Type parameter
 to allow DataFlavor subclasses to handle special
 parameters like the text/plain charset
 parameters, whose values are case insensitive.  (MIME type parameter
 values are supposed to be case sensitive.
 
 This method is called for each parameter name/value pair and should
 return the normalized representation of the parameterValue.

 This method is never invoked by this implementation from 1.1 onwards.

"
DataFlavor,readExternal(ObjectInput is),void,Restores this DataFlavor from a Serialized state.,"

readExternal
public void readExternal(ObjectInput is)
                  throws IOException,
                         ClassNotFoundException
Restores this DataFlavor from a Serialized state.

Specified by:
readExternal in interface Externalizable
Parameters:
is - the stream to read data from in order to restore the object
Throws:
IOException - if I/O errors occur
ClassNotFoundException - If the class for an object being
              restored cannot be found.


"
DataFlavor,selectBestTextFlavor(DataFlavor[] availableFlavors),static DataFlavor,Selects the best text DataFlavor from an array of DataFlavors.,"

selectBestTextFlavor
public static final DataFlavor selectBestTextFlavor(DataFlavor[] availableFlavors)
Selects the best text DataFlavor from an array of 
 DataFlavors. Only DataFlavor.stringFlavor, and
 equivalent flavors, and flavors that have a primary MIME type of ""text"",
 are considered for selection.
 
 Flavors are first sorted by their MIME types in the following order:
 
""text/sgml""
 ""text/xml""
 ""text/html""
 ""text/rtf""
 ""text/enriched""
 ""text/richtext""
 ""text/uri-list""
 ""text/tab-separated-values""
 ""text/t140""
 ""text/rfc822-headers""
 ""text/parityfec""
 ""text/directory""
 ""text/css""
 ""text/calendar""
 ""application/x-java-serialized-object""
 ""text/plain""
 ""text/<other>""
 
For example, ""text/sgml"" will be selected over
 ""text/html"", and DataFlavor.stringFlavor will be chosen
 over DataFlavor.plainTextFlavor.
 
 If two or more flavors share the best MIME type in the array, then that
 MIME type will be checked to see if it supports the charset parameter.
 
 The following MIME types support, or are treated as though they support,
 the charset parameter:
 
""text/sgml""
 ""text/xml""
 ""text/html""
 ""text/enriched""
 ""text/richtext""
 ""text/uri-list""
 ""text/directory""
 ""text/css""
 ""text/calendar""
 ""application/x-java-serialized-object""
 ""text/plain""
 
 The following MIME types do not support, or are treated as though they
 do not support, the charset parameter:
 
""text/rtf""
 ""text/tab-separated-values""
 ""text/t140""
 ""text/rfc822-headers""
 ""text/parityfec""
 
 For ""text/<other>"" MIME types, the first time the JRE needs to
 determine whether the MIME type supports the charset parameter, it will
 check whether the parameter is explicitly listed in an arbitrarily
 chosen DataFlavor which uses that MIME type. If so, the JRE
 will assume from that point on that the MIME type supports the charset
 parameter and will not check again. If the parameter is not explicitly
 listed, the JRE will assume from that point on that the MIME type does
 not support the charset parameter and will not check again. Because
 this check is performed on an arbitrarily chosen
 DataFlavor, developers must ensure that all
 DataFlavors with a ""text/<other>"" MIME type specify
 the charset parameter if it is supported by that MIME type. Developers
 should never rely on the JRE to substitute the platform's default
 charset for a ""text/<other>"" DataFlavor. Failure to adhere to this
 restriction will lead to undefined behavior.
 
 If the best MIME type in the array does not support the charset
 parameter, the flavors which share that MIME type will then be sorted by
 their representation classes in the following order:
 java.io.InputStream, java.nio.ByteBuffer,
 [B, <all others>.
 
 If two or more flavors share the best representation class, or if no
 flavor has one of the three specified representations, then one of those
 flavors will be chosen non-deterministically.
 
 If the best MIME type in the array does support the charset parameter,
 the flavors which share that MIME type will then be sorted by their
 representation classes in the following order:
 java.io.Reader, java.lang.String,
 java.nio.CharBuffer, [C, <all others>.
 
 If two or more flavors share the best representation class, and that
 representation is one of the four explicitly listed, then one of those
 flavors will be chosen non-deterministically. If, however, no flavor has
 one of the four specified representations, the flavors will then be
 sorted by their charsets. Unicode charsets, such as ""UTF-16"", ""UTF-8"",
 ""UTF-16BE"", ""UTF-16LE"", and their aliases, are considered best. After
 them, the platform default charset and its aliases are selected.
 ""US-ASCII"" and its aliases are worst. All other charsets are chosen in
 alphabetical order, but only charsets supported by this implementation
 of the Java platform will be considered.
 
 If two or more flavors share the best charset, the flavors will then
 again be sorted by their representation classes in the following order:
 java.io.InputStream, java.nio.ByteBuffer,
 [B, <all others>.
 
 If two or more flavors share the best representation class, or if no
 flavor has one of the three specified representations, then one of those
 flavors will be chosen non-deterministically.

Parameters:
availableFlavors - an array of available DataFlavors
Returns:
the best (highest fidelity) flavor according to the rules
         specified above, or null,
         if availableFlavors is null,
         has zero length, or contains no text flavors
Since:
1.3


"
DataFlavor,setHumanPresentableName(String humanPresentableName),void,Sets the human presentable name for the data format that this DataFlavor represents.,"

setHumanPresentableName
public void setHumanPresentableName(String humanPresentableName)
Sets the human presentable name for the data format that this
 DataFlavor represents. This name would be localized
 for different countries.

Parameters:
humanPresentableName - the new human presentable name


"
DataFlavor,toString(),String,String representation of this DataFlavor and its parameters.,"

toString
public String toString()
String representation of this DataFlavor and its
 parameters. The resulting String contains the name of
 the DataFlavor class, this flavor's MIME type, and its
 representation class. If this flavor has a primary MIME type of ""text"",
 supports the charset parameter, and has an encoded representation, the
 flavor's charset is also included. See selectBestTextFlavor
 for a list of text flavors which support the charset parameter.

Overrides:
toString in class Object
Returns:
string representation of this DataFlavor
See Also:
selectBestTextFlavor(java.awt.datatransfer.DataFlavor[])


"
DataFlavor,"tryToLoadClass(String className, ClassLoader fallback)",protected static Class<?>,"Tries to load a class from: the bootstrap loader, the system loader, the context loader (if one is present) and finally the loader specified.","

tryToLoadClass
protected static final Class<?> tryToLoadClass(String className,
                                               ClassLoader fallback)
                                        throws ClassNotFoundException
Tries to load a class from: the bootstrap loader, the system loader,
 the context loader (if one is present) and finally the loader specified.

Parameters:
className - the name of the class to be loaded
fallback - the fallback loader
Returns:
the class loaded
Throws:
ClassNotFoundException - if class is not found


"
DataFlavor,writeExternal(ObjectOutput os),void,Serializes this DataFlavor.,"

writeExternal
public void writeExternal(ObjectOutput os)
                   throws IOException
Serializes this DataFlavor.

Specified by:
writeExternal in interface Externalizable
Parameters:
os - the stream to write the object to
Throws:
IOException - Includes any I/O exceptions that may occur


"
StringSelection,getTransferData(DataFlavor flavor),Object,Returns the Transferable's data in the requested DataFlavor if possible.,"

getTransferData
public Object getTransferData(DataFlavor flavor)
                       throws UnsupportedFlavorException,
                              IOException
Returns the Transferable's data in the requested
 DataFlavor if possible. If the desired flavor is
 DataFlavor.stringFlavor, or an equivalent flavor,
 the String representing the selection is
 returned. If the desired flavor is
 DataFlavor.plainTextFlavor,
 or an equivalent flavor, a Reader is returned.
 Note: The behavior of this method for
 DataFlavor.plainTextFlavor
 and equivalent DataFlavors is inconsistent with the
 definition of DataFlavor.plainTextFlavor.

Specified by:
getTransferData in interface Transferable
Parameters:
flavor - the requested flavor for the data
Returns:
the data in the requested flavor, as outlined above
Throws:
UnsupportedFlavorException - if the requested data flavor is
         not equivalent to either DataFlavor.stringFlavor
         or DataFlavor.plainTextFlavor
IOException - if an IOException occurs while retrieving the data.
         By default, StringSelection never throws this exception, but a
         subclass may.
NullPointerException - if flavor is null
See Also:
Reader


"
StringSelection,getTransferDataFlavors(),DataFlavor[],Returns an array of flavors in which this Transferable can provide the data.,"

getTransferDataFlavors
public DataFlavor[] getTransferDataFlavors()
Returns an array of flavors in which this Transferable
 can provide the data. DataFlavor.stringFlavor
 is properly supported.
 Support for DataFlavor.plainTextFlavor is
 deprecated.

Specified by:
getTransferDataFlavors in interface Transferable
Returns:
an array of length two, whose elements are DataFlavor.
         stringFlavor and DataFlavor.plainTextFlavor


"
StringSelection,isDataFlavorSupported(DataFlavor flavor),boolean,Returns whether the requested flavor is supported by this Transferable.,"

isDataFlavorSupported
public boolean isDataFlavorSupported(DataFlavor flavor)
Returns whether the requested flavor is supported by this
 Transferable.

Specified by:
isDataFlavorSupported in interface Transferable
Parameters:
flavor - the requested flavor for the data
Returns:
true if flavor is equal to
   DataFlavor.stringFlavor or
   DataFlavor.plainTextFlavor; false if flavor
   is not one of the above flavors
Throws:
NullPointerException - if flavor is null


"
StringSelection,"lostOwnership(Clipboard clipboard, Transferable contents)",void,Notifies this object that it is no longer the clipboard owner.,"

lostOwnership
public void lostOwnership(Clipboard clipboard,
                          Transferable contents)
Description copied from interface: ClipboardOwner
Notifies this object that it is no longer the clipboard owner.
 This method will be called when another application or another
 object within this application asserts ownership of the clipboard.

Specified by:
lostOwnership in interface ClipboardOwner
Parameters:
clipboard - the clipboard that is no longer owned
contents - the contents which this owner had placed on the clipboard


"
SystemFlavorMap,"addFlavorForUnencodedNative(String nat, DataFlavor flav)",void,Adds a mapping from a single String native to a single DataFlavor.,"

addFlavorForUnencodedNative
public void addFlavorForUnencodedNative(String nat,
                                        DataFlavor flav)
Adds a mapping from a single String native to a single
 DataFlavor. Unlike getFlavorsForNative, the
 mapping will only be established in one direction, and the native will
 not be encoded. To establish a two-way mapping, call
 addUnencodedNativeForFlavor as well. The new mapping will
 be of lower priority than any existing mapping.
 This method has no effect if a mapping from the specified
 String native to the specified or equal
 DataFlavor already exists.

Parameters:
nat - the String native key for the mapping
flav - the DataFlavor value for the mapping
Throws:
NullPointerException - if nat or flav is null
Since:
1.4
See Also:
addUnencodedNativeForFlavor(java.awt.datatransfer.DataFlavor, java.lang.String)


"
SystemFlavorMap,"addUnencodedNativeForFlavor(DataFlavor flav, String nat)",void,Adds a mapping from the specified DataFlavor (and all DataFlavors equal to the specified DataFlavor) to the specified String native.,"

addUnencodedNativeForFlavor
public void addUnencodedNativeForFlavor(DataFlavor flav,
                                        String nat)
Adds a mapping from the specified DataFlavor (and all
 DataFlavors equal to the specified DataFlavor)
 to the specified String native.
 Unlike getNativesForFlavor, the mapping will only be
 established in one direction, and the native will not be encoded. To
 establish a two-way mapping, call
 addFlavorForUnencodedNative as well. The new mapping will
 be of lower priority than any existing mapping.
 This method has no effect if a mapping from the specified or equal
 DataFlavor to the specified String native
 already exists.

Parameters:
flav - the DataFlavor key for the mapping
nat - the String native value for the mapping
Throws:
NullPointerException - if flav or nat is null
Since:
1.4
See Also:
addFlavorForUnencodedNative(java.lang.String, java.awt.datatransfer.DataFlavor)


"
SystemFlavorMap,decodeDataFlavor(String nat),static DataFlavor,Decodes a String native for use as a DataFlavor.,"

decodeDataFlavor
public static DataFlavor decodeDataFlavor(String nat)
                                   throws ClassNotFoundException
Decodes a String native for use as a
 DataFlavor.

Parameters:
nat - the String to decode
Returns:
the decoded DataFlavor, or null if
         nat is not an encoded String native
Throws:
ClassNotFoundException


"
SystemFlavorMap,decodeJavaMIMEType(String nat),static String,Decodes a String native for use as a Java MIME type.,"

decodeJavaMIMEType
public static String decodeJavaMIMEType(String nat)
Decodes a String native for use as a Java MIME type.

Parameters:
nat - the String to decode
Returns:
the decoded Java MIME type, or null if nat is not
         an encoded String native


"
SystemFlavorMap,encodeDataFlavor(DataFlavor flav),static String,Encodes a DataFlavor for use as a String native.,"

encodeDataFlavor
public static String encodeDataFlavor(DataFlavor flav)
Encodes a DataFlavor for use as a String
 native. The format of an encoded DataFlavor is
 implementation-dependent. The only restrictions are:
 
The encoded representation is null if and only if the
 specified DataFlavor is null or its MIME type
 String is null.
The encoded representations for two non-null
DataFlavors with non-null MIME type
 Strings are equal if and only if the MIME type
 Strings of these DataFlavors are equal
 according to String.equals(Object).


 The reference implementation of this method returns the MIME type
 String of the specified DataFlavor prefixed
 with JAVA_DATAFLAVOR:.

Parameters:
flav - the DataFlavor to encode
Returns:
the encoded String, or null if
         flav is null or has a null MIME type


"
SystemFlavorMap,encodeJavaMIMEType(String mimeType),static String,Encodes a MIME type for use as a String native.,"

encodeJavaMIMEType
public static String encodeJavaMIMEType(String mimeType)
Encodes a MIME type for use as a String native. The format
 of an encoded representation of a MIME type is implementation-dependent.
 The only restrictions are:
 
The encoded representation is null if and only if the
 MIME type String is null.
The encoded representations for two non-null MIME type
 Strings are equal if and only if these Strings
 are equal according to String.equals(Object).


 The reference implementation of this method returns the specified MIME
 type String prefixed with JAVA_DATAFLAVOR:.

Parameters:
mimeType - the MIME type to encode
Returns:
the encoded String, or null if
         mimeType is null


"
SystemFlavorMap,getDefaultFlavorMap(),static FlavorMap,Returns the default FlavorMap for this thread's ClassLoader.,"

getDefaultFlavorMap
public static FlavorMap getDefaultFlavorMap()
Returns the default FlavorMap for this thread's ClassLoader.

"
SystemFlavorMap,getFlavorsForNative(String nat),List<DataFlavor>,Returns a List of DataFlavors to which the specified String native can be translated by the data transfer subsystem.,"

getFlavorsForNative
public List<DataFlavor> getFlavorsForNative(String nat)
Returns a List of DataFlavors to which the
 specified String native can be translated by the data
 transfer subsystem. The List will be sorted from best
 DataFlavor to worst. That is, the first
 DataFlavor will best reflect data in the specified
 native to a Java application.
 
 If the specified native is previously unknown to the data transfer
 subsystem, and that native has been properly encoded, then invoking this
 method will establish a mapping in both directions between the specified
 native and a DataFlavor whose MIME type is a decoded
 version of the native.
 
 If the specified native is not a properly encoded native and the
 mappings for this native have not been altered with
 setFlavorsForNative, then the contents of the
 List is platform dependent, but null
 cannot be returned.

Specified by:
getFlavorsForNative in interface FlavorTable
Parameters:
nat - the native whose corresponding DataFlavors
        should be returned. If null is specified, all
        DataFlavors currently known to the data transfer
        subsystem are returned in a non-deterministic order.
Returns:
a java.util.List of DataFlavor
         objects into which platform-specific data in the specified,
         platform-specific native can be translated
Since:
1.4
See Also:
encodeJavaMIMEType(java.lang.String)


"
SystemFlavorMap,getFlavorsForNatives(String[] natives),"Map<String,DataFlavor>",Returns a Map of the specified String natives to their most preferred DataFlavor.,"

getFlavorsForNatives
public Map<String,DataFlavor> getFlavorsForNatives(String[] natives)
Returns a Map of the specified String natives
 to their most preferred DataFlavor. Each
 DataFlavor value will be the same as the first
 DataFlavor in the List returned by
 getFlavorsForNative for the specified native.
 
 If a specified native is previously unknown to the data transfer
 subsystem, and that native has been properly encoded, then invoking this
 method will establish a mapping in both directions between the specified
 native and a DataFlavor whose MIME type is a decoded
 version of the native.

Specified by:
getFlavorsForNatives in interface FlavorMap
Parameters:
natives - an array of Strings which will be the
        key set of the returned Map. If null is
        specified, a mapping of all supported String natives
        to their most preferred DataFlavors will be
        returned.
Returns:
a java.util.Map of String natives to
         DataFlavors
See Also:
getFlavorsForNative(java.lang.String), 
encodeJavaMIMEType(java.lang.String)


"
SystemFlavorMap,getNativesForFlavor(DataFlavor flav),List<String>,Returns a List of String natives to which the specified DataFlavor can be translated by the data transfer subsystem.,"

getNativesForFlavor
public List<String> getNativesForFlavor(DataFlavor flav)
Returns a List of String natives to which the
 specified DataFlavor can be translated by the data transfer
 subsystem. The List will be sorted from best native to
 worst. That is, the first native will best reflect data in the specified
 flavor to the underlying native platform.
 
 If the specified DataFlavor is previously unknown to the
 data transfer subsystem and the data transfer subsystem is unable to
 translate this DataFlavor to any existing native, then
 invoking this method will establish a
 mapping in both directions between the specified DataFlavor
 and an encoded version of its MIME type as its native.

Specified by:
getNativesForFlavor in interface FlavorTable
Parameters:
flav - the DataFlavor whose corresponding natives
        should be returned. If null is specified, all
        natives currently known to the data transfer subsystem are
        returned in a non-deterministic order.
Returns:
a java.util.List of java.lang.String
         objects which are platform-specific representations of platform-
         specific data formats
Since:
1.4
See Also:
encodeDataFlavor(java.awt.datatransfer.DataFlavor)


"
SystemFlavorMap,getNativesForFlavors(DataFlavor[] flavors),"Map<DataFlavor,String>",Returns a Map of the specified DataFlavors to their most preferred String native.,"

getNativesForFlavors
public Map<DataFlavor,String> getNativesForFlavors(DataFlavor[] flavors)
Returns a Map of the specified DataFlavors to
 their most preferred String native. Each native value will
 be the same as the first native in the List returned by
 getNativesForFlavor for the specified flavor.
 
 If a specified DataFlavor is previously unknown to the
 data transfer subsystem, then invoking this method will establish a
 mapping in both directions between the specified DataFlavor
 and an encoded version of its MIME type as its native.

Specified by:
getNativesForFlavors in interface FlavorMap
Parameters:
flavors - an array of DataFlavors which will be the
        key set of the returned Map. If null is
        specified, a mapping of all DataFlavors known to the
        data transfer subsystem to their most preferred
        String natives will be returned.
Returns:
a java.util.Map of DataFlavors to
         String natives
See Also:
getNativesForFlavor(java.awt.datatransfer.DataFlavor), 
encodeDataFlavor(java.awt.datatransfer.DataFlavor)


"
SystemFlavorMap,isJavaMIMEType(String str),static boolean,Returns whether the specified String is an encoded Java MIME type.,"

isJavaMIMEType
public static boolean isJavaMIMEType(String str)
Returns whether the specified String is an encoded Java
 MIME type.

Parameters:
str - the String to test
Returns:
true if the String is encoded;
         false otherwise


"
SystemFlavorMap,"setFlavorsForNative(String nat, DataFlavor[] flavors)",void,"Discards the current mappings for the specified String native, and creates new mappings to the specified DataFlavors.","

setFlavorsForNative
public void setFlavorsForNative(String nat,
                                DataFlavor[] flavors)
Discards the current mappings for the specified String
 native, and creates new mappings to the specified
 DataFlavors. Unlike getFlavorsForNative, the
 mappings will only be established in one direction, and the natives need
 not be encoded. To establish two-way mappings, call
 setNativesForFlavor as well. The first
 DataFlavor in the array will represent the highest priority
 mapping. Subsequent DataFlavors will represent mappings of
 decreasing priority.
 
 If the array contains several elements that reference equal
 DataFlavors, this method will establish new mappings
 for the first of those elements and ignore the rest of them.
 
 It is recommended that client code not reset mappings established by the
 data transfer subsystem. This method should only be used for
 application-level mappings.

Parameters:
nat - the String native key for the mappings
flavors - the DataFlavor values for the mappings
Throws:
NullPointerException - if nat or flavors is null
         or if flavors contains null elements
Since:
1.4
See Also:
setNativesForFlavor(java.awt.datatransfer.DataFlavor, java.lang.String[])


"
SystemFlavorMap,"setNativesForFlavor(DataFlavor flav, String[] natives)",void,"Discards the current mappings for the specified DataFlavor and all DataFlavors equal to the specified DataFlavor, and creates new mappings to the specified String natives.","

setNativesForFlavor
public void setNativesForFlavor(DataFlavor flav,
                                String[] natives)
Discards the current mappings for the specified DataFlavor
 and all DataFlavors equal to the specified
 DataFlavor, and creates new mappings to the
 specified String natives.
 Unlike getNativesForFlavor, the mappings will only be
 established in one direction, and the natives will not be encoded. To
 establish two-way mappings, call setFlavorsForNative
 as well. The first native in the array will represent the highest
 priority mapping. Subsequent natives will represent mappings of
 decreasing priority.
 
 If the array contains several elements that reference equal
 String natives, this method will establish new mappings
 for the first of those elements and ignore the rest of them.
 
 It is recommended that client code not reset mappings established by the
 data transfer subsystem. This method should only be used for
 application-level mappings.

Parameters:
flav - the DataFlavor key for the mappings
natives - the String native values for the mappings
Throws:
NullPointerException - if flav or natives is null
         or if natives contains null elements
Since:
1.4
See Also:
setFlavorsForNative(java.lang.String, java.awt.datatransfer.DataFlavor[])


"
