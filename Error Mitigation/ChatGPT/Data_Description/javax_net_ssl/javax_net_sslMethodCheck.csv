Sample Number,ClassName,Snippet Number,Method,Exist,Description,Full Description
0,CertPathTrustManagerParameters,1,CertPathTrustManagerParameters getParameters(),False,,NULL
0,CertPathTrustManagerParameters,2,void setParameters(CertPathParameters parameters),False,,NULL
0,CertPathTrustManagerParameters,3,boolean equals(Object obj),False,,NULL
0,CertPathTrustManagerParameters,4,int hashCode(),False,,NULL
0,CertPathTrustManagerParameters,5,String toString(),False,,NULL
1,ExtendedSSLSession,1,String getLocalPrincipal(),False,,NULL
1,ExtendedSSLSession,2,String getPeerPrincipal(),False,,NULL
1,ExtendedSSLSession,3,String getCipherSuite(),False,,NULL
1,ExtendedSSLSession,4,String getProtocol(),False,,NULL
1,ExtendedSSLSession,5,byte[] getId(),False,,NULL
2,HandshakeCompletedEvent,1,SSLSession getSession(),True,,"

getSession
public SSLSession getSession()
Returns the session that triggered this event.

Returns:
the SSLSession for this handshake


"
2,HandshakeCompletedEvent,2,String getCipherSuite(),True,,"

getCipherSuite
public String getCipherSuite()
Returns the cipher suite in use by the session which was produced
 by the handshake.  (This is a convenience method for
 getting the ciphersuite from the SSLsession.)

Returns:
the name of the cipher suite negotiated during this session.


"
2,HandshakeCompletedEvent,3,X509Certificate[] getLocalCertificates(),False,,NULL
2,HandshakeCompletedEvent,4,X509Certificate[] getPeerCertificates(),False,,NULL
2,HandshakeCompletedEvent,5,Principal getPeerPrincipal(),True,,"

getPeerPrincipal
public Principal getPeerPrincipal()
                           throws SSLPeerUnverifiedException
Returns the identity of the peer which was established as part of
 defining the session.

Returns:
the peer's principal. Returns an X500Principal of the
 end-entity certiticate for X509-based cipher suites, and
 KerberosPrincipal for Kerberos cipher suites.
Throws:
SSLPeerUnverifiedException - if the peer's identity has not
          been verified
Since:
1.5
See Also:
getPeerCertificates(), 
getLocalPrincipal()


"
3,HttpsURLConnection,1,void setHostnameVerifier(HostnameVerifier verifier),True,,"

setHostnameVerifier
public void setHostnameVerifier(HostnameVerifier v)
Sets the HostnameVerifier for this instance.
 
 New instances of this class inherit the default static hostname
 verifier set by setDefaultHostnameVerifier.  Calls to this method replace
 this object's HostnameVerifier.

Parameters:
v - the host name verifier
Throws:
IllegalArgumentException - if the HostnameVerifier
  parameter is null.
See Also:
getHostnameVerifier(), 
setDefaultHostnameVerifier(HostnameVerifier)


"
3,HttpsURLConnection,2,void setSSLSocketFactory(SSLSocketFactory factory),True,,"

setSSLSocketFactory
public void setSSLSocketFactory(SSLSocketFactory sf)
Sets the SSLSocketFactory to be used when this instance
 creates sockets for secure https URL connections.
 
 New instances of this class inherit the default static
 SSLSocketFactory set by
 setDefaultSSLSocketFactory.  Calls to this method replace
 this object's SSLSocketFactory.

Parameters:
sf - the SSL socket factory
Throws:
IllegalArgumentException - if the SSLSocketFactory
          parameter is null.
SecurityException - if a security manager exists and its
         checkSetFactory method does not allow
         a socket factory to be specified.
See Also:
getSSLSocketFactory()


"
3,HttpsURLConnection,3,void setDefaultSSLSocketFactory(SSLSocketFactory factory),True,,"

setDefaultSSLSocketFactory
public static void setDefaultSSLSocketFactory(SSLSocketFactory sf)
Sets the default SSLSocketFactory inherited by new
 instances of this class.
 
 The socket factories are used when creating sockets for secure
 https URL connections.

Parameters:
sf - the default SSL socket factory
Throws:
IllegalArgumentException - if the SSLSocketFactory
          parameter is null.
SecurityException - if a security manager exists and its
         checkSetFactory method does not allow
         a socket factory to be specified.
See Also:
getDefaultSSLSocketFactory()


"
3,HttpsURLConnection,4,void setDefaultHostnameVerifier(HostnameVerifier verifier),True,,"

setDefaultHostnameVerifier
public static void setDefaultHostnameVerifier(HostnameVerifier v)
Sets the default HostnameVerifier inherited by a
 new instance of this class.
 
 If this method is not called, the default
 HostnameVerifier assumes the connection should not
 be permitted.

Parameters:
v - the default host name verifier
Throws:
IllegalArgumentException - if the HostnameVerifier
          parameter is null.
SecurityException - if a security manager exists and its
         checkPermission method does not allow
         SSLPermission(""setHostnameVerifier"")
See Also:
getDefaultHostnameVerifier()


"
3,HttpsURLConnection,5,void setSSLSocketFactory(SSLSocketFactory factory),True,,"

setSSLSocketFactory
public void setSSLSocketFactory(SSLSocketFactory sf)
Sets the SSLSocketFactory to be used when this instance
 creates sockets for secure https URL connections.
 
 New instances of this class inherit the default static
 SSLSocketFactory set by
 setDefaultSSLSocketFactory.  Calls to this method replace
 this object's SSLSocketFactory.

Parameters:
sf - the SSL socket factory
Throws:
IllegalArgumentException - if the SSLSocketFactory
          parameter is null.
SecurityException - if a security manager exists and its
         checkSetFactory method does not allow
         a socket factory to be specified.
See Also:
getSSLSocketFactory()


"
4,KeyManagerFactory,1,KeyManagerFactory getInstance(String algorithm),True,,"

getInstance
public static final KeyManagerFactory getInstance(String algorithm)
                                           throws NoSuchAlgorithmException
Returns a KeyManagerFactory object that acts as a
 factory for key managers.

  This method traverses the list of registered security Providers,
 starting with the most preferred Provider.
 A new KeyManagerFactory object encapsulating the
 KeyManagerFactorySpi implementation from the first
 Provider that supports the specified algorithm is returned.

  Note that the list of registered providers may be retrieved via
 the Security.getProviders() method.

Parameters:
algorithm - the standard name of the requested algorithm.
          See the 
          Java Secure Socket Extension Reference Guide 
          for information about standard algorithm names.
Returns:
the new KeyManagerFactory object.
Throws:
NoSuchAlgorithmException - if no Provider supports a
          KeyManagerFactorySpi implementation for the
          specified algorithm.
NullPointerException - if algorithm is null.
See Also:
Provider


"
4,KeyManagerFactory,2,"void init(KeyStore ks, char[] password)",True,,"

init
public final void init(KeyStore ks,
                       char[] password)
                throws KeyStoreException,
                       NoSuchAlgorithmException,
                       UnrecoverableKeyException
Initializes this factory with a source of key material.
 
 The provider typically uses a KeyStore for obtaining
 key material for use during secure socket negotiations.
 The KeyStore is generally password-protected.
 
 For more flexible initialization, please see
 init(ManagerFactoryParameters).
 

Parameters:
ks - the key store or null
password - the password for recovering keys in the KeyStore
Throws:
KeyStoreException - if this operation fails
NoSuchAlgorithmException - if the specified algorithm is not
          available from the specified provider.
UnrecoverableKeyException - if the key cannot be recovered
          (e.g. the given password is wrong).


"
4,KeyManagerFactory,3,KeyManager[] getKeyManagers(),True,,"

getKeyManagers
public final KeyManager[] getKeyManagers()
Returns one key manager for each type of key material.

Returns:
the key managers
Throws:
IllegalStateException - if the KeyManagerFactory is not initialized


"
4,KeyManagerFactory,4,String getAlgorithm(),True,,"

getAlgorithm
public final String getAlgorithm()
Returns the algorithm name of this KeyManagerFactory object.

 This is the same name that was specified in one of the
 getInstance calls that created this
 KeyManagerFactory object.

Returns:
the algorithm name of this KeyManagerFactory object.


"
4,KeyManagerFactory,5,void init(ManagerFactoryParameters spec),True,,"

init
public final void init(ManagerFactoryParameters spec)
                throws InvalidAlgorithmParameterException
Initializes this factory with a source of provider-specific
 key material.
 
 In some cases, initialization parameters other than a keystore
 and password may be needed by a provider.  Users of that
 particular provider are expected to pass an implementation of
 the appropriate ManagerFactoryParameters as
 defined by the provider.  The provider can then call the
 specified methods in the ManagerFactoryParameters
 implementation to obtain the needed information.

Parameters:
spec - an implementation of a provider-specific parameter
          specification
Throws:
InvalidAlgorithmParameterException - if an error is encountered


"
5,KeyManagerFactorySpi,1,KeyManager[] engineGetKeyManagers(),True,,"

engineGetKeyManagers
protected abstract KeyManager[] engineGetKeyManagers()
Returns one key manager for each type of key material.

Returns:
the key managers
Throws:
IllegalStateException - if the KeyManagerFactorySpi is not initialized


"
5,KeyManagerFactorySpi,2,"void engineInit(KeyStore ks, char[] password)",True,,"

engineInit
protected abstract void engineInit(KeyStore ks,
                                   char[] password)
                            throws KeyStoreException,
                                   NoSuchAlgorithmException,
                                   UnrecoverableKeyException
Initializes this factory with a source of key material.

Parameters:
ks - the key store or null
password - the password for recovering keys
Throws:
KeyStoreException - if this operation fails
NoSuchAlgorithmException - if the specified algorithm is not
          available from the specified provider.
UnrecoverableKeyException - if the key cannot be recovered
See Also:
KeyManagerFactory.init(KeyStore, char[])


"
5,KeyManagerFactorySpi,3,void engineInit(ManagerFactoryParameters spec),True,,"

engineInit
protected abstract void engineInit(ManagerFactoryParameters spec)
                            throws InvalidAlgorithmParameterException
Initializes this factory with a source of key material.
 
 In some cases, initialization parameters other than a keystore
 and password may be needed by a provider.  Users of that
 particular provider are expected to pass an implementation of
 the appropriate ManagerFactoryParameters as
 defined by the provider.  The provider can then call the
 specified methods in the ManagerFactoryParameters
 implementation to obtain the needed information.

Parameters:
spec - an implementation of a provider-specific parameter
          specification
Throws:
InvalidAlgorithmParameterException - if there is problem
          with the parameters
See Also:
KeyManagerFactory.init(ManagerFactoryParameters spec)


"
5,KeyManagerFactorySpi,4,String engineToString(),False,,NULL
5,KeyManagerFactorySpi,5,KeyManagerFactorySpi(),False,,NULL
6,KeyStoreBuilderParameters,1,List<KeyStore.Builder> getKeyStoreBuilders(),False,,NULL
6,KeyStoreBuilderParameters,2,int hashCode(),False,,NULL
6,KeyStoreBuilderParameters,3,boolean equals(Object obj),False,,NULL
6,KeyStoreBuilderParameters,4,String toString(),False,,NULL
6,KeyStoreBuilderParameters,5,KeyStoreBuilderParameters(List<KeyStore.Builder> keyStoreBuilders),False,,NULL
7,SNIHostName,1,String getAsciiName(),True,,"

getAsciiName
public String getAsciiName()
Returns the StandardCharsets.US_ASCII-compliant hostname of
 this SNIHostName object.
 
 Note that, per
 RFC 6066, the
 returned hostname may be an internationalized domain name that
 contains A-labels. See
 RFC 5890
 for more information about the detailed A-label specification.

Returns:
the StandardCharsets.US_ASCII-compliant hostname
         of this SNIHostName object


"
7,SNIHostName,2,byte[] getEncoded(),False,,NULL
7,SNIHostName,3,boolean equals(Object obj),True,,"

equals
public boolean equals(Object other)
Compares this server name to the specified object.
 
 Per RFC 6066, DNS
 hostnames are case-insensitive.  Two server hostnames are equal if,
 and only if, they have the same name type, and the hostnames are
 equal in a case-independent comparison.

Overrides:
equals in class SNIServerName
Parameters:
other - the other server name object to compare with.
Returns:
true if, and only if, the other is considered
         equal to this instance
See Also:
Object.hashCode(), 
HashMap


"
7,SNIHostName,4,int hashCode(),True,,"

hashCode
public int hashCode()
Returns a hash code value for this SNIHostName.
 
 The hash code value is generated using the case-insensitive hostname
 of this SNIHostName.

Overrides:
hashCode in class SNIServerName
Returns:
a hash code value for this SNIHostName.
See Also:
Object.equals(java.lang.Object), 
System.identityHashCode(java.lang.Object)


"
7,SNIHostName,5,String toString(),True,,"

toString
public String toString()
Returns a string representation of the object, including the DNS
 hostname in this SNIHostName object.
 
 The exact details of the representation are unspecified and subject
 to change, but the following may be regarded as typical:
 
     ""type=host_name (0), value= <hostname>""
 
 The ""<hostname>"" is an ASCII representation of the hostname,
 which may contains A-labels.  For example, a returned value of an pseudo
 hostname may look like:
 
     ""type=host_name (0), value=www.example.com""
 
 or
 
     ""type=host_name (0), value=xn--fsqu00a.xn--0zwm56d""
 

 Please NOTE that the exact details of the representation are unspecified
 and subject to change.

Overrides:
toString in class SNIServerName
Returns:
a string representation of the object.


"
8,SNIMatcher,1,SNIMatcher clone(),False,,NULL
8,SNIMatcher,2,boolean matches(SNIServerName serverName),True,,"

matches
public abstract boolean matches(SNIServerName serverName)
Attempts to match the given SNIServerName.

Parameters:
serverName - the SNIServerName instance on which this matcher
         performs match operations
Returns:
true if, and only if, the matcher matches the
         given serverName
Throws:
NullPointerException - if serverName is null
IllegalArgumentException - if serverName is
         not of the given server name type of this matcher
See Also:
SNIServerName


"
8,SNIMatcher,3,int type(),False,,NULL
8,SNIMatcher,4,String toString(),False,,NULL
8,SNIMatcher,5,boolean equals(Object obj),False,,NULL
9,SNIServerName,1,String getType(),False,,NULL
9,SNIServerName,2,byte[] getEncoded(),True,,"

getEncoded
public final byte[] getEncoded()
Returns a copy of the encoded server name value of this server name.

Returns:
a copy of the encoded server name value of this server name


"
9,SNIServerName,3,String toString(),True,,"

toString
public String toString()
Returns a string representation of this server name, including the server
 name type and the encoded server name value in this
 SNIServerName object.
 
 The exact details of the representation are unspecified and subject
 to change, but the following may be regarded as typical:
 
     ""type= <name type>, value= <name value>""
 

 In this class, the format of ""<name type>"" is
 ""[LITERAL] (INTEGER)"", where the optional ""LITERAL"" is the literal
 name, and INTEGER is the integer value of the name type.  The format
 of ""<name value>"" is ""XX:...:XX"", where ""XX"" is the
 hexadecimal digit representation of a byte value. For example, a
 returned value of an pseudo server name may look like:
 
     ""type=(31), value=77:77:77:2E:65:78:61:6D:70:6C:65:2E:63:6E""
 
 or
 
     ""type=host_name (0), value=77:77:77:2E:65:78:61:6D:70:6C:65:2E:63:6E""
 

 Please NOTE that the exact details of the representation are unspecified
 and subject to change, and subclasses may override the method with
 their own formats.

Overrides:
toString in class Object
Returns:
a string representation of this server name


"
9,SNIServerName,4,boolean equals(Object obj),True,,"

equals
public boolean equals(Object other)
Indicates whether some other object is ""equal to"" this server name.

Overrides:
equals in class Object
Parameters:
other - the reference object with which to compare.
Returns:
true if, and only if, other is of the same class
         of this object, and has the same name type and
         encoded value as this server name.
See Also:
Object.hashCode(), 
HashMap


"
9,SNIServerName,5,int hashCode(),True,,"

hashCode
public int hashCode()
Returns a hash code value for this server name.
 
 The hash code value is generated using the name type and encoded
 value of this server name.

Overrides:
hashCode in class Object
Returns:
a hash code value for this server name.
See Also:
Object.equals(java.lang.Object), 
System.identityHashCode(java.lang.Object)


"
10,SSLContext,1,SSLContext getInstance(String protocol),True,,"

getInstance
public static SSLContext getInstance(String protocol)
                              throws NoSuchAlgorithmException
Returns a SSLContext object that implements the
 specified secure socket protocol.

  This method traverses the list of registered security Providers,
 starting with the most preferred Provider.
 A new SSLContext object encapsulating the
 SSLContextSpi implementation from the first
 Provider that supports the specified protocol is returned.

  Note that the list of registered providers may be retrieved via
 the Security.getProviders() method.

Parameters:
protocol - the standard name of the requested protocol.
          See the SSLContext section in the 
          Java Cryptography Architecture Standard Algorithm Name
          Documentation
          for information about standard protocol names.
Returns:
the new SSLContext object.
Throws:
NoSuchAlgorithmException - if no Provider supports a
          SSLContextSpi implementation for the
          specified protocol.
NullPointerException - if protocol is null.
See Also:
Provider


"
10,SSLContext,2,"void init(KeyManager[] km, TrustManager[] tm, SecureRandom random) throws KeyManagementException",True,,"

init
public final void init(KeyManager[] km,
                       TrustManager[] tm,
                       SecureRandom random)
                throws KeyManagementException
Initializes this context. Either of the first two parameters
 may be null in which case the installed security providers will
 be searched for the highest priority implementation of the
 appropriate factory. Likewise, the secure random parameter may
 be null in which case the default implementation will be used.
 
 Only the first instance of a particular key and/or trust manager
 implementation type in the array is used.  (For example, only
 the first javax.net.ssl.X509KeyManager in the array will be used.)

Parameters:
km - the sources of authentication keys or null
tm - the sources of peer authentication trust decisions or null
random - the source of randomness for this generator or null
Throws:
KeyManagementException - if this operation fails


"
10,SSLContext,3,SSLSocketFactory getSocketFactory(),True,,"

getSocketFactory
public final SSLSocketFactory getSocketFactory()
Returns a SocketFactory object for this
 context.

Returns:
the SocketFactory object
Throws:
IllegalStateException - if the SSLContextImpl requires
          initialization and the init() has not been called


"
10,SSLContext,4,SSLServerSocketFactory getServerSocketFactory(),True,,"

getServerSocketFactory
public final SSLServerSocketFactory getServerSocketFactory()
Returns a ServerSocketFactory object for
 this context.

Returns:
the ServerSocketFactory object
Throws:
IllegalStateException - if the SSLContextImpl requires
          initialization and the init() has not been called


"
10,SSLContext,5,SSLEngine createSSLEngine(),True,,"

createSSLEngine
public final SSLEngine createSSLEngine()
Creates a new SSLEngine using this context.
 
 Applications using this factory method are providing no hints
 for an internal session reuse strategy. If hints are desired,
 createSSLEngine(String, int) should be used
 instead.
 
 Some cipher suites (such as Kerberos) require remote hostname
 information, in which case this factory method should not be used.

Returns:
the SSLEngine object
Throws:
UnsupportedOperationException - if the underlying provider
          does not implement the operation.
IllegalStateException - if the SSLContextImpl requires
          initialization and the init() has not been called
Since:
1.5


"
11,SSLContextSpi,1,"SSLContextSpi engineInit(KeyManager[] km, TrustManager[] tm, SecureRandom sr)",False,,NULL
11,SSLContextSpi,2,SSLSocketFactory engineGetSocketFactory(),True,,"

engineGetSocketFactory
protected abstract SSLSocketFactory engineGetSocketFactory()
Returns a SocketFactory object for this
 context.

Returns:
the SocketFactory object
Throws:
IllegalStateException - if the SSLContextImpl requires
         initialization and the engineInit()
         has not been called
See Also:
SSLContext.getSocketFactory()


"
11,SSLContextSpi,3,SSLServerSocketFactory engineGetServerSocketFactory(),True,,"

engineGetServerSocketFactory
protected abstract SSLServerSocketFactory engineGetServerSocketFactory()
Returns a ServerSocketFactory object for
 this context.

Returns:
the ServerSocketFactory object
Throws:
IllegalStateException - if the SSLContextImpl requires
         initialization and the engineInit()
         has not been called
See Also:
SSLContext.getServerSocketFactory()


"
11,SSLContextSpi,4,SSLSessionContext engineGetServerSessionContext(),True,,"

engineGetServerSessionContext
protected abstract SSLSessionContext engineGetServerSessionContext()
Returns a server SSLSessionContext object for
 this context.

Returns:
the SSLSessionContext object
See Also:
SSLContext.getServerSessionContext()


"
11,SSLContextSpi,5,SSLSessionContext engineGetClientSessionContext(),True,,"

engineGetClientSessionContext
protected abstract SSLSessionContext engineGetClientSessionContext()
Returns a client SSLSessionContext object for
 this context.

Returns:
the SSLSessionContext object
See Also:
SSLContext.getClientSessionContext()


"
12,SSLEngine,1,void beginHandshake(),True,,"

beginHandshake
public abstract void beginHandshake()
                             throws SSLException
Initiates handshaking (initial or renegotiation) on this SSLEngine.
 
 This method is not needed for the initial handshake, as the
 wrap() and unwrap() methods will
 implicitly call this method if handshaking has not already begun.
 
 Note that the peer may also request a session renegotiation with
 this SSLEngine by sending the appropriate
 session renegotiate handshake message.
 
 Unlike the SSLSocket#startHandshake() method, this method does not block
 until handshaking is completed.
 
 To force a complete SSL/TLS session renegotiation, the current
 session should be invalidated prior to calling this method.
 
 Some protocols may not support multiple handshakes on an existing
 engine and may throw an SSLException.

Throws:
SSLException - if a problem was encountered while signaling the
          SSLEngine to begin a new handshake.
          See the class description for more information on
          engine closure.
IllegalStateException - if the client/server mode
          has not yet been set.
See Also:
SSLSession.invalidate()


"
12,SSLEngine,2,"SSLEngineResult wrap(ByteBuffer[] srcs, int offset, int length, ByteBuffer dst)",True,,"

wrap
public abstract SSLEngineResult wrap(ByteBuffer[] srcs,
                                     int offset,
                                     int length,
                                     ByteBuffer dst)
                              throws SSLException
Attempts to encode plaintext bytes from a subsequence of data
 buffers into SSL/TLS network data.  This ""gathering""
 operation encodes, in a single invocation, a sequence of bytes
 from one or more of a given sequence of buffers.  Gathering
 wraps are often useful when implementing network protocols or
 file formats that, for example, group data into segments
 consisting of one or more fixed-length headers followed by a
 variable-length body.  See
 GatheringByteChannel for more
 information on gathering, and GatheringByteChannel.write(ByteBuffer[],
 int, int) for more information on the subsequence
 behavior.
 
 Depending on the state of the SSLEngine, this method may produce
 network data without consuming any application data (for example,
 it may generate handshake data.)
 
 The application is responsible for reliably transporting the
 network data to the peer, and for ensuring that data created by
 multiple calls to wrap() is transported in the same order in which
 it was generated.  The application must properly synchronize
 multiple calls to this method.
 
 If this SSLEngine has not yet started its initial
 handshake, this method will automatically start the handshake.
 
 This method will attempt to produce SSL/TLS records, and will
 consume as much source data as possible, but will never consume
 more than the sum of the bytes remaining in each buffer.  Each
 ByteBuffer's position is updated to reflect the
 amount of data consumed or produced.  The limits remain the
 same.
 
 The underlying memory used by the srcs and
 dst ByteBuffers must not be the same.
 
 See the class description for more information on engine closure.

Parameters:
srcs - an array of ByteBuffers containing the
          outbound application data
offset - The offset within the buffer array of the first buffer from
          which bytes are to be retrieved; it must be non-negative
          and no larger than srcs.length
length - The maximum number of buffers to be accessed; it must be
          non-negative and no larger than
          srcs.length - offset
dst - a ByteBuffer to hold outbound network data
Returns:
an SSLEngineResult describing the result
          of this operation.
Throws:
SSLException - A problem was encountered while processing the
          data that caused the SSLEngine to abort.
          See the class description for more information on
          engine closure.
IndexOutOfBoundsException - if the preconditions on the offset and
          length parameters do not hold.
ReadOnlyBufferException - if the dst buffer is read-only.
IllegalArgumentException - if either srcs or dst
          is null, or if any element in the srcs
          subsequence specified is null.
IllegalStateException - if the client/server mode
          has not yet been set.
See Also:
GatheringByteChannel, 
GatheringByteChannel.write(
              ByteBuffer[], int, int)


"
12,SSLEngine,3,"SSLEngineResult unwrap(ByteBuffer src, ByteBuffer[] dsts, int offset, int length)",True,,"

unwrap
public abstract SSLEngineResult unwrap(ByteBuffer src,
                                       ByteBuffer[] dsts,
                                       int offset,
                                       int length)
                                throws SSLException
Attempts to decode SSL/TLS network data into a subsequence of
 plaintext application data buffers.  This ""scattering""
 operation decodes, in a single invocation, a sequence of bytes
 into one or more of a given sequence of buffers.  Scattering
 unwraps are often useful when implementing network protocols or
 file formats that, for example, group data into segments
 consisting of one or more fixed-length headers followed by a
 variable-length body.  See
 ScatteringByteChannel for more
 information on scattering, and ScatteringByteChannel.read(ByteBuffer[],
 int, int) for more information on the subsequence
 behavior.
 
 Depending on the state of the SSLEngine, this method may consume
 network data without producing any application data (for example,
 it may consume handshake data.)
 
 The application is responsible for reliably obtaining the network
 data from the peer, and for invoking unwrap() on the data in the
 order it was received.  The application must properly synchronize
 multiple calls to this method.
 
 If this SSLEngine has not yet started its initial
 handshake, this method will automatically start the handshake.
 
 This method will attempt to consume one complete SSL/TLS network
 packet, but will never consume more than the sum of the bytes
 remaining in the buffers.  Each ByteBuffer's
 position is updated to reflect the amount of data consumed or
 produced.  The limits remain the same.
 
 The underlying memory used by the src and
 dsts ByteBuffers must not be the same.
 
 The inbound network buffer may be modified as a result of this
 call:  therefore if the network data packet is required for some
 secondary purpose, the data should be duplicated before calling this
 method.  Note:  the network data will not be useful to a second
 SSLEngine, as each SSLEngine contains unique random state which
 influences the SSL/TLS messages.
 
 See the class description for more information on engine closure.

Parameters:
src - a ByteBuffer containing inbound network data.
dsts - an array of ByteBuffers to hold inbound
          application data.
offset - The offset within the buffer array of the first buffer from
          which bytes are to be transferred; it must be non-negative
          and no larger than dsts.length.
length - The maximum number of buffers to be accessed; it must be
          non-negative and no larger than
          dsts.length - offset.
Returns:
an SSLEngineResult describing the result
          of this operation.
Throws:
SSLException - A problem was encountered while processing the
          data that caused the SSLEngine to abort.
          See the class description for more information on
          engine closure.
IndexOutOfBoundsException - If the preconditions on the offset and
          length parameters do not hold.
ReadOnlyBufferException - if any of the dst buffers are read-only.
IllegalArgumentException - if either src or dsts
          is null, or if any element in the dsts
          subsequence specified is null.
IllegalStateException - if the client/server mode
          has not yet been set.
See Also:
ScatteringByteChannel, 
ScatteringByteChannel.read(
              ByteBuffer[], int, int)


"
12,SSLEngine,4,void closeInbound(),True,,"

closeInbound
public abstract void closeInbound()
                           throws SSLException
Signals that no more inbound network data will be sent
 to this SSLEngine.
 
 If the application initiated the closing process by calling
 closeOutbound(), under some circumstances it is not
 required that the initiator wait for the peer's corresponding
 close message.  (See section 7.2.1 of the TLS specification (RFC 2246) for more
 information on waiting for closure alerts.)  In such cases, this
 method need not be called.
 
 But if the application did not initiate the closure process, or
 if the circumstances above do not apply, this method should be
 called whenever the end of the SSL/TLS data stream is reached.
 This ensures closure of the inbound side, and checks that the
 peer followed the SSL/TLS close procedure properly, thus
 detecting possible truncation attacks.
 
 This method is idempotent:  if the inbound side has already
 been closed, this method does not do anything.
 
wrap() should be
 called to flush any remaining handshake data.

Throws:
SSLException - if this engine has not received the proper SSL/TLS close
          notification message from the peer.
See Also:
isInboundDone(), 
isOutboundDone()


"
12,SSLEngine,5,void closeOutbound(),True,,"

closeOutbound
public abstract void closeOutbound()
Signals that no more outbound application data will be sent
 on this SSLEngine.
 
 This method is idempotent:  if the outbound side has already
 been closed, this method does not do anything.
 
wrap(ByteBuffer, ByteBuffer) should be
 called to flush any remaining handshake data.

See Also:
isOutboundDone()


"
13,SSLEngineResult,1,int bytesConsumed(),True,,"

bytesConsumed
public final int bytesConsumed()
Returns the number of bytes consumed from the input buffer.

Returns:
the number of bytes consumed.


"
13,SSLEngineResult,2,int bytesProduced(),True,,"

bytesProduced
public final int bytesProduced()
Returns the number of bytes written to the output buffer.

Returns:
the number of bytes produced


"
13,SSLEngineResult,3,SSLEngineResult.HandshakeStatus getHandshakeStatus(),True,,"

getHandshakeStatus
public final SSLEngineResult.HandshakeStatus getHandshakeStatus()
Gets the handshake status of this SSLEngine
 operation.

Returns:
the handshake status


"
13,SSLEngineResult,4,SSLEngineResult.Status getStatus(),True,,"

getStatus
public final SSLEngineResult.Status getStatus()
Gets the return value of this SSLEngine operation.

Returns:
the return value


"
13,SSLEngineResult,5,Runnable getHandshakeStatus(),False,,NULL
14,SSLParameters,1,String[] getCipherSuites(),True,,"

getCipherSuites
public String[] getCipherSuites()
Returns a copy of the array of ciphersuites or null if none
 have been set.

Returns:
a copy of the array of ciphersuites or null if none
 have been set.


"
14,SSLParameters,2,String[] getProtocols(),True,,"

getProtocols
public String[] getProtocols()
Returns a copy of the array of protocols or null if none
 have been set.

Returns:
a copy of the array of protocols or null if none
 have been set.


"
14,SSLParameters,3,void setCipherSuites(String[] cipherSuites),True,,"

setCipherSuites
public void setCipherSuites(String[] cipherSuites)
Sets the array of ciphersuites.

Parameters:
cipherSuites - the array of ciphersuites (or null)


"
14,SSLParameters,4,void setProtocols(String[] protocols),True,,"

setProtocols
public void setProtocols(String[] protocols)
Sets the array of protocols.

Parameters:
protocols - the array of protocols (or null)


"
14,SSLParameters,5,void setEndpointIdentificationAlgorithm(String algorithm),True,,"

setEndpointIdentificationAlgorithm
public void setEndpointIdentificationAlgorithm(String algorithm)
Sets the endpoint identification algorithm.
 
 If the algorithm parameter is non-null or non-empty, the
 endpoint identification/verification procedures must be handled during
 SSL/TLS handshaking.  This is to prevent man-in-the-middle attacks.

Parameters:
algorithm - The standard string name of the endpoint
     identification algorithm (or null).  See Appendix A in the 
     Java Cryptography Architecture API Specification & Reference 
     for information about standard algorithm names.
Since:
1.7
See Also:
X509ExtendedTrustManager


"
15,SSLPermission,1,String getName(),False,,NULL
15,SSLPermission,2,boolean implies(Permission permission),False,,NULL
15,SSLPermission,3,SSLPermission(String name),False,,NULL
15,SSLPermission,4,int hashCode(),False,,NULL
15,SSLPermission,5,boolean equals(Object obj),False,,NULL
16,SSLServerSocket,1,SSLParameters getSSLParameters(),True,,"

getSSLParameters
public SSLParameters getSSLParameters()
Returns the SSLParameters in effect for newly accepted connections.
 The ciphersuites and protocols of the returned SSLParameters
 are always non-null.

Returns:
the SSLParameters in effect for newly accepted connections
Since:
1.7
See Also:
setSSLParameters(SSLParameters)


"
16,SSLServerSocket,2,String[] getEnabledCipherSuites(),True,,"

getEnabledCipherSuites
public abstract String[] getEnabledCipherSuites()
Returns the list of cipher suites which are currently enabled
 for use by newly accepted connections.
 
 If this list has not been explicitly modified, a system-provided
 default guarantees a minimum quality of service in all enabled
 cipher suites.
 
 There are several reasons why an enabled cipher suite might
 not actually be used.  For example:  the server socket might
 not have appropriate private keys available to it or the cipher
 suite might be anonymous, precluding the use of client authentication,
 while the server socket has been told to require that sort of
 authentication.

Returns:
an array of cipher suites enabled
See Also:
getSupportedCipherSuites(), 
setEnabledCipherSuites(String [])


"
16,SSLServerSocket,3,String[] getSupportedCipherSuites(),True,,"

getSupportedCipherSuites
public abstract String[] getSupportedCipherSuites()
Returns the names of the cipher suites which could be enabled for use
 on an SSL connection.
 
 Normally, only a subset of these will actually
 be enabled by default, since this list may include cipher suites which
 do not meet quality of service requirements for those defaults.  Such
 cipher suites are useful in specialized applications.

Returns:
an array of cipher suite names
See Also:
getEnabledCipherSuites(), 
setEnabledCipherSuites(String [])


"
16,SSLServerSocket,4,void setNeedClientAuth(boolean need),True,,"

setNeedClientAuth
public abstract void setNeedClientAuth(boolean need)
Controls whether accepted server-mode
 SSLSockets will be initially configured to
 require client authentication.
 
 A socket's client authentication setting is one of the following:
 
 client authentication required
  client authentication requested
  no client authentication desired
 

 Unlike setWantClientAuth(boolean), if the accepted
 socket's option is set and the client chooses not to provide
 authentication information about itself, the negotiations
 will stop and the connection will be dropped.
 
 Calling this method overrides any previous setting made by
 this method or setWantClientAuth(boolean).
 
 The initial inherited setting may be overridden by calling
 SSLSocket.setNeedClientAuth(boolean) or
 SSLSocket.setWantClientAuth(boolean).

Parameters:
need - set to true if client authentication is required,
          or false if no client authentication is desired.
See Also:
getNeedClientAuth(), 
setWantClientAuth(boolean), 
getWantClientAuth(), 
setUseClientMode(boolean)


"
16,SSLServerSocket,5,void setWantClientAuth(boolean want),True,,"

setWantClientAuth
public abstract void setWantClientAuth(boolean want)
Controls whether accepted server-mode
 SSLSockets will be initially configured to
 request client authentication.
 
 A socket's client authentication setting is one of the following:
 
 client authentication required
  client authentication requested
  no client authentication desired
 

 Unlike setNeedClientAuth(boolean), if the accepted
 socket's option is set and the client chooses not to provide
 authentication information about itself, the negotiations
 will continue.
 
 Calling this method overrides any previous setting made by
 this method or setNeedClientAuth(boolean).
 
 The initial inherited setting may be overridden by calling
 SSLSocket.setNeedClientAuth(boolean) or
 SSLSocket.setWantClientAuth(boolean).

Parameters:
want - set to true if client authentication is requested,
          or false if no client authentication is desired.
See Also:
getWantClientAuth(), 
setNeedClientAuth(boolean), 
getNeedClientAuth(), 
setUseClientMode(boolean)


"
17,SSLServerSocketFactory,1,SSLServerSocket createServerSocket(int port),False,,NULL
17,SSLServerSocketFactory,2,"SSLServerSocket createServerSocket(int port, int backlog)",False,,NULL
17,SSLServerSocketFactory,3,"SSLServerSocket createServerSocket(int port, int backlog, InetAddress address)",False,,NULL
17,SSLServerSocketFactory,4,SSLServerSocket createServerSocket(),False,,NULL
17,SSLServerSocketFactory,5,String[] getDefaultCipherSuites(),True,,"

getDefaultCipherSuites
public abstract String[] getDefaultCipherSuites()
Returns the list of cipher suites which are enabled by default.
 Unless a different list is enabled, handshaking on an SSL connection
 will use one of these cipher suites.  The minimum quality of service
 for these defaults requires confidentiality protection and server
 authentication (that is, no anonymous cipher suites).

Returns:
array of the cipher suites enabled by default
See Also:
getSupportedCipherSuites()


"
18,SSLSessionBindingEvent,1,String getName(),True,,"

getName
public String getName()
Returns the name to which the object is being bound, or the name
 from which the object is being unbound.

Returns:
the name to which the object is being bound or unbound


"
18,SSLSessionBindingEvent,2,Object getValue(),False,,NULL
18,SSLSessionBindingEvent,3,SSLSession getSession(),True,,"

getSession
public SSLSession getSession()
Returns the SSLSession into which the listener is being bound or
 from which the listener is being unbound.

Returns:
the SSLSession


"
18,SSLSessionBindingEvent,4,"SSLSessionBindingEvent(SSLSession session, String name)",False,,NULL
18,SSLSessionBindingEvent,5,void valueBound(SSLSessionBindingEvent event),False,,NULL
19,SSLSocket,1,void startHandshake(),True,,"

startHandshake
public abstract void startHandshake()
                             throws IOException
Starts an SSL handshake on this connection.  Common reasons include
 a need to use new encryption keys, to change cipher suites, or to
 initiate a new session.  To force complete reauthentication, the
 current session could be invalidated before starting this handshake.

  If data has already been sent on the connection, it continues
 to flow during this handshake.  When the handshake completes, this
 will be signaled with an event.

 This method is synchronous for the initial handshake on a connection
 and returns when the negotiated handshake is complete. Some
 protocols may not support multiple handshakes on an existing socket
 and may throw an IOException.

Throws:
IOException - on a network level error
See Also:
addHandshakeCompletedListener(HandshakeCompletedListener)


"
19,SSLSocket,2,SSLSession getSession(),True,,"

getSession
public abstract SSLSession getSession()
Returns the SSL Session in use by this connection.  These can
 be long lived, and frequently correspond to an entire login session
 for some user.  The session specifies a particular cipher suite
 which is being actively used by all connections in that session,
 as well as the identities of the session's client and server.
 
 This method will initiate the initial handshake if
 necessary and then block until the handshake has been
 established.
 
 If an error occurs during the initial handshake, this method
 returns an invalid session object which reports an invalid
 cipher suite of ""SSL_NULL_WITH_NULL_NULL"".

Returns:
the SSLSession


"
19,SSLSocket,3,void setEnabledCipherSuites(String[] suites),True,,"

setEnabledCipherSuites
public abstract void setEnabledCipherSuites(String[] suites)
Sets the cipher suites enabled for use on this connection.
 
 Each cipher suite in the suites parameter must have
 been listed by getSupportedCipherSuites(), or the method will
 fail.  Following a successful call to this method, only suites
 listed in the suites parameter are enabled for use.
 
 See getEnabledCipherSuites() for more information
 on why a specific ciphersuite may never be used on a connection.

Parameters:
suites - Names of all the cipher suites to enable
Throws:
IllegalArgumentException - when one or more of the ciphers
          named by the parameter is not supported, or when the
          parameter is null.
See Also:
getSupportedCipherSuites(), 
getEnabledCipherSuites()


"
19,SSLSocket,4,void setEnabledProtocols(String[] protocols),True,,"

setEnabledProtocols
public abstract void setEnabledProtocols(String[] protocols)
Sets the protocol versions enabled for use on this connection.
 
 The protocols must have been listed by
 getSupportedProtocols() as being supported.
 Following a successful call to this method, only protocols listed
 in the protocols parameter are enabled for use.

Parameters:
protocols - Names of all the protocols to enable.
Throws:
IllegalArgumentException - when one or more of
            the protocols named by the parameter is not supported or
            when the protocols parameter is null.
See Also:
getEnabledProtocols()


"
19,SSLSocket,5,void setNeedClientAuth(boolean need),True,,"

setNeedClientAuth
public abstract void setNeedClientAuth(boolean need)
Configures the socket to require client authentication.  This
 option is only useful for sockets in the server mode.
 
 A socket's client authentication setting is one of the following:
 
 client authentication required
  client authentication requested
  no client authentication desired
 

 Unlike setWantClientAuth(boolean), if this option is set and
 the client chooses not to provide authentication information
 about itself, the negotiations will stop and the connection
 will be dropped.
 
 Calling this method overrides any previous setting made by
 this method or setWantClientAuth(boolean).

Parameters:
need - set to true if client authentication is required,
          or false if no client authentication is desired.
See Also:
getNeedClientAuth(), 
setWantClientAuth(boolean), 
getWantClientAuth(), 
setUseClientMode(boolean)


"
20,SSLSocketFactory,1,"SSLSocket createSocket(String host, int port)",False,,NULL
20,SSLSocketFactory,2,"SSLSocket createSocket(InetAddress address, int port)",False,,NULL
20,SSLSocketFactory,3,"SSLSocket createSocket(Socket s, String host, int port, boolean autoClose)",False,,NULL
20,SSLSocketFactory,4,"SSLSocket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort)",False,,NULL
20,SSLSocketFactory,5,"SSLSocket createSocket(Socket s, InputStream consumed, boolean autoClose)",False,,NULL
21,StandardConstants,1,int getSecurityPropertyInt(String property),False,,NULL
21,StandardConstants,2,String getSecurityPropertyString(String property),False,,NULL
21,StandardConstants,3,boolean isConstraintViolationException(Throwable cause),False,,NULL
21,StandardConstants,4,boolean isSecurityPropertySupported(String property),False,,NULL
21,StandardConstants,5,"boolean isSecurityPropertySupported(String property, String value)",False,,NULL
22,TrustManagerFactory,1,String getDefaultAlgorithm(),True,,"

getDefaultAlgorithm
public static final String getDefaultAlgorithm()
Obtains the default TrustManagerFactory algorithm name.

 The default TrustManager can be changed at runtime by setting
 the value of the ssl.TrustManagerFactory.algorithm
 security property to the desired algorithm name.

Returns:
the default algorithm name as specified by the
 ssl.TrustManagerFactory.algorithm security property, or an
 implementation-specific default if no such property exists.
See Also:
security properties


"
22,TrustManagerFactory,2,TrustManager[] getTrustManagers(),True,,"

getTrustManagers
public final TrustManager[] getTrustManagers()
Returns one trust manager for each type of trust material.

Returns:
the trust managers
Throws:
IllegalStateException - if the factory is not initialized.


"
22,TrustManagerFactory,3,String getAlgorithm(),True,,"

getAlgorithm
public final String getAlgorithm()
Returns the algorithm name of this TrustManagerFactory
 object.

 This is the same name that was specified in one of the
 getInstance calls that created this
 TrustManagerFactory object.

Returns:
the algorithm name of this TrustManagerFactory
          object


"
22,TrustManagerFactory,4,void init(KeyStore ks),True,,"

init
public final void init(KeyStore ks)
                throws KeyStoreException
Initializes this factory with a source of certificate
 authorities and related trust material.
 
 The provider typically uses a KeyStore as a basis for making
 trust decisions.
 
 For more flexible initialization, please see
 init(ManagerFactoryParameters).

Parameters:
ks - the key store, or null
Throws:
KeyStoreException - if this operation fails


"
22,TrustManagerFactory,5,void init(ManagerFactoryParameters spec),True,,"

init
public final void init(ManagerFactoryParameters spec)
                throws InvalidAlgorithmParameterException
Initializes this factory with a source of provider-specific
 trust material.
 
 In some cases, initialization parameters other than a keystore
 may be needed by a provider.  Users of that particular provider
 are expected to pass an implementation of the appropriate
 ManagerFactoryParameters as defined by the
 provider.  The provider can then call the specified methods in
 the ManagerFactoryParameters implementation to obtain the
 needed information.

Parameters:
spec - an implementation of a provider-specific parameter
          specification
Throws:
InvalidAlgorithmParameterException - if an error is
          encountered


"
23,TrustManagerFactorySpi,1,TrustManager[] engineGetTrustManagers(),True,,"

engineGetTrustManagers
protected abstract TrustManager[] engineGetTrustManagers()
Returns one trust manager for each type of trust material.

Returns:
the trust managers
Throws:
IllegalStateException - if the factory is not initialized.


"
23,TrustManagerFactorySpi,2,void engineInit(KeyStore ks),True,,"

engineInit
protected abstract void engineInit(KeyStore ks)
                            throws KeyStoreException
Initializes this factory with a source of certificate
 authorities and related trust material.

Parameters:
ks - the key store or null
Throws:
KeyStoreException - if this operation fails
See Also:
TrustManagerFactory.init(KeyStore)


"
23,TrustManagerFactorySpi,3,void engineInit(ManagerFactoryParameters spec),True,,"

engineInit
protected abstract void engineInit(ManagerFactoryParameters spec)
                            throws InvalidAlgorithmParameterException
Initializes this factory with a source of provider-specific
 key material.
 
 In some cases, initialization parameters other than a keystore
 may be needed by a provider.  Users of that
 particular provider are expected to pass an implementation of
 the appropriate ManagerFactoryParameters as
 defined by the provider.  The provider can then call the
 specified methods in the ManagerFactoryParameters
 implementation to obtain the needed information.

Parameters:
spec - an implementation of a provider-specific parameter
          specification
Throws:
InvalidAlgorithmParameterException - if there is problem
          with the parameters
See Also:
TrustManagerFactory.init(ManagerFactoryParameters spec)


"
23,TrustManagerFactorySpi,4,TrustManagerFactorySpi engineGetInstance(String algorithm),False,,NULL
23,TrustManagerFactorySpi,5,String engineGetAlgorithm(),False,,NULL
24,X509ExtendedKeyManager,1,"String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket)",False,,NULL
24,X509ExtendedKeyManager,2,"String chooseServerAlias(String keyType, Principal[] issuers, Socket socket)",False,,NULL
24,X509ExtendedKeyManager,3,X509Certificate[] getCertificateChain(String alias),False,,NULL
24,X509ExtendedKeyManager,4,"String[] getClientAliases(String keyType, Principal[] issuers)",False,,NULL
24,X509ExtendedKeyManager,5,"String[] getServerAliases(String keyType, Principal[] issuers)",False,,NULL
25,X509ExtendedTrustManager,1,"void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket)",True,,"

checkClientTrusted
public abstract void checkClientTrusted(X509Certificate[] chain,
                                        String authType,
                                        Socket socket)
                                 throws CertificateException
Given the partial or complete certificate chain provided by the
 peer, build and validate the certificate path based on the
 authentication type and ssl parameters.
 
 The authentication type is determined by the actual certificate
 used. For instance, if RSAPublicKey is used, the authType
 should be ""RSA"". Checking is case-sensitive.
 
 If the socket parameter is an instance of
 SSLSocket, and the endpoint identification
 algorithm of the SSLParameters is non-empty, to prevent
 man-in-the-middle attacks, the address that the socket
 connected to should be checked against the peer's identity presented
 in the end-entity X509 certificate, as specified in the endpoint
 identification algorithm.
 
 If the socket parameter is an instance of
 SSLSocket, and the algorithm constraints of the
 SSLParameters is non-null, for every certificate in the
 certification path, fields such as subject public key, the signature
 algorithm, key usage, extended key usage, etc. need to conform to the
 algorithm constraints in place on this socket.

Parameters:
chain - the peer certificate chain
authType - the key exchange algorithm used
socket - the socket used for this connection. This parameter
        can be null, which indicates that implementations need not check
        the ssl parameters
Throws:
IllegalArgumentException - if null or zero-length array is passed
        in for the chain parameter or if null or zero-length
        string is passed in for the authType parameter
CertificateException - if the certificate chain is not trusted
        by this TrustManager
See Also:
SSLParameters.getEndpointIdentificationAlgorithm(), 
SSLParameters.setEndpointIdentificationAlgorithm(String), 
SSLParameters.getAlgorithmConstraints(), 
SSLParameters.setAlgorithmConstraints(AlgorithmConstraints)


"
25,X509ExtendedTrustManager,2,"void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket)",True,,"

checkServerTrusted
public abstract void checkServerTrusted(X509Certificate[] chain,
                                        String authType,
                                        Socket socket)
                                 throws CertificateException
Given the partial or complete certificate chain provided by the
 peer, build and validate the certificate path based on the
 authentication type and ssl parameters.
 
 The authentication type is the key exchange algorithm portion
 of the cipher suites represented as a String, such as ""RSA"",
 ""DHE_DSS"". Note: for some exportable cipher suites, the key
 exchange algorithm is determined at run time during the
 handshake. For instance, for TLS_RSA_EXPORT_WITH_RC4_40_MD5,
 the authType should be RSA_EXPORT when an ephemeral RSA key is
 used for the key exchange, and RSA when the key from the server
 certificate is used. Checking is case-sensitive.
 
 If the socket parameter is an instance of
 SSLSocket, and the endpoint identification
 algorithm of the SSLParameters is non-empty, to prevent
 man-in-the-middle attacks, the address that the socket
 connected to should be checked against the peer's identity presented
 in the end-entity X509 certificate, as specified in the endpoint
 identification algorithm.
 
 If the socket parameter is an instance of
 SSLSocket, and the algorithm constraints of the
  SSLParameters is non-null, for every certificate in the
 certification path, fields such as subject public key, the signature
 algorithm, key usage, extended key usage, etc. need to conform to the
 algorithm constraints in place on this socket.

Parameters:
chain - the peer certificate chain
authType - the key exchange algorithm used
socket - the socket used for this connection. This parameter
        can be null, which indicates that implementations need not check
        the ssl parameters
Throws:
IllegalArgumentException - if null or zero-length array is passed
        in for the chain parameter or if null or zero-length
        string is passed in for the authType parameter
CertificateException - if the certificate chain is not trusted
        by this TrustManager
See Also:
SSLParameters.getEndpointIdentificationAlgorithm(), 
SSLParameters.setEndpointIdentificationAlgorithm(String), 
SSLParameters.getAlgorithmConstraints(), 
SSLParameters.setAlgorithmConstraints(AlgorithmConstraints)


"
25,X509ExtendedTrustManager,3,"void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine)",True,,"

checkClientTrusted
public abstract void checkClientTrusted(X509Certificate[] chain,
                                        String authType,
                                        SSLEngine engine)
                                 throws CertificateException
Given the partial or complete certificate chain provided by the
 peer, build and validate the certificate path based on the
 authentication type and ssl parameters.
 
 The authentication type is determined by the actual certificate
 used. For instance, if RSAPublicKey is used, the authType
 should be ""RSA"". Checking is case-sensitive.
 
 If the engine parameter is available, and the endpoint
 identification algorithm of the SSLParameters is
 non-empty, to prevent man-in-the-middle attacks, the address that
 the engine connected to should be checked against
 the peer's identity presented in the end-entity X509 certificate,
 as specified in the endpoint identification algorithm.
 
 If the engine parameter is available, and the algorithm
 constraints of the SSLParameters is non-null, for every
 certificate in the certification path, fields such as subject public
 key, the signature algorithm, key usage, extended key usage, etc.
 need to conform to the algorithm constraints in place on this engine.

Parameters:
chain - the peer certificate chain
authType - the key exchange algorithm used
engine - the engine used for this connection. This parameter
        can be null, which indicates that implementations need not check
        the ssl parameters
Throws:
IllegalArgumentException - if null or zero-length array is passed
        in for the chain parameter or if null or zero-length
        string is passed in for the authType parameter
CertificateException - if the certificate chain is not trusted
        by this TrustManager
See Also:
SSLParameters.getEndpointIdentificationAlgorithm(), 
SSLParameters.setEndpointIdentificationAlgorithm(String), 
SSLParameters.getAlgorithmConstraints(), 
SSLParameters.setAlgorithmConstraints(AlgorithmConstraints)


"
25,X509ExtendedTrustManager,4,"void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine)",True,,"

checkServerTrusted
public abstract void checkServerTrusted(X509Certificate[] chain,
                                        String authType,
                                        SSLEngine engine)
                                 throws CertificateException
Given the partial or complete certificate chain provided by the
 peer, build and validate the certificate path based on the
 authentication type and ssl parameters.
 
 The authentication type is the key exchange algorithm portion
 of the cipher suites represented as a String, such as ""RSA"",
 ""DHE_DSS"". Note: for some exportable cipher suites, the key
 exchange algorithm is determined at run time during the
 handshake. For instance, for TLS_RSA_EXPORT_WITH_RC4_40_MD5,
 the authType should be RSA_EXPORT when an ephemeral RSA key is
 used for the key exchange, and RSA when the key from the server
 certificate is used. Checking is case-sensitive.
 
 If the engine parameter is available, and the endpoint
 identification algorithm of the SSLParameters is
 non-empty, to prevent man-in-the-middle attacks, the address that
 the engine connected to should be checked against
 the peer's identity presented in the end-entity X509 certificate,
 as specified in the endpoint identification algorithm.
 
 If the engine parameter is available, and the algorithm
 constraints of the SSLParameters is non-null, for every
 certificate in the certification path, fields such as subject public
 key, the signature algorithm, key usage, extended key usage, etc.
 need to conform to the algorithm constraints in place on this engine.

Parameters:
chain - the peer certificate chain
authType - the key exchange algorithm used
engine - the engine used for this connection. This parameter
        can be null, which indicates that implementations need not check
        the ssl parameters
Throws:
IllegalArgumentException - if null or zero-length array is passed
        in for the chain parameter or if null or zero-length
        string is passed in for the authType parameter
CertificateException - if the certificate chain is not trusted
        by this TrustManager
See Also:
SSLParameters.getEndpointIdentificationAlgorithm(), 
SSLParameters.setEndpointIdentificationAlgorithm(String), 
SSLParameters.getAlgorithmConstraints(), 
SSLParameters.setAlgorithmConstraints(AlgorithmConstraints)


"
25,X509ExtendedTrustManager,5,X509Certificate[] getAcceptedIssuers(),False,,NULL
